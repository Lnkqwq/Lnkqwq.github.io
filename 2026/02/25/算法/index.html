<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>算法 | Hexo</title><meta name="keywords" content="C++"><meta name="description" content="排序  冒泡排序  一、基本思想 冒泡排序就是模拟这个过程：  从数组的第一个元素开始，依次比较相邻的两个元素。 如果它们的顺序错了（比如前一个比后一个大，而我们想升序排序），就交换它们。 这样 一轮比较下来，最大的元素就会“冒”到数组的最后一位。 重复这个过程，每次忽略已经排好序的尾部元素，直到整个数组有序。   二、核心操作：比较与交换 这是冒泡排序的灵魂： 1234567if (arr[j">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="http://example.com/2026/02/25/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="排序  冒泡排序  一、基本思想 冒泡排序就是模拟这个过程：  从数组的第一个元素开始，依次比较相邻的两个元素。 如果它们的顺序错了（比如前一个比后一个大，而我们想升序排序），就交换它们。 这样 一轮比较下来，最大的元素就会“冒”到数组的最后一位。 重复这个过程，每次忽略已经排好序的尾部元素，直到整个数组有序。   二、核心操作：比较与交换 这是冒泡排序的灵魂： 1234567if (arr[j">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2026-02-25T09:23:28.000Z">
<meta property="article:modified_time" content="2026-02-27T12:52:49.843Z">
<meta property="article:author" content="Lnk">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.woff2"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><meta name="page-config" content="{&quot;code_fold&quot;:null}"><script class="pjax-js">var config = {"root":"/","code_fold":15,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}};
var page_config = {
  code_fold: null
};
function updatePageConfig() {
  var newPageConfig = document.querySelector('meta[name="page-config"]');
  if (newPageConfig) {
    page_config = JSON.parse(newPageConfig.content);
  }
}
document.addEventListener('pjax:complete', function() { updatePageConfig(); });
updatePageConfig();</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@11.12.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('/images/BK.PNG');
 --light-background: url('/images/BK.PNG');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@11.12.2/dist/mermaid.esm.min.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.vercount','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {window.giscusSettings = {
 repo: 'Lnkqwq/Lnkqwq.github.io',
 repoId: 'R_kgDORZSSAA',
 category: '',
 categoryId: '',
 mapping: 'pathname',
 strict: '0',
 reactionsEnabled: '1',
 emitMetadata: '0',
 inputPosition: 'bottom',
 lang: 'zh-CN',
 crossorigin: 'anonymous' , loading: 'lazy'};window.giscusThemeConfig = { theme: 'preferred_color_scheme' };MathJax.Hub.Queue(["Typeset", MathJax.Hub]);document.querySelector('.lg-container')?.remove()
const postBg = document.querySelector('#post-bg');
if (postBg) lightGallery(postBg, {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.vercount','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>算法</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2026-02-25T09:23:28.000Z" id="date"> 2026-02-25</time></div></span><br><span>Last Update: <div class="control"><time datetime="2026-02-27T12:52:49.843Z" id="updated"> 2026-02-27</time></div></span></div></div><hr><div id="post-content"><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2>
<hr />
<p>一、基本思想</p>
<p>冒泡排序就是模拟这个过程：</p>
<ol>
<li>从数组的第一个元素开始，依次比较相邻的两个元素。</li>
<li>如果它们的顺序错了（比如前一个比后一个大，而我们想升序排序），就交换它们。</li>
<li>这样 一轮比较下来，最大的元素就会“冒”到数组的最后一位。</li>
<li>重复这个过程，每次忽略已经排好序的尾部元素，直到整个数组有序。</li>
</ol>
<hr />
<p>二、核心操作：比较与交换</p>
<p>这是冒泡排序的灵魂：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-comment">// 交换它们</span><br>    <span class="hljs-type">int</span> temp = arr[j];<br>    arr[j] = arr[j + <span class="hljs-number">1</span>];<br>    arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<hr />
<p>三、C++ 代码实现（基础版）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 外层循环：控制需要多少轮冒泡</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 内层循环：进行相邻元素的比较和交换</span><br>        <span class="hljs-comment">// 注意：j &lt; n - 1 - i，因为最后i个元素已经排好了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 交换arr[j]和arr[j+1]</span><br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>&#125;;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;排序前: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-built_in">bubbleSort</span>(arr);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;排序后: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">排序前: 64 34 25 12 22 11 90<br>排序后: 11 12 22 25 34 64 90<br><br></code></pre></td></tr></table></figure>
<hr />
<p>四、优化版本</p>
<p>基础版本即使数组已经有序，也会完整执行所有轮次。我们可以添加一个标志来优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSortOptimized</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">bool</span> swapped; <span class="hljs-comment">// 记录本轮是否发生过交换</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        swapped = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>                swapped = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 发生了交换</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果本轮没有发生任何交换，说明数组已经有序</span><br>        <span class="hljs-keyword">if</span> (!swapped) &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 提前结束</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>优化效果：</p>
<p>· 对于已经有序的数组，只需要一轮扫描（O(n)）<br />
· 基础版则固定需要 O(n²) 次比较</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2>
<hr />
<p>一、基本思想</p>
<p>选择排序的核心思想是 “选择最小（或最大）的元素，放到它应该在的位置”。</p>
<p>想象一下在整理一副扑克牌：</p>
<ol>
<li>先扫描所有牌，找到最小的一张</li>
<li>把这张牌放到最左边</li>
<li>在剩下的牌中继续找最小的</li>
<li>放到已排序部分的后面</li>
<li>重复直到所有牌都排好</li>
</ol>
<hr />
<p>二、算法步骤（升序排序）</p>
<ol>
<li>将数组分为两部分：<br />
· 已排序部分（初始为空，在左边）<br />
· 未排序部分（初始为整个数组，在右边）</li>
<li>在未排序部分中找到最小元素的索引</li>
<li>将这个最小元素与未排序部分的第一个元素交换</li>
<li>这时，未排序部分的第一个元素就加入了已排序部分</li>
<li>重复步骤2-4，直到未排序部分为空</li>
</ol>
<hr />
<p>三、C++ 代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 外层循环：控制已排序部分的边界</span><br>    <span class="hljs-comment">// i 表示：arr[0...i-1] 是已排序的，arr[i...n-1] 是未排序的</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 假设当前位置 i 就是最小元素的位置</span><br>        <span class="hljs-type">int</span> minIndex = i;<br><br>        <span class="hljs-comment">// 内层循环：在未排序部分中寻找真正的最小元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;  <span class="hljs-comment">// 更新最小元素的索引</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将找到的最小元素交换到正确位置 i</span><br>        <span class="hljs-keyword">if</span> (minIndex != i) &#123;<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[minIndex]);<br>        &#125;<br><br>        <span class="hljs-comment">// 此时，arr[i] 已排好，加入到已排序部分</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">64</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>&#125;;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;排序前: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-built_in">selectionSort</span>(arr);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;排序后: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">排序前: 64 25 12 22 11<br>排序后: 11 12 22 25 64<br><br></code></pre></td></tr></table></figure>
<hr />
<p>四、优化版本</p>
<p>虽然选择排序时间复杂度固定，但我们可以优化交换操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSortOptimized</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> minIndex = i;<br><br>        <span class="hljs-comment">// 找到最小元素的索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 只有当最小元素不在当前位置时才交换</span><br>        <span class="hljs-keyword">if</span> (minIndex != i) &#123;<br>            <span class="hljs-comment">// 使用三次异或交换（无临时变量）</span><br>            arr[i] = arr[i] ^ arr[minIndex];<br>            arr[minIndex] = arr[i] ^ arr[minIndex];<br>            arr[i] = arr[i] ^ arr[minIndex];<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>注意：异或交换虽然酷，但在实际工程中不推荐使用（可读性差，且对相同元素会出错）。</p>
<hr />
<p>五、变体：双向选择排序（鸡尾酒选择排序）</p>
<hr />
<p>优化思路：同时找最小值和最大值，最小值放左边，最大值放右边，从两头向中间推进。</p>
<hr />
<p>版本1：最直观但错误的版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本1：直观但有问题</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bidirectional_v1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> minIndex = left, maxIndex = right;  <span class="hljs-comment">// ❌ 问题1：maxIndex初始化为right</span><br><br>        <span class="hljs-comment">// 找最小值和最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[minIndex]) minIndex = i;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[maxIndex]) maxIndex = i;  <span class="hljs-comment">// ❌ 可能找不到真正的最大值</span><br>        &#125;<br><br>        <span class="hljs-comment">// 交换最小值到左边</span><br>        <span class="hljs-keyword">if</span> (minIndex != left) <span class="hljs-built_in">swap</span>(arr[left], arr[minIndex]);<br><br>        <span class="hljs-comment">// 交换最大值到右边</span><br>        <span class="hljs-keyword">if</span> (maxIndex != right) <span class="hljs-built_in">swap</span>(arr[right], arr[maxIndex]);<br><br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>问题1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//交换最小值时最大值位置变了</span><br></code></pre></td></tr></table></figure>
<hr />
<p>版本2 两次交换之间插入说明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本3：考虑交换最小值对最大值位置的影响</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bidirectional_v3</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> minIndex = left, maxIndex = left;<br><br>        <span class="hljs-comment">// 找最小值和最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[minIndex]) minIndex = i;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[maxIndex]) maxIndex = i;<br>        &#125;<br><br>        <span class="hljs-comment">// 交换最小值到左边</span><br>        <span class="hljs-keyword">if</span> (minIndex != left) <span class="hljs-built_in">swap</span>(arr[left], arr[minIndex]);<br><br>        <span class="hljs-comment">// 关键修复：如果最大值在left，它现在在minIndex</span><br>        <span class="hljs-keyword">if</span> (maxIndex == left) &#123;<br>            maxIndex = minIndex;<br>        &#125;<br><br>        <span class="hljs-comment">// 交换最大值到右边</span><br>        <span class="hljs-keyword">if</span> (maxIndex != right) <span class="hljs-built_in">swap</span>(arr[right], arr[maxIndex]);<br><br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>问题2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//边界重叠问题：</span><br><span class="hljs-comment">//// 第一步：if (minIndex != left) → 1 != 0 成立</span><br><span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]) → [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-comment">// 第二步：if (maxIndex == left) → 0 == 0 成立</span><br>maxIndex = minIndex = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 第三步：if (maxIndex != right) → 1 != 1 ❌ 不成立！</span><br><span class="hljs-comment">// 不执行交换！maxIndex现在是1，right也是1</span><br><span class="hljs-comment">// 但问题是：最大值2已经在正确位置了吗？</span><br><span class="hljs-comment">// 查看数组：[1, 2] ✓ 2确实在最后，但这是巧合！</span><br><br>问题：当 maxIndex 被更新为 minIndex，而 minIndex == right 时，版本<span class="hljs-number">2</span>的 <span class="hljs-keyword">if</span> (maxIndex != right) 会阻止交换，但有时这是需要的！<br></code></pre></td></tr></table></figure>
<hr />
<p>版本3：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bidirectional_v4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> minIndex = left, maxIndex = left;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[minIndex]) minIndex = i;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[maxIndex]) maxIndex = i;<br>        &#125;<br><br>        <span class="hljs-comment">// 交换最小值</span><br>        <span class="hljs-built_in">swap</span>(arr[left], arr[minIndex]);  <span class="hljs-comment">// 移除了if判断</span><br><br>        <span class="hljs-comment">// 更新最大值位置</span><br>        <span class="hljs-keyword">if</span> (maxIndex == left) &#123;<br>            maxIndex = minIndex;<br>        &#125;<br><br>        <span class="hljs-comment">// 交换最大值</span><br>        <span class="hljs-built_in">swap</span>(arr[right], arr[maxIndex]);  <span class="hljs-comment">// 移除了if判断</span><br><br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr />
<p>版本4：最终修复版（处理所有边界）<br />
// 版本5：最终正确版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bidirectionalSelectionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-type">int</span> minIndex = left, maxIndex = left;<br><br>        <span class="hljs-comment">// 查找最小值和最大值的索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;<br>                minIndex = i;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[maxIndex]) &#123;<br>                maxIndex = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 交换最小值到left位置</span><br>        <span class="hljs-built_in">swap</span>(arr[left], arr[minIndex]);<br><br>        <span class="hljs-comment">// 关键：如果最大值在left，它现在在minIndex</span><br>        <span class="hljs-comment">// 但如果minIndex == right，会有问题！</span><br>        <span class="hljs-keyword">if</span> (maxIndex == left) &#123;<br>            maxIndex = minIndex;<br>        &#125;<br><br>        <span class="hljs-comment">// 交换最大值到right位置</span><br>        <span class="hljs-built_in">swap</span>(arr[right], arr[maxIndex]);<br><br>        <span class="hljs-comment">// 收缩边界</span><br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h2>
<hr />
<p>一、基本思想</p>
<p>插入排序模拟了整理扑克牌的过程：</p>
<p>想象手里有一堆乱序的牌：</p>
<ol>
<li>从第二张牌开始（假设第一张已经在&quot;手&quot;里了）</li>
<li>拿起一张新牌</li>
<li>从右向左与手中的牌比较</li>
<li>找到合适的位置插入</li>
<li>重复直到所有牌都插入</li>
</ol>
<p>一句话总结：将每个新元素插入到已排序部分的正确位置。</p>
<hr />
<p>二、算法步骤</p>
<ol>
<li>将数组分为两部分：<br />
· 已排序部分（初始只有第一个元素）<br />
· 未排序部分（其余元素）</li>
<li>依次从未排序部分取元素</li>
<li>在已排序部分中从后往前扫描，找到插入位置</li>
<li>将大于该元素的都向右移动一位</li>
<li>插入该元素到正确位置</li>
</ol>
<hr />
<p>三、C++ 代码实现</p>
<p>基础版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 从第二个元素开始（下标1）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> key = arr[i];  <span class="hljs-comment">// 当前要插入的元素</span><br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;     <span class="hljs-comment">// 从已排序部分的最后一个开始比较</span><br><br>        <span class="hljs-comment">// 将比key大的元素都向右移动一位</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br><br>        <span class="hljs-comment">// 插入key到正确位置</span><br>        arr[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;排序前: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-built_in">insertionSort</span>(arr);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;排序后: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">排序前: 12 11 13 5 6<br>排序后: 5 6 11 12 13<br><br></code></pre></td></tr></table></figure>
<hr />
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2>
<hr />
<p>一、核心思想：分而治之</p>
<p>快速排序的核心是 “Divide and Conquer”：</p>
<ol>
<li>分解：选一个&quot;基准&quot;元素，将数组分成两个子数组<br />
· 左边：所有比基准小的元素<br />
· 右边：所有比基准大的元素<br />
· 基准在中间正确位置</li>
<li>解决：递归地对左右子数组进行快速排序</li>
<li>合并：不需要！因为原址排序，排完后自然有序</li>
</ol>
<hr />
<p>二、基本步骤（Partition操作是关键）</p>
<p>以最经典的 Lomuto分区方案 为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Partition的直观理解：像整理书架</span><br><span class="hljs-comment">// [比pivot小的书] pivot [比pivot大的书]</span><br><br></code></pre></td></tr></table></figure>
<hr />
<p>三、C++代码实现（Lomuto分区）</p>
<p>基础版本（每次取最后一个做基准，小的放左大的放右，基准归位，左右递归！）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 分区函数：返回pivot的最终位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[high];  <span class="hljs-comment">// 选择最后一个元素作为pivot</span><br>    <span class="hljs-type">int</span> i = low - <span class="hljs-number">1</span>;        <span class="hljs-comment">// i指向小于pivot区域的边界</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = low; j &lt; high; j++) &#123;<br>        <span class="hljs-comment">// 如果当前元素小于等于pivot</span><br>        <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) &#123;<br>            i++;  <span class="hljs-comment">// 扩大小于pivot的区域</span><br>            <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将pivot放到正确位置</span><br>    <span class="hljs-built_in">swap</span>(arr[i + <span class="hljs-number">1</span>], arr[high]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 返回pivot的位置</span><br>&#125;<br><br><span class="hljs-comment">// 快速排序主函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-comment">// pi是pivot的正确位置</span><br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partition</span>(arr, low, high);<br><br>        <span class="hljs-comment">// 递归排序左半部分和右半部分</span><br>        <span class="hljs-built_in">quickSort</span>(arr, low, pi - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, pi + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 包装函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">quickSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;原始数组: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-built_in">quickSort</span>(arr);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;排序后: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">原始数组: 10 7 8 9 1 5<br>排序后: 1 5 7 8 9 10<br><br></code></pre></td></tr></table></figure>
<hr />
<p>四、更高效的Hoare分区方案</p>
<p>Lomuto方案简单但交换次数多。Hoare方案更高效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Hoare分区 - 更少的交换，更高效</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partitionHoare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[low];  <span class="hljs-comment">// 选择第一个元素作为pivot</span><br>    <span class="hljs-type">int</span> i = low - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j = high + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 从左找第一个大于等于pivot的元素</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            i++;<br>        &#125; <br>        <span class="hljs-keyword">while</span> (arr[i] &lt; pivot);<br><br>        <span class="hljs-comment">// 从右找第一个小于等于pivot的元素</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            j--;<br>        &#125; <br>        <span class="hljs-keyword">while</span> (arr[j] &gt; pivot);<br><br>        <span class="hljs-comment">// 如果指针相遇，返回j</span><br>        <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">return</span> j;<br><br>        <span class="hljs-comment">// 交换这两个错位的元素</span><br>        <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortHoare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partitionHoare</span>(arr, low, high);<br>        <span class="hljs-built_in">quickSortHoare</span>(arr, low, pi);      <span class="hljs-comment">// 注意：包含pi</span><br>        <span class="hljs-built_in">quickSortHoare</span>(arr, pi + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<hr />
<p>五、📊 快排的pivot极端情况</p>
<p>🏆 最好的pivot：中位数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[1, 2, 3, 4, 5, 6, 7, 8]<br>选pivot=4或5<br>结果：左边3个，右边4个 → 完美平衡<br>递归深度：log₂n ≈ 3层<br>时间复杂度：O(n log n) ✅ 最快<br></code></pre></td></tr></table></figure>
<p>💀 最差的pivot：最大/最小值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[1, 2, 3, 4, 5, 6, 7, 8]<br>选pivot=1或8<br>结果：左边0个，右边7个（或相反）→ 极度不平衡<br>递归深度：n ≈ 8层<br>时间复杂度：O(n²) ❌ 最慢<br></code></pre></td></tr></table></figure>
<hr />
<p>🎯 最好vs最差：一图胜千言</p>
<p>最好情况（中位数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">第1层: [1,2,3,4,5,6,7,8] → pivot=4<br>        /           \\<br>[1,2,3,4]         [5,6,7,8]  ✓ 两边均匀<br>第2层: 再分 → 4个子数组<br>第3层: 再分 → 8个子数组（完成）<br></code></pre></td></tr></table></figure>
<p>最差情况（最大/最小值）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">第1层: [1,2,3,4,5,6,7,8] → pivot=1<br>        /<br>      []    [2,3,4,5,6,7,8]  ❌ 一边倒<br><br>第2层: [2,3,4,5,6,7,8] → pivot=2<br>        /<br>      []    [3,4,5,6,7,8]    ❌ 继续倒<br><br>... 一直倒到结束，像冒泡排序一样慢<br></code></pre></td></tr></table></figure>
<hr />
<p>🔥 为什么中位数最好？</p>
<p>因为每次都能把数组对半切：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">n = 8<br>第1层: 8个 → 4个 + 4个<br>第2层: 4个 → 2个 + 2个<br>第3层: 2个 → 1个 + 1个<br>总层数: log₂8 = 3<br></code></pre></td></tr></table></figure>
<p>为什么最差是最大/最小值？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">n = 8<br>第1层: 8个 → 0个 + 7个<br>第2层: 7个 → 0个 + 6个<br>第3层: 6个 → 0个 + 5个<br>...<br>总层数: 8 = n<br></code></pre></td></tr></table></figure>
<hr />
<p>📈 时间复杂度对比</p>
<p>pivot    递归深度   总时间       举例<br />
中位数     log₂n   O(n log n)   50ms<br />
随机 期望  log₂n   O(n log n)   50-60ms<br />
最大/最小    n        O(n²)     2500ms</p>
<hr />
<p>🎲 为什么随机pivot能救？</p>
<p>固定选最后一个：</p>
<p>· 已排序数组 → 100%是最差pivot ❌</p>
<p>随机选：</p>
<p>· 第一次选到最差概率：2/n<br />
· 连续选到最差概率：(2/n)ⁿ → 几乎为0</p>
<p>数学保你不死！ ✅</p>
<p>💎 一句话总结</p>
<p>最好pivot是正中靶心的中位数，最差pivot是擦边过的大/最小值——前者一剑封喉，后者钝刀割肉。 🎯</p>
<hr />
<p>六、优化策略</p>
<ol>
<li>随机化pivot选择（避免最坏情况）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partitionRandom</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-comment">// 随机选择一个pivot</span><br>    <span class="hljs-type">int</span> randomIndex = low + <span class="hljs-built_in">rand</span>() % (high - low + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">swap</span>(arr[randomIndex], arr[high]);  <span class="hljs-comment">// 放到最后，方便Lomuto分区</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(arr, low, high);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>三数取中法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">medianOfThree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 对arr[low], arr[mid], arr[high]排序</span><br>    <span class="hljs-keyword">if</span> (arr[low] &gt; arr[mid]) <span class="hljs-built_in">swap</span>(arr[low], arr[mid]);<br>    <span class="hljs-keyword">if</span> (arr[low] &gt; arr[high]) <span class="hljs-built_in">swap</span>(arr[low], arr[high]);<br>    <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[high]) <span class="hljs-built_in">swap</span>(arr[mid], arr[high]);<br><br>    <span class="hljs-comment">// 将中位数放到high位置</span><br>    <span class="hljs-built_in">swap</span>(arr[mid], arr[high]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(arr, low, high);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ol start="3">
<li>小数组使用插入排序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortOptimized</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-comment">// 小数组用插入排序更快</span><br>    <span class="hljs-keyword">if</span> (high - low + <span class="hljs-number">1</span> &lt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-built_in">insertionSort</span>(arr, low, high);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partitionRandom</span>(arr, low, high);<br>        <span class="hljs-built_in">quickSortOptimized</span>(arr, low, pi - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSortOptimized</span>(arr, pi + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h2>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h2>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h2>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a><a class="markdownIt-Anchor" href="#搜索"></a> 搜索</h1>
<h2 id="线性搜索"><a href="#线性搜索" class="headerlink" title="线性搜索"></a><a class="markdownIt-Anchor" href="#线性搜索"></a> 线性搜索</h2>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a><a class="markdownIt-Anchor" href="#二分搜索"></a> 二分搜索</h2>
<h2 id="插值搜索"><a href="#插值搜索" class="headerlink" title="插值搜索"></a><a class="markdownIt-Anchor" href="#插值搜索"></a> 插值搜索</h2>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a><a class="markdownIt-Anchor" href="#跳表"></a> 跳表</h2>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2026/02/26/linux%E6%8C%87%E4%BB%A4-shell%E8%84%9A%E6%9C%AC/">← Next linux指令&amp;shell脚本</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2026/02/25/vcpkg-CMake/">vcpkg&amp;CMake Prev →</a></div></div></div><details id="reward"><summary>reward</summary><div><span>微信 | Wechat</span><br><img src="/images/WeChat.png"></div><div><span>支付宝 | Alipay</span><br><img src="/images/Alipay.png"></div></details><div id="comments"><div id="giscus"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" onClick="tocControl.change()" title="To Catalog"><span class="tocBtnIconBar"></span><span class="tocBtnIconBar"></span><span class="tocBtnIconBar"></span></a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a><a onclick="BgmControl()"><svg id="bgm-control" viewBox="0 0 30 34" fill="#18d1ff" style="width: 24px; transition: transform .3s;margin-top: 4px"><path d="M25.998 23.422V11.29h3.999v12.132h-3.999zM19.497 6.234h4.001v22.243h-4.001V6.234zM12.998.867h4v32.978h-4V.867zm-6.5 5.367h4.001v22.243H6.498V6.234zm-6.5 5.056h4v12.132h-4V11.29z"></path></svg><audio id="bgm" src="/audio/bgm.mp3" autoplay loop crossorigin="anonymous"> </audio></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/images/1.jpg" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">Lnk</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/Lnkqwq"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="3403583728@qq.com"><i class="fa fa-envelope" alt="E-Mail"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text"> 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text"> 冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text"> 选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text"> 插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text"> 快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text"> 归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text"> 堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text"> 计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text"> 基数排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">2.</span> <span class="toc-text"> 搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2"><span class="toc-number">2.1.</span> <span class="toc-text"> 线性搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">2.2.</span> <span class="toc-text"> 二分搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%90%9C%E7%B4%A2"><span class="toc-number">2.3.</span> <span class="toc-text"> 插值搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text"> 跳表</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>
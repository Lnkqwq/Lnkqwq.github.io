[{"title":"CF","url":"/2026/02/27/CF/","content":"","categories":["-CF"]},{"title":"Database","url":"/2026/02/27/Database/","content":"","categories":["-database"]},{"title":"数学分析","url":"/2026/02/26/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/","content":" 一、实数集与函数\n 1. 实数及其性质\n性质 1（封闭性）\n实数集对加、减、乘、除（除数非零）运算封闭。\n性质 2（有序性）\n∀a,b∈R\\forall a, b \\in R∀a,b∈R，必满足 a&lt;ba &lt; ba&lt;b，a=ba = ba=b，a&gt;ba &gt; ba&gt;b 三者之一。\n性质 3（传递性）\n若 a&gt;ba &gt; ba&gt;b 且 b&gt;cb &gt; cb&gt;c，则 a&gt;ca &gt; ca&gt;c。\n性质 4（阿基米德性）\n∀a,b∈R\\forall a, b \\in R∀a,b∈R，若 b&gt;a&gt;0b &gt; a &gt; 0b&gt;a&gt;0，则 ∃n∈N+\\exists n \\in N^+∃n∈N+ 使 na&gt;bna &gt; bna&gt;b。\n性质 5（稠密性）\n任意两个不等实数之间必存在另一个实数（既有有理数也有无理数）。\n 2. 绝对值不等式\n∣∣a∣−∣b∣∣≤∣a±b∣≤∣a∣+∣b∣||a| - |b|| \\leq |a \\pm b| \\leq |a| + |b|\n∣∣a∣−∣b∣∣≤∣a±b∣≤∣a∣+∣b∣\n 3. 有界集与确界\n定义 1（有上界）\n∃M∈R\\exists M \\in R∃M∈R，使得 ∀x∈S\\forall x \\in S∀x∈S，有 x≤Mx \\leq Mx≤M。\n定义 2（有下界）\n∃m∈R\\exists m \\in R∃m∈R，使得 ∀x∈S\\forall x \\in S∀x∈S，有 x≥mx \\geq mx≥m。\n定义 3（有界）\n∃K&gt;0\\exists K &gt; 0∃K&gt;0，使得 ∀x∈S\\forall x \\in S∀x∈S，有 ∣x∣≤K|x| \\leq K∣x∣≤K。\n等价于既有上界又有下界。\n定义 4（上确界）\n设 S⊆RS \\subseteq RS⊆R，η=sup⁡S\\eta = \\sup Sη=supS 若：\n\n∀x∈S\\forall x \\in S∀x∈S，x≤ηx \\leq \\etax≤η（上界性）\n∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃x0∈S\\exists x_0 \\in S∃x0​∈S，使得 x0&gt;η−εx_0 &gt; \\eta - \\varepsilonx0​&gt;η−ε（最小性）\n\n定义 5（下确界）\n设 S⊆RS \\subseteq RS⊆R，ξ=inf⁡S\\xi = \\inf Sξ=infS 若：\n\n∀x∈S\\forall x \\in S∀x∈S，x≥ξx \\geq \\xix≥ξ（下界性）\n∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃x0∈S\\exists x_0 \\in S∃x0​∈S，使得 x0&lt;ξ+εx_0 &lt; \\xi + \\varepsilonx0​&lt;ξ+ε（最大性）\n\n定理 1（确界原理）\n非空有上界的实数集必有上确界；非空有下界的实数集必有下确界。\n 4. 确界的运算性质\ninf⁡S≤sup⁡S\\inf S \\leq \\sup S\ninfS≤supS\n等号成立当且仅当 SSS 为单点集。\n设 A,BA, BA,B 为非空有界集，则：\nsup⁡(A∪B)=max⁡{sup⁡A,sup⁡B},inf⁡(A∪B)=min⁡{inf⁡A,inf⁡B}\\sup(A \\cup B) = \\max\\{\\sup A, \\sup B\\},\\quad \\inf(A \\cup B) = \\min\\{\\inf A, \\inf B\\}\nsup(A∪B)=max{supA,supB},inf(A∪B)=min{infA,infB}\nsup⁡(kA)=ksup⁡A (k&gt;0),inf⁡(kA)=kinf⁡A (k&gt;0)\\sup(kA) = k \\sup A\\ (k &gt; 0),\\quad \\inf(kA) = k \\inf A\\ (k &gt; 0)\nsup(kA)=ksupA (k&gt;0),inf(kA)=kinfA (k&gt;0)\nk&lt;0k &lt; 0k&lt;0 时，sup⁡\\supsup 与 inf⁡\\infinf 互换。\nsup⁡(A+c)=sup⁡A+c,inf⁡(A+c)=inf⁡A+c\\sup(A + c) = \\sup A + c,\\quad \\inf(A + c) = \\inf A + c\nsup(A+c)=supA+c,inf(A+c)=infA+c\n\n 二、数列极限\n 1. 数列极限的定义\n定义 6\n设 {an}\\{a_n\\}{an​} 为数列，aaa 为常数。若 ∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃N∈N+\\exists N \\in N^+∃N∈N+，使得当 n&gt;Nn &gt; Nn&gt;N 时，有\n∣an−a∣&lt;ε|a_n - a| &lt; \\varepsilon\n∣an​−a∣&lt;ε\n则称 aaa 为数列 {an}\\{a_n\\}{an​} 的极限，记作 lim⁡n→∞an=a\\lim_{n \\to \\infty} a_n = alimn→∞​an​=a。\n 2. 极限性质\n定理 2（唯一性）\n收敛数列的极限唯一。\n定理 3（有界性）\n收敛数列必有界。\n定理 4（保号性）\n若 lim⁡an=a&gt;0\\lim a_n = a &gt; 0liman​=a&gt;0，则 ∃N\\exists N∃N，当 n&gt;Nn &gt; Nn&gt;N 时，an&gt;0a_n &gt; 0an​&gt;0。\n定理 5（迫敛性）\n若 an≤bn≤cna_n \\leq b_n \\leq c_nan​≤bn​≤cn​ 且 lim⁡an=lim⁡cn=a\\lim a_n = \\lim c_n = aliman​=limcn​=a，则 lim⁡bn=a\\lim b_n = alimbn​=a。\n 3. 极限运算法则\n若 lim⁡an=a\\lim a_n = aliman​=a，lim⁡bn=b\\lim b_n = blimbn​=b，则：\nlim⁡(an±bn)=a±b\\lim (a_n \\pm b_n) = a \\pm b\nlim(an​±bn​)=a±b\nlim⁡(anbn)=ab\\lim (a_n b_n) = ab\nlim(an​bn​)=ab\nlim⁡anbn=ab (b≠0)\\lim \\frac{a_n}{b_n} = \\frac{a}{b}\\ (b \\neq 0)\nlimbn​an​​=ba​ (b=0)\n 4. 单调有界定理\n定理 6\n单调有界数列必有极限。\n 5. 柯西收敛准则\n定理 7\n数列 {an}\\{a_n\\}{an​} 收敛 ⇔\\Leftrightarrow⇔ ∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃N\\exists N∃N，使得当 m,n&gt;Nm, n &gt; Nm,n&gt;N 时，有\n∣am−an∣&lt;ε|a_m - a_n| &lt; \\varepsilon\n∣am​−an​∣&lt;ε\n\n 三、函数极限\n 1. 函数极限的定义\n定义 7\n设 f(x)f(x)f(x) 在 x0x_0x0​ 的某去心邻域有定义，AAA 为常数。若 ∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃δ&gt;0\\exists \\delta &gt; 0∃δ&gt;0，使得当 0&lt;∣x−x0∣&lt;δ0 &lt; |x - x_0| &lt; \\delta0&lt;∣x−x0​∣&lt;δ 时，有\n∣f(x)−A∣&lt;ε|f(x) - A| &lt; \\varepsilon\n∣f(x)−A∣&lt;ε\n则称 AAA 为 f(x)f(x)f(x) 当 x→x0x \\to x_0x→x0​ 时的极限，记作 lim⁡x→x0f(x)=A\\lim_{x \\to x_0} f(x) = Alimx→x0​​f(x)=A。\n 2. 单侧极限\nlim⁡x→x0+f(x)=A,lim⁡x→x0−f(x)=A\\lim_{x \\to x_0^+} f(x) = A,\\quad \\lim_{x \\to x_0^-} f(x) = A\nx→x0+​lim​f(x)=A,x→x0−​lim​f(x)=A\n极限存在当且仅当左右极限存在且相等。\n 3. 极限性质\n定理 8（唯一性、局部有界性、局部保号性、迫敛性）\n与数列极限类似。\n 4. 极限运算法则\n与数列极限类似。\n 5. 两个重要极限\nlim⁡x→0sin⁡xx=1\\lim_{x \\to 0} \\frac{\\sin x}{x} = 1\nx→0lim​xsinx​=1\nlim⁡x→∞(1+1x)x=e\\lim_{x \\to \\infty} \\left(1 + \\frac{1}{x}\\right)^x = e\nx→∞lim​(1+x1​)x=e\n 6. 无穷小与无穷大\n3403583728: 02-27 11:30:19\n定义 8\n若 lim⁡f(x)=0\\lim f(x) = 0limf(x)=0，则称 f(x)f(x)f(x) 为无穷小。\n定义 9\n若 lim⁡f(x)=∞\\lim f(x) = \\inftylimf(x)=∞，则称 f(x)f(x)f(x) 为无穷大。\n\n 四、函数的连续性\n 1. 连续的定义\n定义 10\nf(x)f(x)f(x) 在 x0x_0x0​ 连续 ⇔\\Leftrightarrow⇔ lim⁡x→x0f(x)=f(x0)\\lim_{x \\to x_0} f(x) = f(x_0)limx→x0​​f(x)=f(x0​)。\n 2. 间断点分类\n\n可去间断点：极限存在但不等于函数值或函数无定义\n跳跃间断点：左右极限存在但不相等\n无穷间断点：极限为无穷大\n振荡间断点：极限不存在且不为无穷大\n\n 3. 连续函数的性质\n定理 9（介值定理）\n若 fff 在 [a,b][a, b][a,b] 连续，且 f(a)≠f(b)f(a) \\neq f(b)f(a)=f(b)，则对介于 f(a)f(a)f(a) 与 f(b)f(b)f(b) 之间的任意数 CCC，存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f(ξ)=Cf(\\xi) = Cf(ξ)=C。\n定理 10（最值定理）\n闭区间上的连续函数必有最大值和最小值。\n定理 11（零点定理）\n若 f(a)f(b)&lt;0f(a)f(b) &lt; 0f(a)f(b)&lt;0，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f(ξ)=0f(\\xi) = 0f(ξ)=0。\n\n 五、导数与微分\n 1. 导数的定义\n定义 11\nf′(x0)=lim⁡h→0f(x0+h)−f(x0)hf&#x27;(x_0) = \\lim_{h \\to 0} \\frac{f(x_0 + h) - f(x_0)}{h}\nf′(x0​)=h→0lim​hf(x0​+h)−f(x0​)​\n 2. 基本求导公式\n(c)′=0,(xμ)′=μxμ−1(c)&#x27; = 0,\\quad (x^\\mu)&#x27; = \\mu x^{\\mu-1}\n(c)′=0,(xμ)′=μxμ−1\n(sin⁡x)′=cos⁡x,(cos⁡x)′=−sin⁡x(\\sin x)&#x27; = \\cos x,\\quad (\\cos x)&#x27; = -\\sin x\n(sinx)′=cosx,(cosx)′=−sinx\n(ln⁡x)′=1x,(ex)′=ex(\\ln x)&#x27; = \\frac{1}{x},\\quad (e^x)&#x27; = e^x\n(lnx)′=x1​,(ex)′=ex\n 3. 求导法则\n(u±v)′=u′±v′(u \\pm v)&#x27; = u&#x27; \\pm v&#x27;\n(u±v)′=u′±v′\n(uv)′=u′v+uv′(uv)&#x27; = u&#x27;v + uv&#x27;\n(uv)′=u′v+uv′\n(uv)′=u′v−uv′v2\\left(\\frac{u}{v}\\right)&#x27; = \\frac{u&#x27;v - uv&#x27;}{v^2}\n(vu​)′=v2u′v−uv′​\ndydx=dydu⋅dudx\\frac{dy}{dx} = \\frac{dy}{du} \\cdot \\frac{du}{dx}\ndxdy​=dudy​⋅dxdu​\n 4. 微分的定义\n定义 12\n若 Δy=AΔx+o(Δx)\\Delta y = A\\Delta x + o(\\Delta x)Δy=AΔx+o(Δx)，则称 fff 在 x0x_0x0​ 可微，记 dy=Adxdy = A dxdy=Adx，且 A=f′(x0)A = f&#x27;(x_0)A=f′(x0​)。\n\n 六、微分中值定理\n 1. 罗尔定理\n定理 12\n若 fff 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，且 f(a)=f(b)f(a) = f(b)f(a)=f(b)，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f′(ξ)=0f&#x27;(\\xi) = 0f′(ξ)=0。\n 2. 拉格朗日中值定理\n定理 13\n若 fff 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使\nf(b)−f(a)=f′(ξ)(b−a)f(b) - f(a) = f&#x27;(\\xi)(b - a)\nf(b)−f(a)=f′(ξ)(b−a)\n 3. 柯西中值定理\n定理 14\n若 f,gf, gf,g 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，且 g′(x)≠0g&#x27;(x) \\neq 0g′(x)=0，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使\nf(b)−f(a)g(b)−g(a)=f′(ξ)g′(ξ)\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f&#x27;(\\xi)}{g&#x27;(\\xi)}\ng(b)−g(a)f(b)−f(a)​=g′(ξ)f′(ξ)​\n 4. 洛必达法则\n若 lim⁡f(x)g(x)\\lim \\frac{f(x)}{g(x)}limg(x)f(x)​ 为 00\\frac{0}{0}00​ 或 ∞∞\\frac{\\infty}{\\infty}∞∞​ 型，且 lim⁡f′(x)g′(x)\\lim \\frac{f&#x27;(x)}{g&#x27;(x)}limg′(x)f′(x)​ 存在，则\nlim⁡f(x)g(x)=lim⁡f′(x)g′(x)\\lim \\frac{f(x)}{g(x)} = \\lim \\frac{f&#x27;(x)}{g&#x27;(x)}\nlimg(x)f(x)​=limg′(x)f′(x)​\n 5. 泰勒公式\n定理 15\n若 fff 在 x0x_0x0​ 处 nnn 阶可导，则\nf(x)=f(x0)+f′(x0)(x−x0)+⋯+f(n)(x0)n!(x−x0)n+o((x−x0)n)f(x) = f(x_0) + f&#x27;(x_0)(x - x_0) + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + o((x - x_0)^n)\nf(x)=f(x0​)+f′(x0​)(x−x0​)+⋯+n!f(n)(x0​)​(x−x0​)n+o((x−x0​)n)\n定义 8\n若 lim⁡f(x)=0\\lim f(x) = 0limf(x)=0，则称 f(x)f(x)f(x) 为无穷小。\n定义 9\n若 lim⁡f(x)=∞\\lim f(x) = \\inftylimf(x)=∞，则称 f(x)f(x)f(x) 为无穷大。\n\n 四、函数的连续性\n 1. 连续的定义\n定义 10\nf(x)f(x)f(x) 在 x0x_0x0​ 连续 ⇔\\Leftrightarrow⇔ lim⁡x→x0f(x)=f(x0)\\lim_{x \\to x_0} f(x) = f(x_0)limx→x0​​f(x)=f(x0​)。\n 2. 间断点分类\n\n可去间断点：极限存在但不等于函数值或函数无定义\n跳跃间断点：左右极限存在但不相等\n无穷间断点：极限为无穷大\n振荡间断点：极限不存在且不为无穷大\n\n 3. 连续函数的性质\n定理 9（介值定理）\n若 fff 在 [a,b][a, b][a,b] 连续，且 f(a)≠f(b)f(a) \\neq f(b)f(a)=f(b)，则对介于 f(a)f(a)f(a) 与 f(b)f(b)f(b) 之间的任意数 CCC，存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f(ξ)=Cf(\\xi) = Cf(ξ)=C。\n定理 10（最值定理）\n闭区间上的连续函数必有最大值和最小值。\n定理 11（零点定理）\n若 f(a)f(b)&lt;0f(a)f(b) &lt; 0f(a)f(b)&lt;0，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f(ξ)=0f(\\xi) = 0f(ξ)=0。\n\n 五、导数与微分\n 1. 导数的定义\n定义 11\nf′(x0)=lim⁡h→0f(x0+h)−f(x0)hf&#x27;(x_0) = \\lim_{h \\to 0} \\frac{f(x_0 + h) - f(x_0)}{h}\nf′(x0​)=h→0lim​hf(x0​+h)−f(x0​)​\n 2. 基本求导公式\n(c)′=0,(xμ)′=μxμ−1(c)&#x27; = 0,\\quad (x^\\mu)&#x27; = \\mu x^{\\mu-1}\n(c)′=0,(xμ)′=μxμ−1\n(sin⁡x)′=cos⁡x,(cos⁡x)′=−sin⁡x(\\sin x)&#x27; = \\cos x,\\quad (\\cos x)&#x27; = -\\sin x\n(sinx)′=cosx,(cosx)′=−sinx\n(ln⁡x)′=1x,(ex)′=ex(\\ln x)&#x27; = \\frac{1}{x},\\quad (e^x)&#x27; = e^x\n(lnx)′=x1​,(ex)′=ex\n 3. 求导法则\n(u±v)′=u′±v′(u \\pm v)&#x27; = u&#x27; \\pm v&#x27;\n(u±v)′=u′±v′\n(uv)′=u′v+uv′(uv)&#x27; = u&#x27;v + uv&#x27;\n(uv)′=u′v+uv′\n(uv)′=u′v−uv′v2\\left(\\frac{u}{v}\\right)&#x27; = \\frac{u&#x27;v - uv&#x27;}{v^2}\n(vu​)′=v2u′v−uv′​\ndydx=dydu⋅dudx\\frac{dy}{dx} = \\frac{dy}{du} \\cdot \\frac{du}{dx}\ndxdy​=dudy​⋅dxdu​\n 4. 微分的定义\n定义 12\n若 Δy=AΔx+o(Δx)\\Delta y = A\\Delta x + o(\\Delta x)Δy=AΔx+o(Δx)，则称 fff 在 x0x_0x0​ 可微，记 dy=Adxdy = A dxdy=Adx，且 A=f′(x0)A = f&#x27;(x_0)A=f′(x0​)。\n\n 六、微分中值定理\n 1. 罗尔定理\n定理 12\n若 fff 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，且 f(a)=f(b)f(a) = f(b)f(a)=f(b)，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f′(ξ)=0f&#x27;(\\xi) = 0f′(ξ)=0。\n 2. 拉格朗日中值定理\n定理 13\n若 fff 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使\nf(b)−f(a)=f′(ξ)(b−a)f(b) - f(a) = f&#x27;(\\xi)(b - a)\nf(b)−f(a)=f′(ξ)(b−a)\n 3. 柯西中值定理\n定理 14\n若 f,gf, gf,g 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，且 g′(x)≠0g&#x27;(x) \\neq 0g′(x)=0，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使\nf(b)−f(a)g(b)−g(a)=f′(ξ)g′(ξ)\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f&#x27;(\\xi)}{g&#x27;(\\xi)}\ng(b)−g(a)f(b)−f(a)​=g′(ξ)f′(ξ)​\n 4. 洛必达法则\n若 lim⁡f(x)g(x)\\lim \\frac{f(x)}{g(x)}limg(x)f(x)​ 为 00\\frac{0}{0}00​ 或 ∞∞\\frac{\\infty}{\\infty}∞∞​ 型，且 lim⁡f′(x)g′(x)\\lim \\frac{f&#x27;(x)}{g&#x27;(x)}limg′(x)f′(x)​ 存在，则\nlim⁡f(x)g(x)=lim⁡f′(x)g′(x)\\lim \\frac{f(x)}{g(x)} = \\lim \\frac{f&#x27;(x)}{g&#x27;(x)}\nlimg(x)f(x)​=limg′(x)f′(x)​\n 5. 泰勒公式\n定理 15\n若 fff 在 x0x_0x0​ 处 nnn 阶可导，则\nf(x)=f(x0)+f′(x0)(x−x0)+⋯+f(n)(x0)n!(x−x0)n+o((x−x0)n)f(x) = f(x_0) + f&#x27;(x_0)(x - x_0) + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + o((x - x_0)^n)\nf(x)=f(x0​)+f′(x0​)(x−x0​)+⋯+n!f(n)(x0​)​(x−x0​)n+o((x−x0​)n)\n","categories":["-数学分析"]},{"title":"linux指令&shell脚本","url":"/2026/02/27/linux%E6%8C%87%E4%BB%A4-shell%E8%84%9A%E6%9C%AC/","content":" 文件操作\n 一、文件查看类\n\ncat : 显示文件内容\n\ncat filename           # 显示文件内容cat file1 file2        # 显示多个文件cat &gt; newfile          # 创建新文件（输入内容，Ctrl+D 结束）cat data.txt | less    # 分页查看大文件\n\nfile : 检测文件类型\n\nfile filename          # 检查单个文件类型file ./*               # 检查当前目录所有文件类型file -b filename       # 简洁输出（只显示类型）file -L filename       # 跟随符号链接\n\nstrings : 提取二进制文件中的可打印字符串\n\nstrings filename       # 提取所有≥4个可打印字符的字符串strings -n 10 filename # 提取≥10个字符的字符串strings data.bin | grep &quot;password&quot;  # 在二进制中搜索文本\n4.head ：显示文件开头部分\nhead filename                 # 显示前10行head -n 20 filename           # 显示前20行head -c 100 filename          # 显示前100字节head -v filename              # 显示文件名标题\n\ntail : 显示文件结尾部分\n\ntail filename                 # 显示最后10行tail -n 20 filename           # 显示最后20行tail -f filename              # 实时追踪文件变化tail -F filename              # 实时追踪（文件重命名后仍追踪）\n\nless : 分页查看文件\n\nless filename                 # 分页查看# 操作键: 空格翻页, b上一页, /搜索, n下一个匹配, q退出less -N filename              # 显示行号less -S filename              # 不换行显示\n\nmore : 分页查看文件\n\nmore filename                 # 分页查看# 操作键: 空格翻页, Enter下一行, q退出more -d filename              # 显示提示信息more +10 filename             # 从第10行开始显示\n8、diff ：比较文件差异\ndiff file1 file2               # 比较两个文件diff -u file1 file2           # 输出统一格式（便于打补丁）diff -r dir1 dir2             # 递归比较目录diff -N file1 file2           # 将不存在的文件视为空文件比较\n\n 二、文件操作类\n\nfind : 查找文件\n\nfind . -name &quot;*.txt&quot;          # 按文件名查找find . -type f -size +100k    # 查找大于100KB的文件find . -perm 644              # 按权限查找find . -mtime -7              # 查找7天内修改的文件find . -exec file &#123;&#125; \\\\;       # 对每个找到的文件执行命令\n\nmkdir : 创建目录\n\nmkdir dirname           # 创建目录mkdir -p a/b/c          # 递归创建多层目录（父目录不存在则创建）mkdir -m 755 dirname    # 创建目录并设置权限mktemp -d               # 创建唯一临时目录（Bandit推荐）\n\ncp : 复制文件/目录\n\ncp source dest          # 复制文件cp -r sourcedir dest    # 递归复制目录cp ~/file.txt .         # 复制到家目录文件到当前目录cp -p file dest         # 保留权限、时间戳等属性cp -u source dest       # 仅当源文件更新时才复制\n\nmv : 移动/重命名\n\nmv oldname newname      # 重命名文件mv file dir/            # 移动到目录mv *.txt backup/        # 移动多个文件mv -i file dest         # 交互式（覆盖前询问）mv -n file dest         # 不覆盖已存在文件\n\nrmdir : 删除空目录\n\nrmdir dirname                 # 删除空目录rmdir -p a/b/c                # 递归删除空目录rmdir -v dirname              # 显示删除信息\n\ntouch : 创建空文件/修改时间戳\n\ntouch filename                # 创建空文件或更新时间为当前时间touch -t 202512131200 filename  # 设置特定时间戳(YYYYMMDDhhmm)touch -a filename             # 只修改访问时间touch -m filename             # 只修改修改时间touch -c filename             # 不创建新文件，只修改时间戳\n\nln : 创建链接\n\nln source target              # 创建硬链接ln -s source target           # 创建软链接（符号链接）ln -sf source target          # 强制创建符号链接（覆盖）ln -i source target           # 交互式（覆盖前询问）\n\n 三、特殊工具类\n\nxxd : 十六进制转储/还原\n\nxxd filename           # 生成hexdump（二进制→十六进制文本）xxd -r hexdump.txt &gt; binary  # 还原hexdump（文本→二进制）xxd -l 100 filename    # 只显示前100字节xxd -p filename        # 纯十六进制输出（无地址和文本）\n\ndu : 查看磁盘使用量\n\ndu filename           # 显示文件大小（单位：块）du -h filename        # 人类可读格式（K、M）du -sh directory      # 显示目录总大小du -s                 # 显示所有文件大小\n\ncd : 切换目录\n\ncd dirname           # 进入目录cd ..               # 返回上级目录cd ~                # 返回用户家目录cd -                # 返回上一个目录cd /tmp             # 进入系统临时目录\n\nwhich : 查找命令位置\n\nwhich command                 # 显示命令完整路径which -a command              # 显示所有匹配路径which --skip-alias command    # 跳过别名\n\nwhereis : 查找命令相关文件\n\nwhereis command               # 查找命令的二进制、源码、手册页whereis -b command            # 只查找二进制whereis -m command            # 只查找手册页whereis -s command            # 只查找源码\n\nlocate : 快速文件查找\n\nlocate filename               # 查找文件locate -i filename            # 忽略大小写locate -c filename            # 统计找到的数量locate -r &quot;\\\\.txt$&quot;            # 使用正则表达式（查找.txt文件）# 注意：需要先运行 sudo updatedb 更新数据库\n\n 四、包管理与软件类\n\napt (Debian/Ubuntu)\n\napt update                   # 更新包列表apt upgrade                  # 升级所有包apt install package          # 安装软件包apt remove package           # 移除软件包apt search keyword           # 搜索软件包\n\nyum (RedHat/CentOS)\n\nyum install package          # 安装软件包yum update                   # 更新软件包yum remove package           # 移除软件包yum search keyword           # 搜索软件包\n\n 五、系统监控与性能类\n\nfree : 显示内存使用情况\n\nfree                          # 显示内存信息free -h                       # 人类可读格式free -m                       # 以MB为单位free -s 5                     # 每5秒刷新一次\n\nvmstat : 虚拟内存统计\n\nvmstat                        # 显示一次统计vmstat 2                      # 每2秒显示一次vmstat 2 10                   # 每2秒一次，共10次vmstat -s                     # 显示事件计数器\n\niostat : 输入输出统计\n\niostat                        # 显示一次统计iostat 2                      # 每2秒显示一次iostat -x                     # 扩展统计信息iostat -c                     # 只显示CPU统计\n\nnetstat / ss : 网络连接统计\n\nnetstat -tuln                 # 显示监听端口netstat -an                   # 显示所有连接netstat -rn                   # 显示路由表ss -tuln                      # ss替代netstat（更快）\n\nlsof : 列出打开文件\n\nlsof                          # 列出所有打开文件lsof -i :80                   # 列出使用80端口的进程lsof -u username              # 列出用户打开的文件lsof /path/to/file            # 列出打开指定文件的进程\n\n 六、链接与引用类\n\nln : 创建链接\n\nln source target              # 创建硬链接ln -s source target           # 创建软链接（符号链接）ln -sf source target          # 强制创建符号链接ln -nfs source target         # 不追踪目录符号链接\n\nreadlink : 读取符号链接目标\n\nreadlink linkname             # 显示符号链接指向readlink -f path              # 显示规范化的绝对路径readlink -e path              # 显示存在文件的规范路径\n\nrealpath : 获取绝对路径\n\nrealpath file                 # 显示文件的绝对路径realpath -s file              # 不解析符号链接realpath -q file              # 静默模式\n\n 七、查找与定位类\n\nlocate : 快速文件查找\n\nlocate filename               # 查找文件locate -i filename            # 忽略大小写locate -c filename            # 统计找到的数量locate -r &quot;pattern&quot;           # 使用正则表达式# 注意：需要先运行 sudo updatedb 更新数据库\n\nwhich : 查找命令位置\n\nwhich command                 # 显示命令完整路径which -a command              # 显示所有匹配路径which --skip-alias command    # 跳过别名\n\nwhereis : 查找命令相关文件\n\nwhereis command               # 查找命令的二进制、源码、手册页whereis -b command            # 只查找二进制whereis -m command            # 只查找手册页whereis -s command            # 只查找源码\n\ntype : 显示命令类型\n\ntype command                  # 显示命令类型（别名/内置/外部）type -a command               # 显示所有可能的解释type -t command               # 只显示类型（file/alias/builtin）\n 权限与用户管理\n 一、权限与用户管理类\n\nsudo : 以超级用户权限执行\n\nsudo command                   # 执行需要root权限的命令sudo -l                       # 列出当前用户可执行的sudo命令sudo -u username command       # 以指定用户身份执行\n\nsu : 切换用户\n\nsu                             # 切换到rootsu username                    # 切换到指定用户su - username                  # 切换用户并加载环境变量\n\nchmod : 修改文件权限\n\nchmod 755 file                # 数字模式设置权限chmod u+x file                # 给所有者添加执行权限chmod a-w file                # 移除所有用户的写权限chmod g=rx file               # 设置组权限为读执行\n\nchown : 修改文件所有者\n\nchown user file               # 修改文件所有者chown user:group file         # 同时修改所有者和组chown -R user dir/            # 递归修改目录下所有文件\n\nId : 显示用户身份信息\n\nid                            # 显示当前用户信息id username                   # 显示指定用户信息id -u                         # 显示用户IDid -g                         # 显示组ID\n\n 二、权限绕过与工作空间类\n相关指令用法\n\nmktemp : 创建临时文件/目录\n\nmktemp -d                  # 创建临时目录，返回路径mktemp file.XXXXXX         # 创建临时文件mktemp -t prefix.XXXXXX    # 在/tmp下创建带前缀的文件mktemp -p /custom/path     # 在指定路径创建\n\ncd : 切换目录\n\ncd /tmp                    # 切换到系统临时目录（总是可写）cd /dev/shm               # 切换到内存文件系统（速度最快）cd ~                      # 回到家目录（可能只读）cd -                      # 回到上一个目录\n\ncp : 复制文件\n\ncp ~/readonly_file .      # 从只读位置复制到当前目录cp -r source_dir dest     # 递归复制目录cp -p file dest           # 保留文件属性\n\nrm : 删除文件/目录\n\nrm -rf dirname            # 强制递归删除目录rm -f filename            # 强制删除文件rm -v file               # 显示删除信息\n\ndf : 查看磁盘空间\n\ndf -h /tmp               # 查看/tmp空间使用（人类可读）df -i /tmp               # 查看inode使用情况\n\nmount : 查看/操作挂载点\n\nmount | grep &quot; ro,&quot;       # 查找只读挂载点mount | grep /tmp         # 查看/tmp挂载属性\n 管道与重定向\n 基础\n\n管道符 | : 连接命令，传递数据\n\ncommand1 | command2          # 将command1的输出作为command2的输入ls -l | grep &quot;.txt&quot;          # 列出文件并过滤txt文件ps aux | sort -nk4           # 列出进程并按内存排序cat file | head -20 | tail -5 # 取文件的第16-20行\n\n重定向符 &gt; : 输出到文件（覆盖）\n\ncommand &gt; file               # 将输出保存到文件（覆盖原有内容）ls &gt; filelist.txt            # 将ls结果保存到文件echo &quot;hello&quot; &gt; greeting.txt  # 创建文件并写入内容\n\n重定向符 &gt;&gt; : 输出到文件（追加）\n\ncommand &gt;&gt; file              # 将输出追加到文件末尾date &gt;&gt; log.txt              # 将当前时间追加到日志echo &quot;new entry&quot; &gt;&gt; data.txt # 在文件末尾添加新行\n\n输入重定向 &lt; : 从文件读取输入\n\ncommand &lt; file               # 从文件读取输入（代替键盘输入）sort &lt; unsorted.txt          # 从文件读取内容进行排序wc -l &lt; data.txt             # 统计文件行数\n\nhere文档 &lt;&lt; : 内联输入\n\ncommand &lt;&lt; EOF多行输入直到遇到EOFEOFcat &lt;&lt; END这是多行文本直接作为输入END\n\n标准错误重定向 2&gt; : 处理错误信息\n\ncommand 2&gt; error.log         # 将错误信息保存到文件find / -name &quot;*.conf&quot; 2&gt;/dev/null  # 丢弃错误信息command 2&gt;&amp;1                 # 将错误重定向到标准输出command &gt; output.txt 2&gt;&amp;1    # 将输出和错误都保存到文件\n\ntee : 分流输出（同时输出到屏幕和文件）\n\ncommand | tee file           # 输出到屏幕并保存到文件ls | tee list.txt | wc -l    # 保存列表并统计行数command | tee -a log.txt     # 追加到文件（-a参数）\n\nxargs : 将管道输入转为命令行参数\n\necho &quot;file1 file2&quot; | xargs rm    # 删除file1和file2find . -name &quot;*.txt&quot; | xargs grep &quot;pattern&quot;  # 在所有txt文件中搜索ls *.txt | xargs -I &#123;&#125; cp &#123;&#125; backup/  # 复制所有txt文件\n\n命名管道 mkfifo : 创建先进先出管道\n\nmkfifo mypipe                # 创建命名管道ls -l &gt; mypipe &amp;             # 在后台写入管道cat &lt; mypipe                 # 从管道读取\n\n进程替换 &lt;( ) 和 &gt;( ) : 将命令输出作为文件\n\ndiff &lt;(ls dir1) &lt;(ls dir2)   # 比较两个目录的内容tar czf &gt;(ssh host &quot;cat &gt; backup.tar.gz&quot;) /data  # 直接压缩传输\n\n 管道组合模式\n模式1：过滤链\ncat log.txt | grep &quot;ERROR&quot; | sort | uniq -c | sort -nr# 读取日志 → 过滤错误 → 排序 → 统计重复 → 按数量降序\n模式2：解码链\ncat encoded.txt | base64 -d | tr &#x27;A-Z&#x27; &#x27;a-z&#x27; | grep &quot;secret&quot;# 读取文件 → base64解码 → 转小写 → 搜索关键词\n模式3：统计报告\nnetstat -an | grep &quot;:80 &quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d: -f1 | sort | uniq -c# 网络连接 → 过滤80端口 → 提取IP → 去端口 → 排序 → 统计每个IP连接数\n\n 注意事项\n1. 管道缓冲区：默认64KB，大数据可能阻塞2. 二进制安全：文本工具可能损坏二进制数据3. 错误处理：管道中某个命令失败不影响后续4. 性能：长管道链可能降低性能\n 文本处理\n 一、文本处理\n\ngrep : 文本搜索工具\n\ngrep &quot;pattern&quot; filename      # 搜索包含&quot;pattern&quot;的行grep -i &quot;pattern&quot; filename   # 忽略大小写搜索grep -r &quot;pattern&quot; dir/       # 递归搜索目录grep -v &quot;pattern&quot; filename   # 显示不包含pattern的行（反转）grep -n &quot;pattern&quot; filename   # 显示行号grep -c &quot;pattern&quot; filename   # 统计匹配行数grep -E &quot;regex&quot; filename     # 使用扩展正则表达式\n\nsort : 排序文本行\n\nsort filename          # 按字母顺序排序sort -n filename       # 按数字大小排序sort -r filename       # 反向排序sort -u filename       # 去重并排序sort data.txt | uniq -u  # 组合使用：找唯一行\n\nuniq : 报告或忽略重复行\n\nuniq filename          # 去重（需先排序）uniq -c filename       # 统计每行出现次数uniq -u filename       # 只显示唯一行（不重复的）uniq -d filename       # 只显示重复行\n\ntr : 字符替换/删除\n\ntr &#x27;a-z&#x27; &#x27;A-Z&#x27; &lt; file  # 小写转大写tr -d &#x27;\\\\n&#x27; &lt; file      # 删除换行符tr -d &#x27;0-9&#x27; &lt; file     # 删除所有数字# ROT13解码：tr &#x27;A-Za-z&#x27; &#x27;N-ZA-Mn-za-m&#x27; &lt; data.txt\n\nbase64 : base64编解码\n\nbase64 filename        # 编码base64 -d filename     # 解码（-d 参数）echo &quot;hello&quot; | base64  # 管道编码echo &quot;aGVsbG8=&quot; | base64 -d  # 管道解码\n\nwc : 统计行数、单词数、字节数\n\nwc filename                   # 统计行数、单词数、字节数wc -l filename                # 只统计行数wc -w filename                # 只统计单词数wc -c filename                # 只统计字节数wc -m filename                # 只统计字符数\n\ncut : 剪切文件中的列\n\ncut -d: -f1 filename          # 以冒号分隔，取第一列cut -c1-10 filename           # 取第1-10个字符cut -f2,5 filename            # 取第2列和第5列cut -d&#x27; &#x27; -f2- filename       # 以空格分隔，取第二列到最后一列\n\npaste : 合并文件行\n\npaste file1 file2             # 并排合并文件paste -d&#x27;,&#x27; file1 file2       # 用逗号分隔合并paste -s file1                # 将文件所有行合并为一行paste -d&#x27;\\\\t&#x27; file1 file2      # 用制表符分隔\n\njoin : 基于共同字段合并文件\n\njoin file1 file2              # 基于第一列合并join -1 2 -2 3 file1 file2    # 指定列合并（file1第2列，file2第3列）join -t&#x27;:&#x27; file1 file2        # 指定分隔符join -a1 file1 file2          # 显示file1所有行（类似左连接）\n\n 二、压缩归档类\n\ntar : 打包/解包归档文件\n\ntar xf archive.tar           # 解包（提取）tar tf archive.tar           # 查看包内文件列表tar czf archive.tar.gz dir/  # 打包并用gzip压缩tar xzf archive.tar.gz       # 解压gzip压缩的tar包tar cjf archive.tar.bz2 dir/ # 打包并用bzip2压缩tar xjf archive.tar.bz2      # 解压bzip2压缩的tar包tar xO archive.tar           # 解包到标准输出（不保存文件）\n\ngzip / gunzip : gzip格式压缩/解压\n\ngzip filename           # 压缩，生成 filename.gzgzip -d filename.gz     # 解压（同 gunzip filename.gz）zcat filename.gz        # 不解压直接查看内容gzip -c file &gt; file.gz  # 压缩并保留原文件\n\nbzip2 / bunzip2 : bzip2格式压缩/解压\n\nbzip2 filename          # 压缩，生成 filename.bz2bzip2 -d filename.bz2   # 解压（同 bunzip2 filename.bz2）bzcat filename.bz2      # 不解压直接查看内容bzip2 -k filename       # 压缩并保留原文件（-k 参数）\n\n 三、文本编辑与处理（高级）\n\nvim / vi : 文本编辑器\n\nvim file                      # 用vim打开文件# 常用操作: i插入, Esc退出插入, :wq保存退出, :q!强制退出\n\nnano : 简单文本编辑器\n\nnano file                     # 用nano打开文件# Ctrl+O保存, Ctrl+X退出\n\nawk : 文本处理语言\n\nawk &#x27;&#123;print $1&#125;&#x27; file        # 打印第一列awk -F: &#x27;&#123;print $1&#125;&#x27; file    # 以冒号为分隔符awk &#x27;/pattern/ &#123;print $0&#125;&#x27;   # 匹配模式的行\n\nsed : 流编辑器\n\nsed &#x27;s/old/new/g&#x27; file       # 替换所有old为newsed -n &#x27;5,10p&#x27; file          # 打印5-10行sed &#x27;/pattern/d&#x27; file        # 删除匹配行\n 网络操作\n\nssh : 安全远程登录\n\nssh user@host                  # 基本连接ssh -p 2220 user@host          # 指定端口ssh -i key.pem user@host       # 使用密钥登录ssh -L 8080:localhost:80 user@host  # 本地端口转发\n\ntelnet : 明文远程登录（测试服务）\n\ntelnet host 端口号             # 连接服务telnet bandit.labs.overthewire.org 2220  # Bandit连接方式\n\nnc (netcat) : 网络瑞士军刀\n\nnc -l -p 1234                  # 监听端口nc host 端口号                 # 连接主机nc -z host 端口范围            # 端口扫描echo &quot;data&quot; | nc host port     # 发送数据\n\ncurl : 传输数据（HTTP/FTP等）\n\ncurl &lt;http://example.com&gt;        # 获取网页curl -o file.txt &lt;http://url&gt;    # 下载文件curl -X POST -d &quot;data&quot; &lt;http://url&gt;  # POST请求curl -u user:pass &lt;http://url&gt;   # 基本认证\n 系统信息与进程\n\nps : 显示进程状态\n\nps aux                        # 显示所有进程详细信息ps -ef                        # 完整格式列表ps -u username                # 显示指定用户的进程ps aux | grep process_name    # 查找特定进程\n\ntop / htop : 动态显示进程\n\ntop                           # 实时进程监控htop                          # 增强版top（需要安装）\n\nkill : 终止进程\n\nkill PID                      # 终止指定PID进程kill -9 PID                   # 强制终止killall process_name          # 终止所有同名进程pkill pattern                 # 按模式终止进程\n\njobs / fg / bg : 作业控制\n\njobs                          # 显示后台作业fg %1                         # 将作业1调到前台bg %1                         # 将作业1放到后台command &amp;                     # 在后台运行命令\n\ndf / du : 磁盘空间\n\ndf -h                         # 显示磁盘使用情况（人类可读）du -sh dir/                   # 显示目录总大小du -h --max-depth=1           # 显示一级子目录大小挂载存储U盘```bash# 1. 创建挂载目录（如果不存在）$ sudo mkdir -p /mnt/vm_disk# 2. 挂载 U 盘（假设 U 盘设备为 /dev/sdb1）$ sudo mount /dev/sdb1 /mnt/vm_disk# 3. 使用完毕后安全卸载 U 盘$ sudo umount /mnt/vm_disk如果想进一步判断 U 盘设备名，可以先用以下命令查看：# 查看当前存储设备信息$ lsblk# 或$ sudo fdisk -l\n\n shell脚本\n 变量定义\n一、变量定义（赋值）\n\n基本定义（不加$）\n\n# 定义变量（赋值时不用$）name=&quot;张三&quot;age=25file=&quot;test.zip&quot;PATH=&quot;/usr/bin:/bin&quot;\n\n规则\n\n· 等号两边不能有空格：name=“张三” ✅ name = “张三” ❌\n· 变量名：字母/数字/下划线，不能数字开头\n· 值可以加引号，也可以不加（但推荐加）\n二、变量使用（要加$）\n\n基本使用\n\nname=&quot;张三&quot;echo $name      # 输出：张三echo &quot;$name&quot;    # 输出：张三（推荐）echo &#x27;$name&#x27;    # 输出：$name（单引号不替换）\n\n变量+文本的三种写法\n\nprefix=&quot;INFO_&quot;# 方法1：大括号（最推荐！）echo &quot;$&#123;prefix&#125;message&quot;    # INFO_message# 方法2：空格分隔echo &quot;$prefix message&quot;     # INFO_ message（有空格）# 方法3：引号外拼接（不推荐）echo $prefix&quot;message&quot;      # INFO_message\n\n必须用大括号的情况\n\n# 当变量名后紧跟文本时count=5echo &quot;我有$&#123;count&#125;个苹果&quot;  # ✅ 正确：我有5个苹果echo &quot;我有$count个苹果&quot;    # ❌ 错误：找$count个苹果变量\n三、输出前缀模式\n\n定义前缀变量\n\n# 定义输出前缀（标签）INFO=&quot;[INFO] &quot;ERROR=&quot;[ERROR] &quot;SUCCESS=&quot;[SUCCESS] &quot;WARNING=&quot;[WARNING] &quot;\n\n使用前缀（必须用{}）\n\nfile=&quot;test.zip&quot;# 正确用法echo &quot;$&#123;INFO&#125;检查文件: $file&quot;     # [INFO] 检查文件: test.zipecho &quot;$&#123;ERROR&#125;文件不存在: $file&quot;  # [ERROR] 文件不存在: test.zipecho &quot;$&#123;SUCCESS&#125;解压成功&quot;         # [SUCCESS] 解压成功# 错误用法echo &quot;$INFO检查文件&quot;    # ❌ 找 $INFO检查文件 变量echo &quot;$ERROR文件不存在&quot; # ❌ 找 $ERROR文件不存在 变量\n\n后期添加颜色（只需修改定义）\n\n# 无颜色版本# INFO=&quot;[INFO] &quot;# ERROR=&quot;[ERROR] &quot;# 有颜色版本（只需改这里！）RED=&#x27;\\\\033[0;31m&#x27;GREEN=&#x27;\\\\033[0;32m&#x27;NC=&#x27;\\\\033[0m&#x27;INFO=&quot;$&#123;RED&#125;[INFO]$&#123;NC&#125; &quot;      # 红色INFOERROR=&quot;$&#123;GREEN&#125;[ERROR]$&#123;NC&#125; &quot;  # 绿色ERROR# 其他地方代码完全不变！\n四、局部变量 vs 全局变量\n\n局部变量（函数内使用）\n\nprocess_file() &#123;    local file=&quot;$1&quot;      # local声明局部变量    local name=&quot;临时&quot;    # 这里的变量不会影响函数外部&#125;# 调用process_file &quot;test.zip&quot;echo $file  # ❌ 为空，因为file是局部变量\n\n全局变量（不加local）\n\nglobal_var=&quot;我是全局的&quot;my_function() &#123;    file=&quot;$1&quot;           # ❌ 危险！影响全局    echo &quot;处理: $file&quot;&#125;# 调用后，file变量在脚本任何地方都可以访问\n五、特殊变量\n变量      含义        $0       脚本名称    $1 - $9  第1-9个参数$#       参数个数$@       所有参数列表$*       所有参数（一个字符串）$?       上一个命令的退出码 0=成功，非0=失败$$       当前进程PID$!       最后一个后台进程PID\n六、命令替换：将命令输出保存到变量\n$()（新写法，推荐）\ncurrent_date=$(date)file_count=$(ls | wc -l)filename=$(basename &quot;/path/to/file.zip&quot;)  # 你的脚本用法\n 条件判断\n 一、基本语法结构\n\nif 基础结构\n\n# 基本格式if [ 条件 ]; then    # 条件成立执行的代码fi# 或写成多行if [ 条件 ]then    # 代码fi\n\nif-else 结构\n\nif [ 条件 ]; then    echo &quot;条件成立&quot;else    echo &quot;条件不成立&quot;fi\n\nif-elif-else 结构\n\nif [ 条件1 ]; then    echo &quot;条件1成立&quot;elif [ 条件2 ]; then    echo &quot;条件2成立&quot;else    echo &quot;都不成立&quot;fi\n 二、测试条件语法\n\n旧语法：test 或 [ ]\n\n# 两种等价写法if test -f &quot;file.txt&quot;; then    echo &quot;文件存在&quot;fiif [ -f &quot;file.txt&quot; ]; then    echo &quot;文件存在&quot;fi\n\n新语法：[[ ]]（推荐）\n\nif [[ -f &quot;file.txt&quot; ]]; then    echo &quot;文件存在&quot;fi\n 三、测试条件\n\n文件存在性\n\n-e 文件/目录存在 -f 是普通文件 -d 是目录 检查是否是目录\n\n文件权限\n\n-r 文件可读 [ ! -r &quot;$file&quot; ] 检查不可读-w 文件可写 检查是否可写-x 文件可执行 检查是否可执行-s 文件非空（大小&gt;0） [ ! -s &quot;$file&quot; ] 检查为空文件\n\n文件类型\n\n-L 是符号链接 [ -L &quot;link&quot; ]-b 是块设备文件 [ -b &quot;/dev/sda&quot; ]-c 是字符设备文件 [ -c &quot;/dev/tty&quot; ]-p 是命名管道 [ -p &quot;fifo&quot; ]\n\n数值比较（整数）\n\n-eq 等于（equal） [ $a -eq $b ]-ne 不等于（not equal） [ $a -ne $b ]-gt 大于（greater than） [ $a -gt $b ]-ge 大于等于 [ $a -ge $b ]-lt 小于（less than） [ $a -lt $b ]-le 小于等于 [ $a -le $b ]\n\n字符串比较\n\n-z 字符串为空 [ -z &quot;$str&quot; ]-n 字符串非空 [ -n &quot;$str&quot; ]= 字符串相等 [ &quot;$str1&quot; = &quot;$str2&quot; ]!= 字符串不等 [ &quot;$str1&quot; != &quot;$str2&quot; ]\n\n逻辑操作符\n\n# 传统写法（不推荐）[ 条件1 -a 条件2 ]  # 与[ 条件1 -o 条件2 ]  # 或[ ! 条件 ]          # 非# 现代写法（推荐）[ 条件1 ] &amp;&amp; [ 条件2 ]   # 与[ 条件1 ] || [ 条件2 ]   # 或! [ 条件 ]              # 非\n\n[[ ]] 增强测试（bash特有）\n\n# 模式匹配[[ $file == *.txt ]]# 正则表达式[[ $input =~ ^[0-9]+$ ]] ^       # 开头（像Ctrl+Home）$       # 结尾（像Ctrl+End）.       # 任意一个字符（像？通配符）*       # 前面的东西出现0次或多次（&quot;随便有没有&quot;）+       # 前面的东西出现1次或多次（&quot;至少要有&quot;）# 字符串比较（不用引号）[[ $str1 &lt; $str2 ]]# 逻辑运算符（不用-a/-o）[[ -f file &amp;&amp; -r file ]]# 处理空值安全[[ $var ]]          # var非空（安全）\n 一、while 循环\n基本结构\nwhile [ 条件 ]do    命令done\n无限循环\n# 服务器监控脚本while truedo    if ! ping -c 1 google.com &gt;/dev/null 2&gt;&amp;1; then        echo &quot;$(date): 网络断开！&quot; &gt;&gt; network.log    fi    sleep 60  # 每60秒检查一次done\n 二、for 循环\n\n遍历列表\n\n# 解压多个指定文件for file in archive1.zip archive2.tar.gz backup.rardo    echo &quot;正在处理: $file&quot;    ./unlock_nest.sh &quot;$file&quot;done\n\n遍历文件\n\n# 解压当前目录所有压缩文件for file in *.zip *.tar.gz *.rar *.7zdo    if [ -f &quot;$file&quot; ]; then        echo &quot;批量解压: $file&quot;        ./unlock_nest.sh &quot;$file&quot;    fidone\n\n遍历命令输出\n\n# 处理find找到的所有zip文件for zipfile in $(find /path -name &quot;*.zip&quot;)do    echo &quot;找到: $zipfile&quot;    unzip &quot;$zipfile&quot;done\n 三、until 循环\n与 while 相反：条件为假时执行\n# 等待服务启动until curl -s &lt;http://localhost:8080&gt; &gt;/dev/nulldo    echo &quot;等待服务启动...&quot;    sleep 2doneecho &quot;服务已启动！&quot;\n 四、循环控制语句\nbreak：跳出循环\n# 找到第一个可解压文件就停止for file in *do    if [[ &quot;$file&quot; =~ \\\\.(zip|tar|rar)$ ]]; then        echo &quot;找到: $file&quot;        ./unlock_nest.sh &quot;$file&quot;        break  # 只处理第一个    fidone\ncontinue：跳过本次循环\n# 跳过空文件for file in *do    if [ ! -s &quot;$file&quot; ]; then        echo &quot;跳过空文件: $file&quot;        continue    fi    echo &quot;处理: $file&quot;done\n 常用命令\n command\ncommand 是一个内置命令，用来查找和执行原始命令，绕过别名和函数。\n一、command 的三大功能\n\n查找命令（最常用）\n\n# 检查命令是否存在（你的脚本用法）if command -v unzip &gt;/dev/null 2&gt;&amp;1; then    echo &quot;unzip已安装&quot;fi# 获取命令路径unzip_path=$(command -v unzip)echo &quot;unzip路径: $unzip_path&quot;\n\n绕过别名和函数\n\n# 假设用户定义了：alias rm=&#x27;rm -i&#x27;           # 删除前询问ls() &#123; echo &quot;自定义函数&quot;; &#125; # 自定义函数# 执行：rm file.txt         # 会询问确认（受别名影响）command rm file.txt # 直接删除（原始行为）ls                  # 输出：&quot;自定义函数&quot;command ls          # 列出文件（原始行为）\n\n执行原始命令\n\n# 强制使用系统命令command echo &quot;hello&quot;  # 使用bash内置的echo/bin/echo &quot;hello&quot;     # 使用外部echo（如果有）\n二、参数详解\n-v    显示命令信息     command -v ls-V    显示详细信息     command -V ls-p    使用默认PATH查找 command -p ls无参数  执行命令        command ls\n\nv 参数详细\n\n# 对不同类型命令的输出command -v cd      # 输出：cd （内置命令）command -v ls      # 输出：/bin/ls （外部命令）command -v ll      # 输出：alias ll=&#x27;ls -l&#x27; （别名）command -v myfunc  # 输出：myfunc （函数）\n\n read\nread = 从键盘读取用户输入，保存到变量中\nread [选项] 变量名\n常用选项\n选项 作用 示例-p 显示提示 read -p &quot;提示: &quot; var-s 静默输入（密码） read -s -p &quot;密码: &quot; pass-t N 超时N秒 read -t 5 -p &quot;输入: &quot;-n N 读取N个字符 read -n 1 -p &quot;按键: &quot;-r 禁用反斜杠转义 read -r line-a 读取为数组 read -a arr\n\n set\n# 安全模式三件套（脚本开头必加）set -e   # 出错就退出set -u   # 未定义变量报错set -o pipefail  # 管道失败也退出# 调试模式set -x   # 打开调试（显示每行命令）set +x   # 关闭调试# 组合使用set -euo pipefail  # 专业脚本标配\n\n 重定向\n 三种标准流\n文件描述符  名称     默认目标 缩写\n0 标准输入 (stdin)  键盘    &lt;\n1 标准输出 (stdout) 屏幕    &gt;\n2 标准错误 (stderr) 屏幕    2&gt;\n 基本重定向语法\n\n输出到文件\n\n# 覆盖写入command &gt; file.txtecho &quot;Hello&quot; &gt; output.txt# 追加写入command &gt;&gt; file.txtecho &quot;World&quot; &gt;&gt; output.txt\n\n错误输出\n\n# 错误输出到文件command 2&gt; error.log# 错误追加到文件command 2&gt;&gt; error.log\n\n所有输出\n\n# 所有输出重定向（覆盖）command &amp;&gt; all_output.log# 所有输出重定向（追加）command &amp;&gt;&gt; all_output.log\n 组合重定向\n\n标准输出和错误输出合并\n\n# 方法1：旧写法command &gt; output.log 2&gt;&amp;1# 方法2：新写法（推荐）command &amp;&gt; output.log# 解释：# &gt; output.log    → 标准输出到文件# 2&gt;&amp;1           → 错误输出也重定向到标准输出（即文件）\n\n分别重定向\n\n# 输出到文件，错误到屏幕command &gt; output.log# 输出到屏幕，错误到文件command 2&gt; error.log# 输出到文件A，错误到文件Bcommand &gt; output.log 2&gt; error.log\n特殊设备：/dev/null\n&quot;黑洞&quot;设备\n# 丢弃所有输出command &gt; /dev/null 2&gt;&amp;1# 只丢弃正常输出，显示错误command &gt; /dev/null# 只丢弃错误，显示正常输出command 2&gt; /dev/null\n 输入重定向\n\n从文件读取输入\n\n# 文件内容作为命令输入command &lt; input.txt# 统计文件行数wc -l &lt; data.txt\n\nHere Document\n\n# 多行输入cat &lt;&lt; EOF第一行第二行第三行EOF# 带变量替换cat &lt;&lt; EOF用户名: $USER时间: $(date)EOF\n\nHere String\n\n# 字符串作为输入tr &#x27;a-z&#x27; &#x27;A-Z&#x27; &lt;&lt;&lt; &quot;hello world&quot;\n 高级技巧\n\n重定向到进程（管道）\n\n# 标准用法command1 | command2# 同时重定向错误command1 2&gt;&amp;1 | command2# 只传递错误command1 2&gt;&amp;1 &gt;/dev/null | command2\n\n进程替换\n\n# 将命令输出作为文件使用diff &lt;(ls dir1) &lt;(ls dir2)# 作为输入文件cat &lt;(echo &quot;第一行&quot;) &lt;(echo &quot;第二行&quot;)\n\n同时输出到文件和屏幕\n\n# 使用 tee 命令command | tee output.log          # 覆盖command | tee -a output.log       # 追加# 同时输出到多个地方command | tee file1.log file2.log &gt;/dev/null\n 常见错误\n错误1：忘记文件描述符\n# 错误：以为这样能重定向错误command &gt; file.log 2&gt;1   # ❌ 创建文件名为&quot;1&quot;的文件！# 正确：需要&amp;符号command &gt; file.log 2&gt;&amp;1  # ✅ 正确\n错误2：noclobber保护\n# 防止意外覆盖文件set -o noclobberecho &quot;test&quot; &gt; existing.txt  # ❌ 失败，文件已存在echo &quot;test&quot; &gt;| existing.txt # ✅ 强制覆盖\n\n自定义流（3-9）\n# 打开自定义文件描述符exec [n]&lt; file    # 打开用于输入（读）exec [n]&gt; file    # 打开用于输出（写，覆盖）exec [n]&gt;&gt; file   # 打开用于输出（写，追加）# 使用自定义描述符command &lt;&amp;n       # 从描述符n读取输入  command &gt;&amp;n       # 向描述符n写入输出# 关闭自定义描述符exec n&gt;&amp;-         # 关闭输出描述符exec n&lt;&amp;-         # 关闭输入描述符\n\n 变量拓展符\n删除操作符\n$&#123;var#pattern&#125;      # 从左删除最短匹配$&#123;var##pattern&#125;     # 从左删除最长匹配$&#123;var%pattern&#125;      # 从右删除最短匹配$&#123;var%%pattern&#125;     # 从右删除最长匹配\n替换操作符\n$&#123;var/pattern/replace&#125;    # 替换第一个匹配$&#123;var//pattern/replace&#125;   # 替换所有匹配$&#123;var/#pattern/replace&#125;   # 替换开头匹配（前缀）$&#123;var/%pattern/replace&#125;   # 替换结尾匹配（后缀）\n默认值操作符\n$&#123;var:-default&#125;    # 如果var空/未设，用default（不赋值）$&#123;var:=default&#125;    # 如果var空/未设，用default并赋值给var$&#123;var:?error_msg&#125;  # 如果var空/未设，显示error_msg并退出$&#123;var:+alt_value&#125;  # 如果var已设，用alt_value\n切片操作符\n$&#123;var:start&#125;          # 从start到结尾$&#123;var:start:length&#125;   # 从start截取length长度# 例子：str=&quot;0123456789&quot;$&#123;str:3&#125;       → &quot;3456789&quot;$&#123;str:3:4&#125;     → &quot;3456&quot;$&#123;str: -3&#125;     → &quot;789&quot;（注意空格）\n大小写转换\n$&#123;var^&#125;        # 首字母大写$&#123;var^^&#125;       # 全部大写$&#123;var,&#125;        # 首字母小写$&#123;var,,&#125;       # 全部小写$&#123;var~&#125;        # 首字母大小写反转$&#123;var~~&#125;       # 全部大小写反转\n","categories":["-Linux"]},{"title":"网络通信","url":"/2026/02/27/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/","content":" 应用层\n 一、应用层是干什么的？\n核心职责：让计算机理解人类意图\n应用层 = 网络应用的&quot;大脑&quot;你的需求：看网页、发邮件、传文件↓应用层翻译成：HTTP请求、SMTP命令、FTP操作↓网络传输\n 二、应用层协议家族\n2.1 Web通信：HTTP/HTTPS\n# HTTP就像&quot;明信片&quot; - 所有人都能看到内容GET /index.html HTTP/1.1      ← 你要什么Host: www.example.com          ← 找谁要User-Agent: Chrome             ← 谁在要Accept: text/html              ← 要什么格式# HTTPS = HTTP + 加密信封# 把明信片装进加密信封再寄# 关键特点：1. 无状态：服务器不记得你2. 请求-响应：一问一答3. 可扩展：各种Header自定义\n2.2 电子邮件：SMTP/POP3/IMAP\n# SMTP发送邮件（像邮局寄信）HELO client.example.com        ← 打招呼MAIL FROM:&lt;alice@example.com&gt;  ← 谁寄的RCPT TO:&lt;bob@example.org&gt;      ← 寄给谁DATA                           ← 开始写信From: Alice &lt;alice@example.com&gt;To: Bob &lt;bob@example.org&gt;Subject: Hello!This is the email body..                              ← 结束（一个点）QUIT                           ← 再见# POP3收邮件（像从邮箱取信）# IMAP更高级（像在邮局看信，信还在服务器）\n2.3 文件传输：FTP/SFTP\n# FTP命令（像远程文件管理器）$ ftp example.comConnected to example.com.Name: alicePassword: *****ftp&gt; ls                         # 列出文件ftp&gt; get file.txt              # 下载文件ftp&gt; put newfile.txt           # 上传文件ftp&gt; quit# SFTP = FTP + SSH加密# 更安全，但用法类似\n2.4 域名解析：DNS\n# DNS查询（像电话簿查询）你：www.google.com的IP是多少？↓DNS客户端：查询本地缓存 → 没有↓DNS递归解析器：问根服务器 → &quot;.com&quot;服务器在哪？↓根服务器：.com服务器是这些IP↓递归解析器：问.com服务器 → google.com服务器在哪？↓.com服务器：在这里↓递归解析器：问google.com服务器 → www的IP？↓google.com服务器：是 142.250.190.78↓你：知道了！连接142.250.190.78# 实际上用dig命令：$ dig www.google.com; ANSWER SECTION:www.google.com.    300    IN    A    142.250.190.78\n2.5 远程登录：SSH\n# SSH（像带加密的远程控制）$ ssh user@server.example.comPassword: *****# 连接后：1. 客户端和服务器协商加密算法2. 验证服务器身份（防止中间人攻击）3. 用户认证（密码或密钥）4. 建立加密通道# 你可以：$ ls                          # 执行命令$ vim file.txt                # 编辑文件$ scp local.txt user@server:~/  # 安全复制文件\n 三、现代应用层：不仅仅是协议\n3.1 RESTful API（现在最流行）\n# REST把网络资源当成&quot;物体&quot;来操作# 统一接口：HTTP方法对应CRUD操作GET    /api/users           # 获取用户列表GET    /api/users/123       # 获取用户123POST   /api/users           # 创建新用户PUT    /api/users/123       # 更新用户123DELETE /api/users/123       # 删除用户123# 请求示例：POST /api/users HTTP/1.1Content-Type: application/json&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;&#125;# 响应示例：HTTP/1.1 201 CreatedContent-Type: application/jsonLocation: /api/users/456&#123;&quot;id&quot;: 456, &quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;&#125;\n3.2 WebSocket（双向实时通信）\n// 传统HTTP：客户端问，服务器答（像对讲机）// WebSocket：双向随时通信（像电话）// 客户端JavaScriptconst socket = new WebSocket(&#x27;ws://example.com/chat&#x27;);socket.onopen = function() &#123;    // 连接建立，可以随时发消息    socket.send(&#x27;Hello Server!&#x27;);&#125;;socket.onmessage = function(event) &#123;    // 随时接收服务器消息    console.log(&#x27;Received:&#x27;, event.data);&#125;;// 服务器可以主动推消息，不用等客户端请求\n3.3 GraphQL（灵活的数据查询）\n# 传统REST：多个端点，固定返回格式# GraphQL：一个端点，客户端指定要什么# 客户端查询（只要id和name）query &#123;  user(id: &quot;123&quot;) &#123;    id    name  &#125;&#125;# 响应（只返回请求的字段）&#123;  &quot;data&quot;: &#123;    &quot;user&quot;: &#123;      &quot;id&quot;: &quot;123&quot;,      &quot;name&quot;: &quot;Alice&quot;    &#125;  &#125;&#125;# 可以复杂查询：query &#123;  user(id: &quot;123&quot;) &#123;    name    posts &#123;      title      comments &#123;        text        author &#123;          name        &#125;      &#125;    &#125;  &#125;&#125;\n 四、应用层的安全考虑\n4.1 HTTPS：HTTP的加密版本\n# HTTPS = HTTP + TLS加密# 建立连接过程：# 1. 客户端打招呼ClientHello  - 支持的TLS版本  - 支持的加密算法  - 客户端随机数# 2. 服务器回应ServerHello  - 选择的TLS版本和算法  - 服务器随机数  - 服务器证书（证明身份）# 3. 密钥交换客户端验证证书，生成预主密钥用服务器公钥加密发送# 4. 生成会话密钥双方用随机数+预主密钥计算相同密钥# 5. 加密通信开始之后所有HTTP数据用会话密钥加密\n4.2 OAuth 2.0（授权框架）\n# 你不用把密码给第三方应用，而是授权它访问# 流程：1. 用户点击&quot;用Google登录&quot;2. 跳转到Google授权页面3. 用户登录Google并同意授权4. Google返回授权码给应用5. 应用用授权码换访问令牌6. 应用用令牌访问用户数据# 请求示例：GET /oauth/authorize?  response_type=code&amp;  client_id=CLIENT_ID&amp;  redirect_uri=REDIRECT_URI&amp;  scope=email\n 传输层\n 一、传输层是干什么的？\n1.1 核心职责：进程到进程的通信\n应用层：浏览器 ↔ 网站传输层：Chrome进程(端口443) ↔ Nginx进程(端口443)关键概念：端口号（Port）- IP地址：找到哪台计算机- 端口号：找到哪个程序- 范围：0-65535  - 0-1023：知名端口（HTTP:80, HTTPS:443, SSH:22）  - 1024-49151：注册端口  - 49152-65535：动态/私有端口\n1.2 传输层的两大选择\nTCP（传输控制协议）：可靠的&quot;快递员&quot;  - 保证送达，保证顺序  - 速度较慢，开销较大  - 用于：网页、邮件、文件传输UDP（用户数据报协议）：快速的&quot;邮筒&quot;  - 不保证送达，不保证顺序  - 速度极快，开销极小  - 用于：视频流、游戏、DNS查询\n 二、TCP深度解析：可靠的连接\n2.1 TCP三次握手（建立连接）\n// 想象打电话的过程：// 客户端：喂，能听到吗？ (SYN)// 服务器：能听到，你能听到我吗？ (SYN+ACK)// 客户端：能听到，开始说吧！ (ACK)// 实际TCP数据包：// 包1：SYN, seq=1000// 包2：SYN, seq=2000, ACK=1001// 包3：ACK, seq=1001, ACK=2001// 为什么三次？不是两次或四次？// 两次：无法确认客户端收到服务器的SYN+ACK// 四次：冗余，第三次ACK已经足够\n2.2 TCP数据传输机制\n// TCP把数据分成&quot;段&quot;（segment）发送// 每个段有序列号，接收方按序重组// 发送方视角：1. 应用数据：&quot;Hello World&quot; (11字节)2. TCP分成：seq=1000, data=&quot;Hello &quot;           seq=1006, data=&quot;World&quot;3. 等待ACK：收到ACK=1011表示对方收到了// 接收方视角：收到seq=1000, data=&quot;Hello &quot; → 缓存收到seq=1006, data=&quot;World&quot;  → 拼成&quot;Hello World&quot;发送ACK=1011 (&quot;我收到了0-1010字节&quot;)// 如果乱序到达：收到seq=1006先到 → 等待seq=1000收到seq=1000后 → 一起交给应用层\n2.3 TCP可靠性保证的四大机制\n// 1. 确认应答（ACK）// 每收到数据，必须回复ACKstruct tcp_ack &#123;    uint32_t ack_number;  // &quot;我期望收到的下一个字节号&quot;    // 可以累积确认：ACK=5000 表示收到了0-4999&#125;;// 2. 超时重传// 发送数据后启动定时器（RTO - 重传超时）// 如果超时未收到ACK，重发数据// RTO动态调整：基于RTT（往返时间）// 3. 流量控制（滑动窗口）// 接收方：&quot;我缓冲区只剩1460字节了&quot;// 发送方：&quot;那我先发1460字节，等你腾出空间&quot;uint16_t window_size;  // 窗口大小字段，告诉对方能收多少// 4. 拥塞控制（保护网络）// 四个阶段：// - 慢启动：指数增长，试探网络容量// - 拥塞避免：线性增长，接近阈值// - 快速重传：收到3个重复ACK立即重传// - 快速恢复：拥塞后不回到慢启动\n2.4 TCP四次挥手（断开连接）\n// 想象挂电话：// 客户端：我说完了 (FIN)// 服务器：好的，我也说完了 (ACK + FIN)// 客户端：收到，再见 (ACK)// 实际过程：// 客户端 → FIN → 服务器 (我要关闭了)// 服务器 → ACK → 客户端 (知道了)// (这里可能有数据传输延迟)// 服务器 → FIN → 客户端 (我也要关了)// 客户端 → ACK → 服务器 (好的，再见)// 为什么需要TIME_WAIT状态？// 客户端发送最后一个ACK后等待2MSL（最大段生存期）// 原因：// 1. 确保对方收到ACK（如果没收到会重传FIN）// 2. 让旧连接的数据包在网络中消失，避免混淆新连接\n 三、UDP深度解析：简单的数据报\n3.1 UDP协议特点\n// UDP头只有8字节（TCP至少20字节）struct udphdr &#123;    uint16_t source_port;    // 源端口    uint16_t dest_port;      // 目标端口    uint16_t length;         // UDP头+数据总长度    uint16_t checksum;       // 校验和（可选）&#125;;// UDP的特点：// 1. 无连接：直接发送，不需要握手// 2. 不可靠：不保证到达，不保证顺序// 3. 无状态：不维护连接状态// 4. 无流量控制：能发多快发多快// 5. 无拥塞控制：可能淹没网络// 但正是这种&quot;简单&quot;在某些场景是优势\n3.2 UDP使用场景\n// 场景1：DNS查询// 请求：&quot;www.google.com的IP？&quot;// 响应：&quot;142.250.190.78&quot;// 特点：小数据包，快速响应，一次查询一次响应// 场景2：音视频流// 视频帧1 → 视频帧2 → 视频帧3// 丢了一帧？继续播下一帧！// 重传旧帧反而会导致卡顿// 场景3：在线游戏// 玩家位置更新：新位置比旧位置更重要// 如果位置包延迟，直接发最新位置// 场景4：DHCP（动态主机配置）// 广播请求IP配置，快速获取网络参数\n3.3 UDP的可靠性实现（可选）\n// 应用层可以在UDP基础上实现可靠性// 比如QUIC协议（HTTP/3的基础）// 简单可靠UDP实现思路：struct reliable_udp_header &#123;    uint32_t sequence;       // 序列号（应用层实现）    uint32_t ack;            // 确认号（应用层实现）    uint16_t flags;          // 标志位    uint8_t data[];          // 数据&#125;;// 应用层实现：// - 序列号保证顺序// - 确认和重传保证可靠// - 但比TCP更灵活：可以自定义重传策略\n 网络层\n 一、网络层是干什么的？\n1.1 核心职责：跨网络的数据包路由\n传输层：从进程到进程（港口到港口）网络层：从主机到主机（城市到城市）你的电脑（北京） → 路由器1 → 路由器2 → ... → 目标服务器（上海）网络层解决两个问题：1. 寻址：每台设备有唯一IP地址2. 路由：找到最佳路径送到目的地\n1.2 关键概念：IP地址\n// IPv4地址：32位，点分十进制表示192.168.1.100 = 11000000.10101000.00000001.01100100// 网络部分 + 主机部分192.168.1.0/24  // 前24位是网络，后8位是主机                // 这个网络可以有254台主机（1-254）// IPv6地址：128位，冒号分隔十六进制2001:0db8:85a3:0000:0000:8a2e:0370:7334// 简写：2001:db8:85a3::8a2e:370:7334// 特殊地址：127.0.0.1     本地环回（自己）192.168.x.x   私有地址（内网用）10.x.x.x      私有地址（大型内网）172.16.x.x    私有地址\n 二、IP协议详解\n2.1 IP包头结构\n// IPv4包头（20-60字节）struct iphdr &#123;#if defined(__LITTLE_ENDIAN_BITFIELD)    __u8    ihl:4,      // 头部长度（以4字节为单位，最小5）            version:4;  // 版本（4=IPv4）#elif defined(__BIG_ENDIAN_BITFIELD)    __u8    version:4,            ihl:4;#endif    __u8    tos;        // 服务类型（优先级、延迟、吞吐量要求）    __be16  tot_len;    // 总长度（头+数据，最大65535）    __be16  id;         // 标识（用于分片重组）    __be16  frag_off;   // 分片偏移和标志    __u8    ttl;        // 生存时间（每过一跳减1，到0丢弃）    __u8    protocol;   // 上层协议（6=TCP, 17=UDP, 1=ICMP）    __sum16 check;      // 头部校验和    __be32  saddr;      // 源IP地址    __be32  daddr;      // 目标IP地址    // 可选项（如果有）&#125;;// 关键字段解释：// TTL：防止数据包永远循环//   你 traceroute 时看到的就是TTL递减过程// Protocol：告诉接收方&quot;这是TCP包，交给TCP处理&quot;\n2.2 IP分片与重组\n// 问题：网络链路有MTU（最大传输单元）// 以太网MTU=1500字节，IP头20字节，所以数据最多1480字节// 如果数据更大怎么办？分片！// 分片过程：原始IP包：总长度3000字节↓ 分成3片：片1：偏移0，长度1500，更多分片标志=1片2：偏移1480，长度1500，更多分片标志=1片3：偏移2960，长度40，更多分片标志=0// 接收方重组：收到片2 → 等片1和片3收到片1 → 等片3收到片3 → 重组完成，交给上层// 现代网络避免分片：TCP有MSS（最大段大小）// TCP握手时协商MSS，保证数据小于MTU\n2.3 IP地址分类和子网划分\n# IP地址分类（传统）A类：0.0.0.0 - 127.255.255.255    # 前8位网络，后24位主机B类：128.0.0.0 - 191.255.255.255  # 前16位网络，后16位主机C类：192.0.0.0 - 223.255.255.255  # 前24位网络，后8位主机# CIDR（无类别域间路由）现代方法192.168.1.0/24      # 前24位是网络，后8位是主机10.0.0.0/8          # 前8位是网络，后24位是主机172.16.0.0/12       # 前12位是网络，后20位是主机# 子网划分：把一个大网络分成小网络192.168.1.0/24 分成4个子网：192.168.1.0/26   # 主机范围：1-62192.168.1.64/26  # 主机范围：65-126192.168.1.128/26 # 主机范围：129-190192.168.1.192/26 # 主机范围：193-254\n 三、路由：互联网的导航系统\n3.1 路由表：网络的&quot;地图&quot;\n# 查看Linux路由表$ ip route showdefault via 192.168.1.1 dev eth0      # 默认路由：不知道去哪的都发给网关192.168.1.0/24 dev eth0 proto kernel  # 本地网络：直接发送10.0.0.0/8 via 192.168.1.2 dev eth0   # 特定网络：通过特定网关# 路由表结构：# 目标网络 → 下一跳地址 → 出口网卡# 路由查找过程（最长前缀匹配）：目标IP：192.168.1.100匹配项：1. 192.168.1.0/24 dev eth0        ✓ 匹配24位，直接发送2. 192.168.0.0/16 via 10.0.0.1    ✗ 只匹配16位，不是最具体目标IP：8.8.8.8匹配项：1. 192.168.1.0/24 dev eth0        ✗ 不匹配2. default via 192.168.1.1 dev eth0 ✓ 默认路由匹配\n3.2 路由协议：路由器之间的&quot;语言&quot;\n// 路由器如何知道网络拓扑？// 通过路由协议交换信息// 1. RIP（路由信息协议） - 距离向量//    告诉邻居：&quot;我到网络A的距离是3跳&quot;//    问题：收敛慢，最大15跳// 2. OSPF（开放最短路径优先） - 链路状态//    每个路由器知道整个网络拓扑//    自己计算最短路径（Dijkstra算法）// 3. BGP（边界网关协议） - 路径向量//    互联网骨干路由器使用//    &quot;AS100：我能到网络A，路径是AS200→AS300&quot;//    AS：自治系统（一个运营商或大公司）\n3.3 路由过程详解\n// 数据包在路由器中的旅程// 路由器收到数据包：1. 检查目标IP地址2. 查找路由表3. 确定下一跳和出口接口4. 减少TTL（如果为0则丢弃）5. 重新计算校验和6. 转发到出口接口// 实际路由表示例（简化）：struct fib_table &#123;    struct trie *trie;  // 路由表用trie树组织    // ...&#125;;// 路由查找函数：struct fib_result fib_lookup(struct net *net, struct flowi *flp) &#123;    // 根据目标IP查找路由    // 返回下一跳地址、出口设备等&#125;\n 四、相关协议\n4.1 ARP：地址解析协议\n// 问题：网络层用IP地址，但链路层用MAC地址// ARP解决：&quot;这个IP地址对应的MAC地址是什么？&quot;// ARP请求（广播）：发送者：&quot;谁的IP是192.168.1.1？请告诉192.168.1.100&quot;以太网目标MAC：FF:FF:FF:FF:FF:FF（广播）// ARP响应（单播）：192.168.1.1：&quot;我是192.168.1.1，我的MAC是00:11:22:33:44:55&quot;// Linux ARP缓存：$ arp -a? (192.168.1.1) at 00:11:22:33:44:55 [ether] on eth0? (192.168.1.100) at aa:bb:cc:dd:ee:ff [ether] on eth0\n4.2 ICMP：互联网控制消息协议\n// IP协议的&quot;辅助协议&quot;，用于错误报告和诊断// ICMP类型：// 0: Echo Reply (ping响应)// 3: Destination Unreachable (目标不可达)// 5: Redirect (重定向)// 8: Echo Request (ping请求)// 11: Time Exceeded (超时，traceroute用)// 常见用途：// 1. ping：发送ICMP Echo Request，等待Reply// 2. traceroute：发送TTL=1的包，收到Time Exceeded，知道第一跳// 3. 网络错误：收到Destination Unreachable// ICMP头：struct icmphdr &#123;    __u8    type;       // 类型    __u8    code;       // 代码（更具体信息）    __sum16 checksum;   // 校验和    // 其他字段根据类型不同&#125;;\n4.3 NAT：网络地址转换\n// 问题：IPv4地址不够用// 解决方案：多个设备共享一个公网IP// NAT工作原理：内网设备：192.168.1.100:54321 → NAT路由器NAT路由器：转换源地址为 203.0.113.1:12345 → 互联网互联网响应：203.0.113.1:12345 → NAT路由器NAT路由器：转换目标地址为 192.168.1.100:54321 → 内网// NAT表记录：// 内网IP:端口 ↔ 公网IP:端口 映射关系// 类型：// 1. 静态NAT：固定映射（服务器用）// 2. 动态NAT：临时映射（普通用户用）// 3. PAT（端口地址转换）：多个内网IP用一个公网IP，不同端口区分\n 五、IPv6：下一代IP协议\n5.1 IPv6的优势\n// IPv6包头（固定40字节）struct ipv6hdr &#123;#if defined(__LITTLE_ENDIAN_BITFIELD)    __u8    priority:4,    // 流量类别            version:4;     // 版本（6）#elif defined(__BIG_ENDIAN_BITFIELD)    __u8    version:4,            priority:4;#endif    __u8    flow_lbl[3];   // 流标签    __be16  payload_len;   // 负载长度    __u8    nexthdr;       // 下一个头（类似IPv4的protocol）    __u8    hop_limit;     // 跳数限制（类似TTL）    struct in6_addr saddr; // 源地址（128位）    struct in6_addr daddr; // 目标地址（128位）&#125;;// IPv6改进：// 1. 地址空间巨大：2^128个地址（地球每平方米10^23个地址）// 2. 简化头部：固定40字节，无分片（路径MTU发现）// 3. 更好的安全性：IPsec内置// 4. 无NAT：每个设备都有公网地址// 5. 更好的QoS支持：流标签\n5.2 IPv6地址类型\n# IPv6地址表示2001:0db8:85a3:0000:0000:8a2e:0370:7334# 简写：2001:db8:85a3::8a2e:370:7334# 特殊地址：::1                          # 环回地址（类似127.0.0.1）fe80::/10                    # 链路本地地址（类似169.254.x.x）2000::/3                     # 全球单播地址（公网地址）ff00::/8                     # 多播地址# IPv4映射的IPv6地址：::ffff:192.0.2.1             # 表示IPv4地址192.0.2.1\n 链路层\n 一、链路层是干什么的？\n1.1 核心职责：同一网络内设备间的直接通信\n网络层：北京 → 上海（跨城市）链路层：你家 → 邻居家（同一条街）链路层只关心：1. 这个数据包在本地网络发给谁？2. 用什么样的&quot;信封&quot;（帧格式）包装？3. 如何避免邻居同时说话（冲突避免）？\n1.2 工作范围：一跳之内\n你的电脑 → 交换机/路由器 → 下一跳设备      ↑ 这一跳由链路层负责链路层不关心：- 数据包最终要去哪（那是网络层的事）- 数据内容是什么（那是上层的事）- 如何跨多个网络（那是路由的事）\n 二、以太网：最主流的链路层协议\n2.1 以太网帧结构\n// 以太网帧（最小64字节，最大1518字节）struct ethhdr &#123;    unsigned char h_dest[ETH_ALEN];   // 目标MAC地址 (6字节)    unsigned char h_source[ETH_ALEN]; // 源MAC地址 (6字节)    __be16 h_proto;                   // 上层协议类型 (2字节)    // 后面是数据（46-1500字节）    // 最后是CRC校验（4字节）&#125; __attribute__((packed));// 关键字段解释：// MAC地址：00:11:22:33:44:55//   - 前3字节：厂商标识（OUI）//   - 后3字节：设备序列号//   - 全球唯一（理论上）// 协议类型：// 0x0800: IPv4// 0x0806: ARP// 0x86DD: IPv6// 0x8100: VLAN标签\n2.2 MAC地址详解\n# 查看本机MAC地址$ ip link show eth02: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000    link/ether 00:11:22:33:44:55 brd ff:ff:ff:ff:ff:ff# MAC地址类型：00:11:22:33:44:55    # 单播地址（发给特定设备）ff:ff:ff:ff:ff:ff    # 广播地址（发给所有设备）01:00:5e:xx:xx:xx    # 多播地址（发给一组设备）# MAC地址由IEEE分配：00:11:22              # 可能是Intel网卡00:50:56              # VMware虚拟网卡08:00:27              # VirtualBox虚拟网卡\n 三、交换机：链路层的智能中枢\n3.1 交换机如何工作\n// 交换机维护一个MAC地址表// 记录：哪个MAC地址在哪个端口struct mac_table_entry &#123;    unsigned char mac[ETH_ALEN];  // MAC地址    int port;                     // 端口号    time_t timestamp;             // 上次看到的时间&#125;;// 交换机工作流程：1. 学习：收到帧时，记录源MAC和入口端口2. 转发：查看目标MAC，查表决定出口端口3. 广播：如果MAC不在表中，向所有端口转发（除入口）// 示例：端口1收到：源MAC=AA:BB:CC:DD:EE:FF，目标MAC=00:11:22:33:44:551. 学习：AA:BB:CC:DD:EE:FF在端口12. 查表：00:11:22:33:44:55在端口33. 转发：只从端口3转发出去// 如果目标MAC是广播地址ff:ff:ff:ff:ff:ff// 则向所有端口转发（泛洪）\n3.2 交换机的三种转发方式\n1. 存储转发（最常用）   - 接收完整帧   - 检查CRC错误   - 查表转发   - 延迟较大，但可靠2. 直通交换   - 收到目标MAC就开始转发   - 延迟小，但可能转发错误帧3. 无碎片交换   - 收到前64字节（避免冲突碎片）后转发   - 平衡了延迟和可靠性\n 四、无线网络（Wi-Fi）的链路层\n4.1 802.11帧结构\n// 无线帧比以太网帧复杂很多struct ieee80211_hdr &#123;    __le16 frame_control;     // 帧控制字段    __le16 duration_id;       // 持续时间/ID    u8 addr1[6];             // 接收方地址    u8 addr2[6];             // 发送方地址    u8 addr3[6];             // 过滤地址（通常BSSID）    __le16 seq_ctrl;          // 序列控制    // 可选：地址4、QoS控制等    // 然后是帧主体&#125;;// 无线网络的特殊问题：// 1. 共享介质：大家用同一频率，会冲突// 2. 隐藏节点：A和C都能和B通信，但彼此听不到// 3. 信号衰减：距离远了信号弱\n4.2 CSMA/CA：避免冲突的机制\n// 有线以太网用CSMA/CD：冲突检测// 无线用CSMA/CA：冲突避免（因为难以检测冲突）// CSMA/CA流程：1. 监听信道：如果忙，等待随机时间再试2. 发送RTS：请求发送（可选）3. 等待CTS：清除发送（可选）4. 发送数据5. 等待ACK：接收方确认收到// RTS/CTS解决隐藏节点问题：// A想发给B，但C在附近也在发// A发RTS，B回CTS，C听到CTS就知道信道被占用了\n 五、ARP协议再深入\n5.1 ARP完整流程\n// 情景：你的电脑(192.168.1.100)想访问路由器(192.168.1.1)// 步骤1：查ARP缓存$ arp -a? (192.168.1.1) at 00:11:22:33:44:55 [ether] on eth0// 如果有，直接使用MAC地址// 步骤2：如果没有，发送ARP请求// 以太网帧：目标MAC: ff:ff:ff:ff:ff:ff (广播)源MAC: aa:bb:cc:dd:ee:ff协议类型: 0x0806 (ARP)数据: &quot;谁的IP是192.168.1.1？告诉192.168.1.100&quot;// 步骤3：路由器回复目标MAC: aa:bb:cc:dd:ee:ff (你的电脑)源MAC: 00:11:22:33:44:55 (路由器)数据: &quot;我是192.168.1.1，MAC是00:11:22:33:44:55&quot;// 步骤4：更新ARP缓存// 现在知道192.168.1.1的MAC了\n5.2 ARP攻击与防御\n// ARP欺骗（中间人攻击）：// 攻击者发送虚假ARP响应：// &quot;我是192.168.1.1，MAC是攻击者的MAC&quot;// 结果：你的流量都经过攻击者// 防御：// 1. 静态ARP条目（手动绑定）$ arp -s 192.168.1.1 00:11:22:33:44:55// 2. ARP监控软件// 检测异常的ARP活动// 3. 交换机安全特性// 端口安全：每个端口只允许特定MAC// DHCP监听：防止虚假DHCP服务器\n 六、VLAN：虚拟局域网\n6.1 VLAN的作用\n问题：大型公司有多个部门，都在一个物理网络      - 财务部数据能被工程部看到      - 广播风暴影响所有部门解决方案：VLAN物理上一个交换机，逻辑上分成多个虚拟交换机\n6.2 VLAN帧格式\n// 带VLAN标签的以太网帧struct vlan_ethhdr &#123;    unsigned char h_dest[ETH_ALEN];    unsigned char h_source[ETH_ALEN];    __be16 h_vlan_proto;      // 固定0x8100    __be16 h_vlan_TCI;        // VLAN标签信息    __be16 h_vlan_encapsulated_proto;  // 上层协议    // 数据...&#125;;// VLAN TCI字段：// - PCP (3位): 优先级// - DEI (1位): 丢弃资格指示// - VID (12位): VLAN ID (1-4094)// 示例：VLAN 10：财务部 (192.168.10.0/24)VLAN 20：工程部 (192.168.20.0/24)VLAN 30：访客网络 (192.168.30.0/24)// 即使物理连接同一交换机，不同VLAN不能直接通信// 需要路由器（或三层交换机）在VLAN间转发\n 物理层\n 一、物理层是干什么的？\n1.1 核心职责：把0和1变成物理信号\n上层看到的是：0 1 0 1 0 1物理层看到的是：- 网线：高电压(1) 低电压(0) 高电压(1)- 光纤：亮(1) 灭(0) 亮(1)- 无线电：特定频率(1) 另一频率(0)物理层不关心：- 数据是什么意思- 数据要发给谁- 数据是否正确它只关心：怎么可靠地传输比特\n1.2 物理层的两大任务\n1. 编码：把比特变成信号   计算机：0101   物理层：高高低高高高低高（电压变化）2. 传输：把信号送到对面   通过：铜线、光纤、空气（无线）\n 二、有线传输：看得见的物理层\n2.1 以太网电缆（双绞线）\n// 常见的网线：Cat5e、Cat6、Cat7// 8根线分成4对，每对双绞（减少干扰）// 引脚定义（T568B标准）：引脚  颜色      用途1    白橙       TX+ (发送正)2    橙         TX- (发送负)3    白绿       RX+ (接收正)6    绿         RX- (接收负)4    蓝         (有时用于电话)5    白蓝7    白棕8    棕// 为什么双绞？// 每对线互相缠绕，外部干扰会同时影响两根线// 接收方比较两根线的差值，抵消干扰// 水晶头（RJ45）连接：1. 剥开外皮，理直8根线2. 按顺序排好：白橙、橙、白绿、蓝、白蓝、绿、白棕、棕3. 剪齐，插入水晶头4. 用压线钳压紧\n2.2 编码技术：如何表示0和1\n// 曼彻斯特编码（旧以太网用）// 每个比特中间都有跳变// 0：高→低跳变// 1：低→高跳变// 示例：数据： 0   1   0   1   0信号：高→低 低→高 高→低 低→高 高→低      |___| |___| |___| |___| |___|// 优点：自带时钟，接收方容易同步// 缺点：效率只有50%（每个比特都有跳变）// 4B/5B编码（更快以太网用）// 每4个数据比特映射为5个传输比特// 保证至少有2次跳变，保持同步// 效率：80%// 8B/10B编码（千兆以太网）// 每8比特映射为10比特// 平衡0和1的数量（直流平衡）\n2.3 物理层设备：中继器和集线器\n// 中继器（Repeater）：// 功能：放大信号，延长传输距离// 问题：也放大噪声// 现代基本不用，被交换机取代// 集线器（Hub）：// 多端口中继器// 收到信号 → 放大 → 转发给所有其他端口// 工作在物理层，没有智能// 集线器的问题：// 1. 所有设备共享带宽（10Mbps集线器，4个设备，每个最多2.5Mbps）// 2. 冲突域大：一个设备发数据，其他都要等// 3. 不安全：所有设备看到所有数据\n 三、无线传输：看不见的物理层\n3.1 Wi-Fi无线电基础\n// 无线网络在特定频率工作// 2.4GHz频段：// 信道1：2.412 GHz// 信道6：2.437 GHz// 信道11：2.462 GHz// （中国有13个信道，美国11个）// 5GHz频段：// 更多信道，更少干扰，但穿透力差// 调制技术：把数据加载到无线电波上// 1. BPSK：1比特/符号（最慢，最可靠）// 2. QPSK：2比特/符号// 3. 16-QAM：4比特/符号// 4. 64-QAM：6比特/符号（最快，需要好信号）// 5. 256-QAM：8比特/符号（Wi-Fi 6）// MIMO（多输入多输出）：// 多个天线同时收发，提高速度和可靠性\n3.2 无线信号特性\n# 无线信号随距离衰减（自由空间路径损耗）def path_loss(distance, frequency):    &quot;&quot;&quot;    distance: 距离（米）    frequency: 频率（Hz）    返回：路径损耗（dB）    &quot;&quot;&quot;    # 公式：PL = 20*log10(d) + 20*log10(f) + 20*log10(4π/c) - Gt - Gr    # 简化：每倍距离增加6dB损耗    return 20 * math.log10(distance) + 20 * math.log10(frequency) + 147.55# 示例：2.4GHz Wi-Fi，10米距离loss = path_loss(10, 2.4e9)  # 约60dB损耗# 障碍物影响：# 墙壁：3-10dB损耗# 地板：10-20dB损耗# 金属：完全阻挡\n 四、光纤传输：光速的物理层\n4.1 光纤原理\n// 光纤结构：// 核心：高折射率玻璃（直径9-62.5微米）// 包层：低折射率玻璃// 涂覆层：保护层// 工作原理：全内反射// 光在核心内反射前进，不会漏出// 两种类型：// 1. 多模光纤（MMF）：//    - 核心较粗（50或62.5微米）//    - 光有多种路径（模式）//    - 距离短（500米以内）//    - 便宜，用于局域网// 2. 单模光纤（SMF）：//    - 核心很细（9微米）//    - 光只有一种路径//    - 距离长（数十公里）//    - 贵，用于长途通信\n4.2 光传输系统\n// 光通信组件：// 1. 光源：激光二极管或LED//    - 激光：相干光，适合单模长距离//    - LED：非相干光，适合多模短距离// 2. 调制：直接调制或外调制//    - 直接：改变驱动电流改变光强//    - 外调制：恒定光源+外部调制器（更高速）// 3. 光纤：传输介质// 4. 探测器：光电二极管//    - PIN光电二极管：普通速度//    - 雪崩光电二极管（APD）：高灵敏度// 波分复用（WDM）：// 一根光纤传输多个波长（颜色）的光// 提高容量：160个波长 × 100Gbps = 16Tbps\n 五、物理层标准与速率\n5.1 以太网物理层标准\n# 常见以太网标准：10BASE-T:   10 Mbps, 双绞线, 100米100BASE-TX: 100 Mbps, Cat5双绞线, 100米   # 快速以太网1000BASE-T: 1 Gbps, Cat5e双绞线, 100米    # 千兆以太网10GBASE-T:  10 Gbps, Cat6a双绞线, 100米   # 万兆以太网# 光纤标准：1000BASE-SX: 1 Gbps, 多模光纤, 550米（850nm波长）1000BASE-LX: 1 Gbps, 单模光纤, 5公里（1310nm波长）10GBASE-SR:  10 Gbps, 多模光纤, 300米10GBASE-LR:  10 Gbps, 单模光纤, 10公里100GBASE-SR4: 100 Gbps, 多模光纤, 100米（并行4光纤）# 命名规则：- 10/100/1000：速率 Mbps- BASE：基带传输（数字信号）- T：双绞线，S：短波，L：长波，X：特殊编码\n5.2 Wi-Fi物理层标准\n# IEEE 802.11系列：802.11b: 2.4GHz, 最大11 Mbps (1999)802.11a: 5GHz, 最大54 Mbps (1999)802.11g: 2.4GHz, 最大54 Mbps (2003)802.11n: 2.4/5GHz, 最大600 Mbps (2009)  # Wi-Fi 4802.11ac: 5GHz, 最大6.9 Gbps (2014)      # Wi-Fi 5802.11ax: 2.4/5/6GHz, 最大9.6 Gbps (2019) # Wi-Fi 6802.11be: 即将发布，Wi-Fi 7，最大30 Gbps# 实际速度：标称速度 ≠ 实际速度- 802.11ac 1300Mbps → 实际约500-800Mbps- 802.11ax 2400Mbps → 实际约800-1200Mbps# 原因：协议开销、信号干扰、共享介质\n 六、物理层的关键问题与解决方案\n6.1 信号衰减与失真\n// 问题1：信号随距离衰减// 解决方案：中继器/放大器// 问题2：码间干扰（ISI）// 一个信号位影响下一个位// 原因：带宽有限，信号展宽// 解决方案：// 1. 均衡器：补偿频率响应// 2. 更好的编码：减少高频分量// 问题3：时钟同步// 发送方和接收方时钟有微小差异// 解决方案：// 1. 曼彻斯特编码：自带时钟// 2. 锁相环（PLL）：从数据流提取时钟// 3. 弹性缓冲区：容忍微小差异\n6.2 错误检测与纠正\n// 物理层不纠正错误（那是上层的事）// 但可以检测错误并标记// 常见技术：// 1. 奇偶校验：1位错误检测，不能纠正//    偶校验：数据中1的个数为偶数，校验位=0//    奇校验：数据中1的个数为奇数，校验位=1// 2. CRC（循环冗余校验）：以太网用//    发送方：数据 ÷ 生成多项式 = 余数，附加余数//    接收方：（数据+余数）÷ 生成多项式，应该余0//    能检测多位错误// 物理层发现错误 → 丢弃帧 → 上层重传\n","categories":["-网络通信"]},{"title":"汇编语言","url":"/2026/02/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","content":"","categories":["-汇编语言"]},{"title":"高等代数","url":"/2026/02/27/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/","content":" 一、多项式\n 1. 一元多项式的基本概念\n定义 1（多项式）\n设 PPP 是一个数域，xxx 是一个文字，形式表达式\nf(x)=anxn+an−1xn−1+⋯+a1x+a0f(x) = a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_1 x + a_0\nf(x)=an​xn+an−1​xn−1+⋯+a1​x+a0​\n称为数域 PPP 上的一元多项式，其中 ai∈Pa_i \\in Pai​∈P。\n定义 2（次数）\n若 an≠0a_n \\neq 0an​=0，则称 nnn 为多项式 f(x)f(x)f(x) 的次数，记作 deg⁡f(x)=n\\deg f(x) = ndegf(x)=n，ana_nan​ 称为首项系数。\n定义 3（多项式相等）\n两个多项式相等当且仅当它们的同次项系数全相等。\n 2. 多项式的运算\n性质 1\n设 f(x),g(x)∈P[x]f(x), g(x) \\in P[x]f(x),g(x)∈P[x]，则：\ndeg⁡(f(x)±g(x))≤max⁡{deg⁡f,deg⁡g}\\deg(f(x) \\pm g(x)) \\leq \\max\\{\\deg f, \\deg g\\}\ndeg(f(x)±g(x))≤max{degf,degg}\ndeg⁡(f(x)g(x))=deg⁡f+deg⁡g\\deg(f(x)g(x)) = \\deg f + \\deg g\ndeg(f(x)g(x))=degf+degg\n 3. 带余除法\n定理 1（带余除法）\n对于 f(x),g(x)∈P[x]f(x), g(x) \\in P[x]f(x),g(x)∈P[x]，g(x)≠0g(x) \\neq 0g(x)=0，存在唯一的 q(x),r(x)∈P[x]q(x), r(x) \\in P[x]q(x),r(x)∈P[x]，使得\nf(x)=q(x)g(x)+r(x)f(x) = q(x)g(x) + r(x)\nf(x)=q(x)g(x)+r(x)\n其中 deg⁡r(x)&lt;deg⁡g(x)\\deg r(x) &lt; \\deg g(x)degr(x)&lt;degg(x) 或 r(x)=0r(x) = 0r(x)=0。\n 4. 最大公因式\n定义 4（最大公因式）\n设 f(x),g(x)∈P[x]f(x), g(x) \\in P[x]f(x),g(x)∈P[x]，d(x)d(x)d(x) 称为 f(x)f(x)f(x) 与 g(x)g(x)g(x) 的最大公因式，若：\n\nd(x)∣f(x)d(x) \\mid f(x)d(x)∣f(x) 且 d(x)∣g(x)d(x) \\mid g(x)d(x)∣g(x)\n若 h(x)∣f(x)h(x) \\mid f(x)h(x)∣f(x) 且 h(x)∣g(x)h(x) \\mid g(x)h(x)∣g(x)，则 h(x)∣d(x)h(x) \\mid d(x)h(x)∣d(x)\n\n定理 2\nf(x)f(x)f(x) 与 g(x)g(x)g(x) 的最大公因式存在，且存在 u(x),v(x)∈P[x]u(x), v(x) \\in P[x]u(x),v(x)∈P[x] 使得\nd(x)=u(x)f(x)+v(x)g(x)d(x) = u(x)f(x) + v(x)g(x)\nd(x)=u(x)f(x)+v(x)g(x)\n 5. 因式分解定理\n定义 5（不可约多项式）\n次数 ≥1\\geq 1≥1 的多项式 p(x)p(x)p(x) 称为不可约的，若它不能表示为两个次数比它低的多项式的乘积。\n定理 3（唯一因式分解定理）\n数域 PPP 上任意次数 ≥1\\geq 1≥1 的多项式均可唯一分解为不可约多项式的乘积：\nf(x)=ap1r1(x)p2r2(x)⋯psrs(x)f(x) = a p_1^{r_1}(x) p_2^{r_2}(x) \\cdots p_s^{r_s}(x)\nf(x)=ap1r1​​(x)p2r2​​(x)⋯psrs​​(x)\n 6. 重因式\n定义 6（重因式）\n若不可约多项式 p(x)p(x)p(x) 满足 pk(x)∣f(x)p^k(x) \\mid f(x)pk(x)∣f(x) 但 pk+1(x)∤f(x)p^{k+1}(x) \\nmid f(x)pk+1(x)∤f(x)，则称 p(x)p(x)p(x) 为 f(x)f(x)f(x) 的 kkk 重因式。\n定理 4\n若 p(x)p(x)p(x) 是 f(x)f(x)f(x) 的 kkk 重因式，则 p(x)p(x)p(x) 是 f′(x)f&#x27;(x)f′(x) 的 k−1k-1k−1 重因式。\n 7. 复数域、实数域上的多项式\n定理 5（代数基本定理）\n每个次数 ≥1\\geq 1≥1 的复系数多项式在复数域中至少有一个根。\n定理 6\n复数域上的不可约多项式只有一次多项式。\n定理 7\n实数域上的不可约多项式只有一次多项式和判别式小于零的二次多项式。\n\n 二、行列式\n 1. 排列与逆序\n定义 7（排列）\n由 1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 组成的一个有序数组称为一个 nnn 级排列。\n定义 8（逆序数）\n排列中逆序的总数称为该排列的逆序数，记作 τ(i1i2⋯in)\\tau(i_1 i_2 \\cdots i_n)τ(i1​i2​⋯in​)。\n定义 9（奇偶排列）\n逆序数为奇数的排列称为奇排列，为偶数的称为偶排列。\n 2. nnn 阶行列式的定义\n定义 10\nnnn 阶行列式\ndet⁡A=∣a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮an1an2⋯ann∣=∑j1j2⋯jn(−1)τ(j1j2⋯jn)a1j1a2j2⋯anjn\\det A = \\begin{vmatrix}\na_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\na_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\na_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\n\\end{vmatrix} = \\sum_{j_1 j_2 \\cdots j_n} (-1)^{\\tau(j_1 j_2 \\cdots j_n)} a_{1j_1} a_{2j_2} \\cdots a_{nj_n}\ndetA=∣∣∣∣∣∣∣∣∣∣​a11​a21​⋮an1​​a12​a22​⋮an2​​⋯⋯⋱⋯​a1n​a2n​⋮ann​​∣∣∣∣∣∣∣∣∣∣​=j1​j2​⋯jn​∑​(−1)τ(j1​j2​⋯jn​)a1j1​​a2j2​​⋯anjn​​\n 3. 行列式的性质\n性质 2\n行列互换，行列式的值不变，即 det⁡A=det⁡AT\\det A = \\det A^TdetA=detAT。\n性质 3\n互换行列式的两行（列），行列式变号。\n性质 4\n行列式的某一行（列）有公因子 kkk，则可提到行列式外面。\n性质 5\n若行列式有两行（列）完全相同，则行列式为零。\n性质 6\n若行列式有两行（列）成比例，则行列式为零。\n性质 7\n将行列式的某一行（列）的 kkk 倍加到另一行（列）上，行列式的值不变。\n 4. 行列式按一行（列）展开\n定义 11（余子式）\n在 nnn 阶行列式中，划去 aija_{ij}aij​ 所在的行和列，剩下的元素按原次序组成的 n−1n-1n−1 阶行列式称为 aija_{ij}aij​ 的余子式，记作 MijM_{ij}Mij​。\n定义 12（代数余子式）\nAij=(−1)i+jMijA_{ij} = (-1)^{i+j} M_{ij}Aij​=(−1)i+jMij​ 称为 aija_{ij}aij​ 的代数余子式。\n定理 8（展开定理）\ndet⁡A=∑j=1naijAij(按第 i 行展开)\\det A = \\sum_{j=1}^n a_{ij} A_{ij} \\quad (\\text{按第 } i \\text{ 行展开})\ndetA=j=1∑n​aij​Aij​(按第 i 行展开)\ndet⁡A=∑i=1naijAij(按第 j 列展开)\\det A = \\sum_{i=1}^n a_{ij} A_{ij} \\quad (\\text{按第 } j \\text{ 列展开})\ndetA=i=1∑n​aij​Aij​(按第 j 列展开)\n 5. 克拉默法则\n定理 9（克拉默法则）\n若线性方程组\n{a11x1+a12x2+⋯+a1nxn=b1a21x1+a22x2+⋯+a2nxn=b2⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯an1x1+an2x2+⋯+annxn=bn\\begin{cases}\na_{11}x_1 + a_{12}x_2 + \\cdots + a_{1n}x_n = b_1 \\\\\na_{21}x_1 + a_{22}x_2 + \\cdots + a_{2n}x_n = b_2 \\\\\n\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots \\\\\na_{n1}x_1 + a_{n2}x_2 + \\cdots + a_{nn}x_n = b_n\n\\end{cases}\n⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​a11​x1​+a12​x2​+⋯+a1n​xn​=b1​a21​x1​+a22​x2​+⋯+a2n​xn​=b2​⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯an1​x1​+an2​x2​+⋯+ann​xn​=bn​​\n的系数行列式 D≠0D \\neq 0D=0，则方程组有唯一解：\nxj=DjD,j=1,2,⋯ ,nx_j = \\frac{D_j}{D},\\quad j = 1,2,\\cdots,n\nxj​=DDj​​,j=1,2,⋯,n\n其中 DjD_jDj​ 是将 DDD 的第 jjj 列换成常数项得到的行列式。\n\n 三、线性方程组\n 1. 消元法\n定义 13（矩阵）\n由 m×nm \\times nm×n 个数排成的 mmm 行 nnn 列的数表称为 m×nm \\times nm×n 矩阵。\n定义 14（阶梯形矩阵）\n满足以下条件的矩阵称为行阶梯形矩阵：\n\n零行在矩阵的最下方\n非零行的第一个非零元（称为主元）的列指标随行指标的增加而严格增加\n\n 2. 矩阵的秩\n定义 15（kkk 阶子式）\n在 m×nm \\times nm×n 矩阵 AAA 中，任取 kkk 行 kkk 列，位于这些行和列交叉处的元素按原次序组成的 kkk 阶行列式称为 AAA 的一个 kkk 阶子式。\n定义 16（秩）\n矩阵 AAA 的非零子式的最高阶数称为 AAA 的秩，记作 r(A)r(A)r(A)。\n 3. 线性方程组解的存在性\n定理 10（线性方程组有解判别定理）\n线性方程组 AX=BAX = BAX=B 有解的充要条件是系数矩阵的秩等于增广矩阵的秩：\nr(A)=r(Aˉ)r(A) = r(\\bar{A})\nr(A)=r(Aˉ)\n定理 11\n设 r(A)=r(Aˉ)=rr(A) = r(\\bar{A}) = rr(A)=r(Aˉ)=r，则：\n\n当 r=nr = nr=n 时，方程组有唯一解\n当 r&lt;nr &lt; nr&lt;n 时，方程组有无穷多解，自由未知量的个数为 n−rn - rn−r\n\n 4. 齐次线性方程组\n定理 12\nnnn 元齐次线性方程组 AX=0AX = 0AX=0 有非零解的充要条件是 r(A)&lt;nr(A) &lt; nr(A)&lt;n。\n定理 13\n当 m&lt;nm &lt; nm&lt;n 时，mmm 个方程 nnn 个未知数的齐次线性方程组必有非零解。\n\n 四、矩阵\n 1. 矩阵的运算\n定义 17（矩阵加法）\n设 A=(aij)m×nA = (a_{ij})_{m \\times n}A=(aij​)m×n​，B=(bij)m×nB = (b_{ij})_{m \\times n}B=(bij​)m×n​，则\nA+B=(aij+bij)m×nA + B = (a_{ij} + b_{ij})_{m \\times n}\nA+B=(aij​+bij​)m×n​\n定义 18（数乘矩阵）\nkA=(kaij)m×nkA = (k a_{ij})_{m \\times n}\nkA=(kaij​)m×n​\n定义 19（矩阵乘法）\n设 A=(aij)m×sA = (a_{ij})_{m \\times s}A=(aij​)m×s​，B=(bij)s×nB = (b_{ij})_{s \\times n}B=(bij​)s×n​，则 C=ABC = ABC=AB 是 m×nm \\times nm×n 矩阵，其中\ncij=∑k=1saikbkjc_{ij} = \\sum_{k=1}^s a_{ik} b_{kj}\ncij​=k=1∑s​aik​bkj​\n性质 8\n矩阵乘法满足结合律，不满足交换律。\n 2. 矩阵的转置\n定义 20（转置矩阵）\n将 A=(aij)m×nA = (a_{ij})_{m \\times n}A=(aij​)m×n​ 的行列互换得到的 n×mn \\times mn×m 矩阵称为 AAA 的转置，记作 ATA^TAT。\n性质 9\n(AT)T=A(A^T)^T = A(AT)T=A，(A+B)T=AT+BT(A + B)^T = A^T + B^T(A+B)T=AT+BT，(kA)T=kAT(kA)^T = kA^T(kA)T=kAT，(AB)T=BTAT(AB)^T = B^T A^T(AB)T=BTAT。\n 3. 逆矩阵\n定义 21（逆矩阵）\n对于 nnn 阶方阵 AAA，若存在 nnn 阶方阵 BBB 使得 AB=BA=InAB = BA = I_nAB=BA=In​，则称 AAA 可逆，BBB 称为 AAA 的逆矩阵，记作 A−1A^{-1}A−1。\n定理 14\nAAA 可逆 ⇔\\Leftrightarrow⇔ det⁡A≠0\\det A \\neq 0detA=0。\n定理 15\n若 AAA 可逆，则\nA−1=1det⁡AA∗A^{-1} = \\frac{1}{\\det A} A^*\nA−1=detA1​A∗\n其中 A∗A^*A∗ 是 AAA 的伴随矩阵。\n 4. 初等变换与初等矩阵\n定义 22（初等变换）\n三种行（列）变换：\n\n交换两行\n用非零常数乘某一行\n将一行的 kkk 倍加到另一行\n\n定义 23（初等矩阵）\n由单位矩阵经过一次初等变换得到的矩阵称为初等矩阵。\n定理 16\n对矩阵 AAA 施行初等行变换相当于左乘相应的初等矩阵；施行初等列变换相当于右乘相应的初等矩阵。\n 5. 矩阵的秩的性质\n性质 10\nr(A)=r(AT)r(A) = r(A^T)r(A)=r(AT)\n性质 11\nr(AB)≤min⁡{r(A),r(B)}r(AB) \\leq \\min\\{r(A), r(B)\\}r(AB)≤min{r(A),r(B)}\n性质 12\nr(A+B)≤r(A)+r(B)r(A + B) \\leq r(A) + r(B)r(A+B)≤r(A)+r(B)\n\n 五、二次型\n 1. 二次型的概念\n定义 24（二次型）\n含有 nnn 个变量 x1,x2,⋯ ,xnx_1, x_2, \\cdots, x_nx1​,x2​,⋯,xn​ 的二次齐次函数\nf(x1,x2,⋯ ,xn)=∑i=1n∑j=1naijxixjf(x_1, x_2, \\cdots, x_n) = \\sum_{i=1}^n \\sum_{j=1}^n a_{ij} x_i x_j\nf(x1​,x2​,⋯,xn​)=i=1∑n​j=1∑n​aij​xi​xj​\n称为二次型，其中 aij∈Pa_{ij} \\in Paij​∈P。\n定义 25（矩阵表示）\n二次型可表示为 f=XTAXf = X^T A Xf=XTAX，其中 AAA 为对称矩阵，称为二次型的矩阵。\n 2. 合同变换\n定义 26（合同）\n设 A,BA, BA,B 为 nnn 阶方阵，若存在可逆矩阵 CCC 使得 B=CTACB = C^T A CB=CTAC，则称 AAA 与 BBB 合同。\n性质 13\n合同关系是等价关系，且合同矩阵的秩相等。\n 3. 化二次型为标准形\n定理 17（配方法）\n任意二次型可通过非退化线性替换化为标准形：\nf=d1y12+d2y22+⋯+dnyn2f = d_1 y_1^2 + d_2 y_2^2 + \\cdots + d_n y_n^2\nf=d1​y12​+d2​y22​+⋯+dn​yn2​\n定理 18（正交变换法）\n对于实二次型，存在正交变换 X=QYX = QYX=QY 使其化为标准形：\nf=λ1y12+λ2y22+⋯+λnyn2f = \\lambda_1 y_1^2 + \\lambda_2 y_2^2 + \\cdots + \\lambda_n y_n^2\nf=λ1​y12​+λ2​y22​+⋯+λn​yn2​\n其中 λi\\lambda_iλi​ 是 AAA 的特征值。\n 4. 惯性定理\n定理 19（惯性定理）\n实二次型的标准形中，正平方项的个数 ppp 和负平方项的个数 qqq 是由二次型唯一确定的，与所做的非退化线性替换无关。(p,q)(p, q)(p,q) 称为惯性指数，p−qp - qp−q 称为符号差。\n 5. 正定二次型\n定义 27（正定二次型）\n实二次型 f=XTAXf = X^T A Xf=XTAX 称为正定的，若对任意非零向量 XXX，都有 f(X)&gt;0f(X) &gt; 0f(X)&gt;0。\n定理 20\n实二次型正定的充要条件是：\n\n它的标准形的所有系数都大于 0\n它的矩阵的所有顺序主子式都大于 0\n\n","categories":["-高等代数"]}]
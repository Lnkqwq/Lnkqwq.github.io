[{"title":"CF","url":"/2026/02/27/CF/","content":"","categories":["CF"],"tags":["C++"]},{"title":"DB-notes","url":"/2026/02/23/Database/","content":" SQL\n SQL基础\n DDL（定义结构）\n一、数据库操作\n-- 创建数据库CREATE DATABASE 数据库名;-- 删除数据库DROP DATABASE 数据库名;-- 修改数据库（某些数据库支持）ALTER DATABASE 数据库名 ...;\n二、表操作（核心）\n创建表\nCREATE TABLE 表名 (    列名 数据类型,    列名 数据类型,    ...);\n数据类型概览\n-- 数值型INT / INTEGERBIGINTSMALLINTDECIMAL(p,s) / NUMERIC(p,s)FLOAT / DOUBLEREAL-- 字符型CHAR(n)           -- 定长VARCHAR(n)        -- 变长TEXT              -- 长文本-- 日期时间型DATETIMETIMESTAMP / DATETIMEYEAR-- 二进制型BLOBBINARY(n)VARBINARY(n)-- 布尔型BOOLEAN / BOOL\n约束条件\n-- 列级约束（跟在数据类型后）列名 数据类型 PRIMARY KEY列名 数据类型 NOT NULL列名 数据类型 UNIQUE列名 数据类型 DEFAULT 默认值列名 数据类型 CHECK (条件)列名 数据类型 REFERENCES 其他表(列)-- 表级约束（单独定义）PRIMARY KEY (列1, 列2, ...)UNIQUE (列1, 列2, ...)FOREIGN KEY (列) REFERENCES 其他表(列)CHECK (条件)\n创建完整表结构\nCREATE TABLE 表名 (    列名1 数据类型 [约束],    列名2 数据类型 [约束],    [表级约束1],    [表级约束2],    ...);\n三、修改表结构\n增加列\nALTER TABLE 表名 ADD 列名 数据类型;ALTER TABLE 表名 ADD 列名 数据类型 [约束];\n删除列\nALTER TABLE 表名 DROP COLUMN 列名;\n修改列\n-- 修改数据类型ALTER TABLE 表名 MODIFY COLUMN 列名 新数据类型;-- 修改列名（某些数据库使用）ALTER TABLE 表名 RENAME COLUMN 旧列名 TO 新列名;ALTER TABLE 表名 CHANGE 旧列名 新列名 数据类型;\n添加约束\nALTER TABLE 表名 ADD CONSTRAINT 约束名 PRIMARY KEY (列);ALTER TABLE 表名 ADD CONSTRAINT 约束名 UNIQUE (列);ALTER TABLE 表名 ADD CONSTRAINT 约束名 FOREIGN KEY (列) REFERENCES 其他表(列);ALTER TABLE 表名 ADD CONSTRAINT 约束名 CHECK (条件);\n删除约束\nALTER TABLE 表名 DROP CONSTRAINT 约束名;ALTER TABLE 表名 DROP PRIMARY KEY;ALTER TABLE 表名 DROP FOREIGN KEY 约束名;\n修改表名\nALTER TABLE 旧表名 RENAME TO 新表名;RENAME TABLE 旧表名 TO 新表名;\n四、删除表结构\n删除表\nDROP TABLE 表名;\n清空表数据（保留结构）\nTRUNCATE TABLE 表名;\n五、其他对象操作\n索引\nCREATE INDEX 索引名 ON 表名 (列);CREATE UNIQUE INDEX 索引名 ON 表名 (列);DROP INDEX 索引名;\n视图\nCREATE VIEW 视图名 AS SELECT语句;DROP VIEW 视图名;\n序列（部分数据库）\nCREATE SEQUENCE 序列名;DROP SEQUENCE 序列名;\n DML（操作数据）\n一、插入数据 (INSERT)\n插入完整行\nINSERT INTO 表名 VALUES (值1, 值2, 值3, ...);\n插入指定列\nINSERT INTO 表名 (列1, 列2, 列3, ...) VALUES (值1, 值2, 值3, ...);\n插入多行数据\nINSERT INTO 表名 (列1, 列2) VALUES(值1a, 值2a),(值1b, 值2b),(值1c, 值2c);\n从查询结果插入\nINSERT INTO 目标表 (列1, 列2)SELECT 源列1, 源列2 FROM 源表 WHERE 条件;\n二、更新数据 (UPDATE)\n更新所有行\nUPDATE 表名 SET 列名 = 新值;\n更新满足条件的行\nUPDATE 表名SET 列1 = 新值1, 列2 = 新值2, ...WHERE 条件;\n基于表达式更新\nUPDATE 表名SET 列名 = 表达式WHERE 条件;\n基于子查询更新\nUPDATE 表名SET 列名 = (SELECT 子查询)WHERE 条件;\n三、删除数据 (DELETE)\n删除所有行\nDELETE FROM 表名;\n删除满足条件的行\nDELETE FROM 表名 WHERE 条件;\n基于子查询删除\nDELETE FROM 表名WHERE 列名 IN (SELECT 子查询);DELETE FROM 表名WHERE EXISTS (SELECT 子查询);\n清空表（DDL操作，但功能类似）\nTRUNCATE TABLE 表名;\n四、合并数据 (MERGE/UPSERT)\n标准合并语法\nMERGE INTO 目标表 USING 源表ON (匹配条件)WHEN MATCHED THEN    UPDATE SET 列 = 值WHEN NOT MATCHED THEN    INSERT (列列表) VALUES (值列表);\n插入或更新 (部分数据库特有)\n-- MySQLINSERT INTO 表名 (列1, 列2) VALUES (值1, 值2)ON DUPLICATE KEY UPDATE 列1 = 新值1, 列2 = 新值2;-- PostgreSQLINSERT INTO 表名 (列1, 列2) VALUES (值1, 值2)ON CONFLICT (约束列) DO UPDATE SET 列1 = 新值1;\n DQL（查询数据）\n一、基础查询结构\nSELECT语句完整结构SELECT [DISTINCT] 列表达式FROM 表名[WHERE 条件][GROUP BY 分组列][HAVING 分组条件][ORDER BY 排序列 [ASC|DESC]][LIMIT/OFFSET 分页];\n​\n二、SELECT子句\n选择列-- 选择所有列SELECT *-- 选择特定列SELECT 列1, 列2, 列3-- 使用表达式SELECT 列1, 列2 + 列3, 函数名(列)-- 使用常量值SELECT 列, &#x27;固定值&#x27; AS 常量列-- 使用列别名SELECT 列 AS 别名SELECT 列 别名​去重SELECT DISTINCT 列\n​\n三、WHERE子句（条件过滤）\n比较运算符=     -- 等于&lt;&gt; != -- 不等于&lt; &lt;=  -- 小于/小于等于&gt; &gt;=  -- 大于/大于等于​逻辑运算符AND   -- 与OR    -- 或NOT   -- 非​特殊运算符BETWEEN 值1 AND 值2      -- 在范围内IN (值1, 值2, ...)       -- 在列表中NOT IN (值1, 值2, ...)   -- 不在列表中LIKE &#x27;模式&#x27;             -- 模式匹配  % -- 匹配任意字符  _ -- 匹配单个字符IS NULL                -- 是空值IS NOT NULL            -- 非空值\n​\n四、聚合函数\nCOUNT(*)                -- 统计行数COUNT(列)               -- 统计非空值COUNT(DISTINCT 列)      -- 统计去重值SUM(列)                 -- 求和AVG(列)                 -- 平均值MAX(列)                 -- 最大值MIN(列)                 -- 最小值​五、GROUP BY与HAVING分组语法GROUP BY 列1, 列2, ...HAVING 聚合函数条件\n​\n六、JOIN连接查询\n连接类型INNER JOIN 表 ON 条件      -- 内连接LEFT JOIN 表 ON 条件       -- 左外连接RIGHT JOIN 表 ON 条件      -- 右外连接FULL OUTER JOIN 表 ON 条件 -- 全外连接CROSS JOIN 表             -- 交叉连接​连接方式-- 等值连接JOIN 表 ON A.列 = B.列-- 非等值连接JOIN 表 ON A.列 BETWEEN B.最小值 AND B.最大值-- 自连接表 AS 别名1 JOIN 表 AS 别名2 ON 条件\n​\n七、子查询\n子查询位置-- 在WHERE中WHERE 列 操作符 (SELECT ...)-- 在FROM中FROM (SELECT ...) AS 别名-- 在SELECT中SELECT 列, (SELECT ...) AS 计算列-- 在HAVING中HAVING 聚合函数 操作符 (SELECT ...)​子查询运算符IN / NOT INEXISTS / NOT EXISTS比较运算符 (=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;)ALL / ANY / SOME\n​\n八、集合操作\n查询1 UNION 查询2        -- 并集（去重）查询1 UNION ALL 查询2    -- 并集（不去重）查询1 INTERSECT 查询2    -- 交集查询1 EXCEPT 查询2       -- 差集查询1 MINUS 查询2        -- 差集（某些数据库）\n​\n九、常用函数\n字符串函数CONCAT(串1, 串2)        -- 连接UPPER(串) / LOWER(串)    -- 大小写转换LENGTH(串)              -- 长度SUBSTRING(串, 开始, 长度) -- 子串TRIM(串)                -- 去空格REPLACE(串, 旧, 新)      -- 替换​数值函数ROUND(数值, 小数位)      -- 四舍五入CEIL(数值) / FLOOR(数值)  -- 上下取整ABS(数值)                -- 绝对值MOD(被除数, 除数)        -- 取模​日期函数CURRENT_DATE            -- 当前日期CURRENT_TIME            -- 当前时间CURRENT_TIMESTAMP       -- 当前时间戳EXTRACT(部分 FROM 日期)  -- 提取部分DATE_ADD(日期, INTERVAL) -- 日期加减DATEDIFF(日期1, 日期2)   -- 日期差​条件函数CASE    WHEN 条件1 THEN 结果1    WHEN 条件2 THEN 结果2    ELSE 默认结果ENDCOALESCE(值1, 值2, ...)   -- 返回第一个非NULL值NULLIF(值1, 值2)          -- 两值相等返回NULLIF(条件, 真值, 假值)       -- 简单条件判断\n​\n十、排序与分页\n排序ORDER BY 列1 [ASC|DESC], 列2 [ASC|DESC]​分页（语法因数据库而异）-- MySQL/PostgreSQLLIMIT 行数 OFFSET 跳过行数LIMIT 跳过行数, 行数-- SQL Server/Oracle 12c+OFFSET 跳过行数 ROWS FETCH NEXT 行数 ROWS ONLY\n DCL（控制权限）\n一、用户管理\n创建用户\nCREATE USER 用户名 IDENTIFIED BY &#x27;密码&#x27;;CREATE USER 用户名@主机 IDENTIFIED BY &#x27;密码&#x27;;\n修改用户\nALTER USER 用户名 IDENTIFIED BY &#x27;新密码&#x27;;ALTER USER 用户名 ACCOUNT LOCK/UNLOCK;ALTER USER 用户名 PASSWORD EXPIRE;RENAME USER 旧用户名 TO 新用户名;\n删除用户\nDROP USER 用户名;DROP USER 用户名@主机;\n二、权限管理\n权限类型概览\n-- 数据权限SELECT     -- 查询INSERT     -- 插入UPDATE     -- 更新DELETE     -- 删除REFERENCES -- 外键引用-- 结构权限CREATE     -- 创建对象ALTER      -- 修改结构DROP       -- 删除对象INDEX      -- 索引操作-- 系统权限CREATE USER     -- 创建用户GRANT OPTION    -- 授权权限SHUTDOWN        -- 关闭数据库SUPER           -- 超级权限\n授予权限\n-- 授予特定权限GRANT 权限列表 ON 对象 TO 用户;-- 授予所有权限GRANT ALL PRIVILEGES ON 对象 TO 用户;-- 授予带授权权限GRANT 权限 ON 对象 TO 用户 WITH GRANT OPTION;\n权限列表格式\n-- 单个权限GRANT SELECT ON 表名 TO 用户名;-- 多个权限GRANT SELECT, INSERT, UPDATE ON 表名 TO 用户名;-- 所有表权限GRANT ALL ON 数据库名.* TO 用户名;-- 特定列权限GRANT SELECT(列1, 列2), UPDATE(列1) ON 表名 TO 用户名;\n撤销权限\n-- 撤销特定权限REVOKE 权限列表 ON 对象 FROM 用户;-- 撤销所有权限REVOKE ALL PRIVILEGES ON 对象 FROM 用户;-- 撤销授权权限REVOKE GRANT OPTION ON 对象 FROM 用户;\n三、对象作用域\n权限作用域级别\n-- 全局级别GRANT 权限 ON *.* TO 用户;-- 数据库级别GRANT 权限 ON 数据库名.* TO 用户;-- 表级别GRANT 权限 ON 数据库名.表名 TO 用户;-- 列级别GRANT 权限(列名) ON 表名 TO 用户;-- 存储过程级别GRANT EXECUTE ON PROCEDURE 过程名 TO 用户;\n四、角色管理\n创建与管理角色\nCREATE ROLE 角色名;DROP ROLE 角色名;GRANT 角色 TO 用户;REVOKE 角色 FROM 用户;SET ROLE 角色名;\n角色权限分配\nGRANT 权限 ON 对象 TO 角色;REVOKE 权限 ON 对象 FROM 角色;\n五、权限查看\n查询权限信息\n-- 查看用户权限SHOW GRANTS FOR 用户名;-- 查看当前用户权限SHOW GRANTS;-- 查看角色权限SHOW GRANTS FOR 角色名;-- 系统表查询（具体表名因数据库而异）SELECT * FROM 权限相关系统表;\n六、其他控制语句\n密码策略\nALTER USER 用户名 PASSWORD EXPIRE;           -- 密码过期ALTER USER 用户名 PASSWORD EXPIRE NEVER;     -- 永不过期ALTER USER 用户名 PASSWORD EXPIRE INTERVAL N DAY; -- N天后过期\n账户锁定\nALTER USER 用户名 ACCOUNT LOCK;    -- 锁定账户ALTER USER 用户名 ACCOUNT UNLOCK;  -- 解锁账户\n连接限制\nCREATE USER 用户名 WITH MAX_CONNECTIONS_PER_HOUR N;ALTER USER 用户名 WITH MAX_USER_CONNECTIONS N;\n\n​\n TCL（管理事务）\n一、事务基本控制\n开启事务\n-- 标准语法BEGIN TRANSACTION;-- 或START TRANSACTION;-- 简写BEGIN;-- 设置隔离级别开启（部分数据库）SET TRANSACTION ISOLATION LEVEL 级别;\n提交事务\nCOMMIT;COMMIT WORK;\n回滚事务\nROLLBACK;ROLLBACK WORK;-- 回滚到指定保存点ROLLBACK TO 保存点名;ROLLBACK TO SAVEPOINT 保存点名;\n二、保存点控制\n创建保存点\nSAVEPOINT 保存点名;\n删除保存点\nRELEASE SAVEPOINT 保存点名;\n三、事务特性设置\n设置事务特性\nSET TRANSACTION[ISOLATION LEVEL 级别][READ ONLY | READ WRITE][DIAGNOSTICS SIZE 大小];\n隔离级别设置\nSET TRANSACTION ISOLATION LEVEL    READ UNCOMMITTED |    READ COMMITTED |    REPEATABLE READ |    SERIALIZABLE;-- 会话级别设置SET SESSION TRANSACTION ISOLATION LEVEL 级别;SET GLOBAL TRANSACTION ISOLATION LEVEL 级别;\n访问模式设置\nSET TRANSACTION READ ONLY;   -- 只读事务SET TRANSACTION READ WRITE;  -- 读写事务\n四、事务状态控制\n设置约束检查\nSET CONSTRAINTS ALL DEFERRED;   -- 延迟检查SET CONSTRAINTS ALL IMMEDIATE;  -- 立即检查SET CONSTRAINTS 约束名 DEFERRED;\n设置事务超时\n-- PostgreSQL示例START TRANSACTION;SET LOCAL lock_timeout = &#x27;2s&#x27;;-- 其他数据库类似语法SET LOCK_TIMEOUT 毫秒数;\n五、两阶段提交（分布式事务）\n准备阶段\nPREPARE TRANSACTION &#x27;事务ID&#x27;;\n提交/回滚预备事务\nCOMMIT PREPARED &#x27;事务ID&#x27;;ROLLBACK PREPARED &#x27;事务ID&#x27;;\n六、事务控制函数\n事务信息查询\n-- 获取当前事务IDSELECT txid_current();-- 检查是否在事务中SELECT in_transaction();-- 获取事务时间戳SELECT transaction_timestamp();SELECT now();  -- 事务开始时间SELECT clock_timestamp();  -- 实时时间\n七、锁控制（相关TCL操作）\n显式加锁\nSELECT ... FOR UPDATE;       -- 排他锁SELECT ... FOR SHARE;        -- 共享锁SELECT ... FOR NO KEY UPDATE;SELECT ... FOR KEY SHARE;-- 表级锁LOCK TABLE 表名 IN 锁模式;\n锁模式类型\nACCESS SHARE         -- 最低级别锁ROW SHARE            -- 行共享锁ROW EXCLUSIVE        -- 行排他锁SHARE UPDATE EXCLUSIVESHARE                -- 共享锁SHARE ROW EXCLUSIVEEXCLUSIVE            -- 排他锁ACCESS EXCLUSIVE     -- 最高级别锁\n\n MySQL\n MySQL\n 一、MySQL 特有数据类型\n\n数值类型扩展\n\n-- 整数类型（有符号/无符号）TINYINT      -- 1字节 (-128~127 或 0~255)SMALLINT     -- 2字节MEDIUMINT    -- 3字节INT/INTEGER  -- 4字节BIGINT       -- 8字节-- 使用UNSIGNED（MySQL特有）CREATE TABLE t (    id INT UNSIGNED AUTO_INCREMENT,    age TINYINT UNSIGNED);\n\n字符串类型扩展\n\n-- TEXT类型细分（MySQL特有）TINYTEXT    -- 最多255字节TEXT        -- 最多65,535字节MEDIUMTEXT  -- 最多16,777,215字节LONGTEXT    -- 最多4GB-- ENUM和SET类型（MySQL特有）CREATE TABLE users (    gender ENUM(&#x27;男&#x27;, &#x27;女&#x27;, &#x27;其他&#x27;),  -- 单选    hobbies SET(&#x27;读书&#x27;, &#x27;运动&#x27;, &#x27;音乐&#x27;, &#x27;游戏&#x27;)  -- 多选);\n\n时间类型扩展\n\nYEAR        -- 年份（1901-2155）-- MySQL特有，1字节存储\n二、MySQL 特有语法\n\nAUTO_INCREMENT（自增）\n\n-- 标准语法CREATE TABLE users (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(50));-- MySQL设置自增起始值ALTER TABLE users AUTO_INCREMENT = 1000;-- 查看下一个自增值SHOW TABLE STATUS LIKE &#x27;users&#x27;;\n\nENGINE 存储引擎\n\n-- 指定存储引擎（MySQL特有）CREATE TABLE t1 (    id INT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-- 常用引擎ENGINE=InnoDB    -- 默认，支持事务ENGINE=MyISAM    -- 旧版默认，全文索引ENGINE=MEMORY    -- 内存表ENGINE=ARCHIVE   -- 归档存储\n\n字符集与校对规则\n\n-- 设置字符集（MySQL详细控制）CREATE DATABASE dbDEFAULT CHARACTER SET utf8mb4COLLATE utf8mb4_unicode_ci;-- 表级别设置CREATE TABLE t (    name VARCHAR(50)) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;-- 列级别设置CREATE TABLE t (    name VARCHAR(50) CHARACTER SET utf8 COLLATE utf8_bin);\n 三、MySQL 查询扩展\n\nLIMIT 分页（MySQL简化语法）\n\n-- 标准SQL分页SELECT * FROM users LIMIT 10 OFFSET 20;-- MySQL特有简化写法SELECT * FROM users LIMIT 20, 10;  -- 跳过20行，取10行\n\n正则表达式\n\n-- REGEXP运算符（MySQL扩展）SELECT * FROM users WHERE username REGEXP &#x27;^[A-Z]&#x27;;  -- 以大写开头SELECT * FROM users WHERE email REGEXP &#x27;@gmail\\\\.com$&#x27;;  -- gmail结尾-- 不区分大小写SELECT * FROM users WHERE username REGEXP BINARY &#x27;^[a-z]&#x27;;  -- 区分大小写\n\n全文检索（MyISAM/InnoDB）\n\n-- 创建全文索引CREATE TABLE articles (    id INT,    title VARCHAR(200),    content TEXT,    FULLTEXT(title, content)  -- 全文索引) ENGINE=InnoDB;-- 使用MATCH...AGAINST搜索SELECT * FROM articlesWHERE MATCH(title, content) AGAINST(&#x27;数据库 教程&#x27; IN NATURAL LANGUAGE MODE);-- 布尔模式搜索SELECT * FROM articlesWHERE MATCH(title, content) AGAINST(&#x27;+MySQL -Oracle&#x27; IN BOOLEAN MODE);\n 四、MySQL 函数扩展\n\n字符串函数\n\n-- MySQL特有字符串函数SELECT CONCAT_WS(&#x27;-&#x27;, &#x27;2024&#x27;, &#x27;01&#x27;, &#x27;15&#x27;);  -- 2024-01-15SELECT GROUP_CONCAT(username SEPARATOR &#x27;, &#x27;) FROM users;  -- 合并为一行SELECT IFNULL(email, &#x27;无邮箱&#x27;) FROM users;  -- 空值替换\n\n流程控制函数\n\n-- IF函数（三元运算）SELECT username, IF(age&gt;=18, &#x27;成年&#x27;, &#x27;未成年&#x27;) AS 状态 FROM users;-- 日期格式化SELECT DATE_FORMAT(NOW(), &#x27;%Y年%m月%d日 %H:%i:%s&#x27;);  -- 2024年01月15日 14:30:25SELECT DATE_FORMAT(birthday, &#x27;%W, %M %e, %Y&#x27;) FROM users;\n\n窗口函数（MySQL 8.0+）\n\n-- ROW_NUMBER() 行号SELECT    username,    age,    ROW_NUMBER() OVER (ORDER BY age DESC) AS 排名FROM users;-- RANK() 和 DENSE_RANK()SELECT    username,    age,    RANK() OVER (ORDER BY age DESC) AS rank_num,    DENSE_RANK() OVER (ORDER BY age DESC) AS dense_rank_numFROM users;\n五、MySQL 系统管理与维护\n\n系统变量操作\n\n-- 查看系统变量SHOW VARIABLES LIKE &#x27;%timeout%&#x27;;SELECT @@global.wait_timeout;SELECT @@session.sql_mode;-- 设置变量（会话级）SET SESSION sql_mode = &#x27;STRICT_TRANS_TABLES&#x27;;SET @@session.wait_timeout = 600;-- 设置变量（全局级，需要权限）SET GLOBAL max_connections = 500;\n\n用户与权限管理\n\n-- 创建用户（MySQL语法）CREATE USER &#x27;user1&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password123&#x27;;CREATE USER &#x27;user2&#x27;@&#x27;192.168.1.%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;-- 授权（详细控制）GRANT SELECT, INSERT ON learn_sql.* TO &#x27;user1&#x27;@&#x27;localhost&#x27;;GRANT ALL PRIVILEGES ON db1.* TO &#x27;user2&#x27;@&#x27;%&#x27; WITH GRANT OPTION;-- 查看权限SHOW GRANTS FOR &#x27;user1&#x27;@&#x27;localhost&#x27;;\n\n备份与恢复\n\n-- mysqldump命令（命令行工具）# 备份整个数据库mysqldump -u root -p learn_sql &gt; backup.sql# 备份特定表mysqldump -u root -p learn_sql users orders &gt; tables.sql# 只备份结构mysqldump -u root -p --no-data learn_sql &gt; structure.sql\n 六、MySQL 性能与优化\n\n执行计划分析\n\n-- EXPLAIN输出详细（MySQL特有信息）EXPLAIN FORMAT=JSON SELECT * FROM users WHERE age &gt; 20;-- 查看索引使用情况EXPLAIN SELECT * FROM users USE INDEX(age_index) WHERE age &gt; 20;\n\n索引提示\n\n-- 强制使用索引SELECT * FROM users FORCE INDEX (idx_age) WHERE age &gt; 20;-- 忽略索引SELECT * FROM users IGNORE INDEX (idx_age) WHERE age &gt; 20;-- 建议使用索引SELECT * FROM users USE INDEX (idx_age) WHERE age &gt; 20;\n\n查询缓存（MySQL 8.0已移除）\n\n-- MySQL 5.7及之前版本SHOW VARIABLES LIKE &#x27;query_cache%&#x27;;SET GLOBAL query_cache_size = 67108864;\n 七、MySQL 事务与锁\n\n事务隔离级别\n\n-- 查看当前隔离级别SELECT @@transaction_isolation;  -- MySQL 8.0+SELECT @@tx_isolation;           -- MySQL 5.7-- 设置隔离级别SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n\n表锁定（MyISAM）\n\n-- 手动锁定表LOCK TABLES users READ, orders WRITE;-- 执行操作...UNLOCK TABLES;\n\n行锁查看（InnoDB）\n\n-- 查看当前锁信息SHOW ENGINE INNODB STATUS\\\\G-- 查看锁等待SELECT * FROM information_schema.INNODB_LOCKS;SELECT * FROM information_schema.INNODB_LOCK_WAITS;\n 八、MySQL 安全注意事项\n\nSQL Mode 严格模式\n\n-- 推荐设置（防止无效数据）SET sql_mode = &#x27;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION&#x27;;-- 查看当前模式SELECT @@sql_mode;\n\n密码策略\n\n-- 密码验证插件INSTALL PLUGIN validate_password SONAME &#x27;validate_password.so&#x27;;-- 查看密码策略SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;\n\n安全连接\n\n-- SSL连接mysql --ssl-mode=REQUIRED -u root -p-- 查看SSL状态SHOW STATUS LIKE &#x27;Ssl_cipher&#x27;;\n 九、MySQL 实用技巧\n\n批量插入优化\n\n-- 多条VALUES（性能优化）INSERT INTO users (username, age) VALUES(&#x27;a&#x27;, 20), (&#x27;b&#x27;, 21), (&#x27;c&#x27;, 22), ...;-- ON DUPLICATE KEY UPDATEINSERT INTO users (id, username) VALUES (1, &#x27;Lnk&#x27;)ON DUPLICATE KEY UPDATE username = VALUES(username);\n\n生成测试数据\n\n-- 使用序列生成INSERT INTO users (username, age)SELECT    CONCAT(&#x27;user&#x27;, n) AS username,    FLOOR(RAND() * 50) + 18 AS ageFROM (    SELECT @row := @row + 1 AS n    FROM (SELECT 0 UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) t1,         (SELECT 0 UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) t2,         (SELECT @row := 0) r) numbersLIMIT 100;\n\n常用元数据查询\n\n-- 查看所有数据库大小SELECT    table_schema AS &#x27;数据库&#x27;,    ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS &#x27;大小(MB)&#x27;FROM information_schema.tablesGROUP BY table_schema;-- 查看表状态SHOW TABLE STATUS FROM learn_sql LIKE &#x27;users&#x27;;\n\n 必须记住的SHOW命令\nSHOW DATABASES;                    -- 所有数据库SHOW TABLES;                       -- 当前数据库所有表SHOW CREATE TABLE table_name;      -- 查看建表语句SHOW INDEX FROM table_name;        -- 查看索引SHOW PROCESSLIST;                  -- 查看连接进程SHOW VARIABLES LIKE &#x27;%pattern%&#x27;;   -- 查看系统变量SHOW STATUS LIKE &#x27;%pattern%&#x27;;      -- 查看系统状态\n\n Neo4j\n 一、Neo4j基础概念\n图数据库三要素\n1. 节点 (Node)       = 实体   - 标签 (Label)    : 类别，如 :User, :Computer   - 属性 (Property) : 特征，如 &#123;name: &quot;Alice&quot;, age: 25&#125;2. 关系 (Relationship) = 连接   - 类型 (Type)     : 关系类型，如 :FOLLOWS, :OWNS   - 方向 (Direction): → 或 ←   - 属性 (Property) : 关系的特征3. 路径 (Path)       = 节点和关系的序列\n与SQL概念对比\nSQL           →     Neo4j----------------------------数据库(Database) →  图数据库(Graph Database)表(Table)      →  标签(Label)行(Row)        →  节点(Node)列(Column)     →  属性(Property)外键(Foreign Key) → 关系(Relationship)JOIN查询        →  模式匹配(Pattern Matching)\n 二、Cypher查询语言结构\nCypher语法模式\n(节点) - [关系] -&gt; (节点)\n基础结构\n-- 完整Cypher语句结构[MATCH WHERE]           -- 查找数据（可选）[OPTIONAL MATCH WHERE]  -- 可选查找[WITH ORDER BY SKIP LIMIT] -- 中间处理CREATE/MERGE            -- 创建数据SET/REMOVE/DELETE       -- 修改数据RETURN [ORDER BY SKIP LIMIT] -- 返回结果\n 三、数据操作（CRUD）\n\nCREATE - 创建数据\n\n创建节点\n-- 创建带标签和属性的节点CREATE (:Person &#123;name: &quot;Alice&quot;, age: 30&#125;)-- 创建多个节点CREATE (:Person &#123;name: &quot;Bob&quot;&#125;), (:Person &#123;name: &quot;Charlie&quot;&#125;)-- 创建带多个标签的节点CREATE (:User:Admin &#123;name: &quot;Admin&quot;, level: 5&#125;)\n创建关系\n-- 为现有节点创建关系MATCH (a:Person &#123;name: &quot;Alice&quot;&#125;), (b:Person &#123;name: &quot;Bob&quot;&#125;)CREATE (a)-[:FRIENDS_WITH &#123;since: 2020&#125;]-&gt;(b)-- 同时创建节点和关系CREATE (a:Person &#123;name: &quot;Alice&quot;&#125;)-[:KNOWS]-&gt;(b:Person &#123;name: &quot;Bob&quot;&#125;)\n\nMATCH - 查询数据\n\n基础查询\n-- 查询所有节点MATCH (n) RETURN n-- 查询特定标签的节点MATCH (p:Person) RETURN p-- 查询带属性的节点MATCH (p:Person &#123;name: &quot;Alice&quot;&#125;) RETURN p\n关系查询\n-- 查询关系MATCH (:Person &#123;name: &quot;Alice&quot;&#125;)-[r]-&gt;(friend) RETURN friend-- 查询特定类型的关系MATCH (:Person)-[:FRIENDS_WITH]-&gt;(friend) RETURN friend-- 查询双向关系MATCH (a:Person)-[:FRIENDS_WITH]-(b:Person) RETURN a, b\n\nWHERE - 条件过滤\n\n-- 基础条件MATCH (p:Person) WHERE p.age &gt; 25 RETURN p-- 字符串匹配MATCH (p:Person) WHERE p.name STARTS WITH &#x27;A&#x27; RETURN pMATCH (p:Person) WHERE p.name CONTAINS &#x27;lic&#x27; RETURN pMATCH (p:Person) WHERE p.name ENDS WITH &#x27;e&#x27; RETURN p-- 正则表达式MATCH (p:Person) WHERE p.name =~ &#x27;.*Ali.*&#x27; RETURN p-- 多条件MATCH (p:Person) WHERE p.age &gt; 20 AND p.name CONTAINS &#x27;A&#x27; RETURN p\n\nSET/REMOVE - 更新数据\n\n-- 更新属性MATCH (p:Person &#123;name: &quot;Alice&quot;&#125;)SET p.age = 31, p.city = &quot;Beijing&quot;RETURN p-- 添加标签MATCH (p:Person &#123;name: &quot;Alice&quot;&#125;)SET p:AdminRETURN p-- 移除属性MATCH (p:Person &#123;name: &quot;Alice&quot;&#125;)REMOVE p.cityRETURN p-- 移除标签MATCH (p:Person:Admin &#123;name: &quot;Alice&quot;&#125;)REMOVE p:AdminRETURN p\n\nDELETE - 删除数据\n\n-- 删除节点（必须先删除关系）MATCH (p:Person &#123;name: &quot;Bob&quot;&#125;)DETACH DELETE p-- 删除关系MATCH (a:Person &#123;name: &quot;Alice&quot;&#125;)-[r:FRIENDS_WITH]-&gt;(b:Person &#123;name: &quot;Bob&quot;&#125;)DELETE r\n\nMERGE - 创建或匹配\n\n-- 存在则匹配，不存在则创建MERGE (p:Person &#123;name: &quot;Alice&quot;&#125;)ON CREATE SET p.created = timestamp()ON MATCH SET p.lastSeen = timestamp()RETURN p-- 合并关系MATCH (a:Person &#123;name: &quot;Alice&quot;&#125;), (b:Person &#123;name: &quot;Bob&quot;&#125;)MERGE (a)-[:FRIENDS_WITH]-&gt;(b)\n 四、高级查询\n\n路径查询\n\n-- 可变长度路径MATCH (a:Person &#123;name: &quot;Alice&quot;&#125;)-[:FRIENDS_WITH*1..3]-&gt;(friend)RETURN friend-- 最短路径MATCH path = shortestPath(  (a:Person &#123;name: &quot;Alice&quot;&#125;)  -[:FRIENDS_WITH*1..10]-&gt;  (b:Person &#123;name: &quot;David&quot;&#125;))RETURN path, length(path) as distance-- 所有路径MATCH path = (a:Person &#123;name: &quot;Alice&quot;&#125;)-[:FRIENDS_WITH*]-&gt;(b:Person &#123;name: &quot;David&quot;&#125;)RETURN path\n\n聚合函数\n\n-- 计数MATCH (p:Person) RETURN count(p) as total_persons-- 分组统计MATCH (p:Person) RETURN p.city, count(p) as residents-- 集合操作MATCH (p:Person) RETURN collect(p.name) as all_namesMATCH (p:Person) RETURN collect(DISTINCT p.city) as cities\n\n排序和分页\n\n-- 排序MATCH (p:Person) RETURN p ORDER BY p.age DESC-- 分页MATCH (p:Person) RETURN p SKIP 10 LIMIT 5-- 组合MATCH (p:Person)RETURN p.name, p.ageORDER BY p.age DESCSKIP 0 LIMIT 10\n\nWITH子句（中间处理）\n\n-- 管道式处理MATCH (p:Person)WITH p ORDER BY p.age DESC LIMIT 5RETURN collect(p.name) as oldest_five-- 聚合后过滤MATCH (p:Person)WITH p.city as city, count(p) as populationWHERE population &gt; 100RETURN city, population\n 五、索引和约束\n创建索引\n-- 创建单属性索引CREATE INDEX FOR (p:Person) ON (p.name)-- 创建复合索引CREATE INDEX FOR (p:Person) ON (p.name, p.age)-- 全文索引CREATE FULLTEXT INDEX personAndPlace FOR (p:Person|Place) ON EACH [p.name, p.description]\n创建约束\n-- 唯一性约束CREATE CONSTRAINT FOR (p:Person) REQUIRE p.email IS UNIQUE-- 存在性约束（企业版）CREATE CONSTRAINT FOR (p:Person) REQUIRE p.name IS NOT NULL-- 节点键约束CREATE CONSTRAINT FOR (p:Person) REQUIRE (p.firstname, p.lastname) IS NODE KEY\n查看和删除\n-- 查看索引和约束SHOW INDEXESSHOW CONSTRAINTS-- 删除索引DROP INDEX index_name-- 删除约束DROP CONSTRAINT constraint_name\n 六、函数和操作符\n字符串函数\nRETURN toString(123)                    -- &quot;123&quot;RETURN toUpper(&quot;hello&quot;)                 -- &quot;HELLO&quot;RETURN toLower(&quot;HELLO&quot;)                 -- &quot;hello&quot;RETURN substring(&quot;hello&quot;, 1, 3)         -- &quot;ell&quot;RETURN split(&quot;a,b,c&quot;, &quot;,&quot;)              -- [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]RETURN replace(&quot;hello&quot;, &quot;l&quot;, &quot;w&quot;)       -- &quot;hewwo&quot;\n数值函数\nRETURN round(3.1415)                    -- 3RETURN ceil(3.14)                       -- 4RETURN floor(3.9)                       -- 3RETURN abs(-5)                          -- 5RETURN rand()                           -- 随机数 0-1\n时间函数\nRETURN datetime()                       -- 当前时间RETURN date()                           -- 当前日期RETURN timestamp()                      -- 时间戳（毫秒）RETURN duration(&quot;P1Y2M10DT12H45M30S&quot;)   -- 持续时间\n列表函数\nRETURN size([1,2,3])                    -- 3RETURN head([1,2,3])                    -- 1RETURN last([1,2,3])                    -- 3RETURN tail([1,2,3])                    -- [2,3]RETURN reverse([1,2,3])                 -- [3,2,1]\n关系函数\nMATCH (a)-[r]-(b)RETURN type(r)                          -- 关系类型RETURN startNode(r)                     -- 起始节点RETURN endNode(r)                       -- 结束节点RETURN id(r)                            -- 关系ID\n 七、管理命令\n数据库管理\n-- 查看数据库SHOW DATABASES-- 切换数据库（Neo4j 4.0+）:USE database_name-- 创建数据库（企业版）CREATE DATABASE database_name-- 删除数据库（企业版）DROP DATABASE database_name\n用户和权限\n-- 创建用户（企业版）CREATE USER username SET PASSWORD &#x27;password&#x27;-- 修改密码ALTER USER username SET PASSWORD &#x27;new_password&#x27;-- 授予角色GRANT ROLE reader, publisher TO username-- 查看用户SHOW USERS\n导入导出\n-- 导入CSVLOAD CSV WITH HEADERS FROM &#x27;file:///data.csv&#x27; AS rowCREATE (:Person &#123;name: row.name, age: toInteger(row.age)&#125;)-- 导出数据（通过APOC插件）CALL apoc.export.cypher.all(&#x27;export.cypher&#x27;, &#123;&#125;)-- 备份（企业版）BACKUP DATABASE neo4j TO &#x27;/backup/location&#x27;\n 八、Bloodhound专用查询模式\nAD域关系查询\n-- 查找域管理员MATCH (g:Group &#123;name: &quot;DOMAIN ADMINS@DOMAIN.LOCAL&quot;&#125;)RETURN g-- 查找用户到域管理员的路径MATCH p = shortestPath(  (n:User)  -[*1..]  -&gt; (m:Group &#123;name: &quot;DOMAIN ADMINS@DOMAIN.LOCAL&quot;&#125;))RETURN p LIMIT 5-- 查找有Session的计算机MATCH (c:Computer)-[:HasSession]-&gt;(u:User)RETURN c.name, u.name-- Kerberoastable用户MATCH (u:User &#123;hasspn: true&#125;)WHERE NOT u.ownedRETURN u.name, u.serviceprincipalnames\n攻击路径分析\n-- 最短特权提升路径MATCH p = shortestPath(  (start:User &#123;owned: true&#125;)  -[*1..10]-&gt;  (target:Group &#123;highvalue: true&#125;))RETURN p, length(p) as distanceORDER BY distance ASC-- 权限传递链MATCH (g1:Group)-[:MemberOf*1..5]-&gt;(g2:Group)RETURN g1.name, g2.name\n 九、Neo4j与MySQL语法对比速查\nCRUD操作对比\n操作      MySQL                    Neo4j (Cypher)-----------------------------------------------------------创建      INSERT INTO              CREATE (:Label &#123;prop: value&#125;)查询      SELECT * FROM            MATCH (n:Label) RETURN n更新      UPDATE SET               MATCH (n) SET n.prop = value删除      DELETE FROM              MATCH (n) DETACH DELETE n条件      WHERE                    WHERE连接      JOIN ON                  MATCH (a)-[r]-(b)分页      LIMIT offset, count      SKIP offset LIMIT count排序      ORDER BY                 ORDER BY\n核心差异提醒\n1. Neo4j没有&quot;表&quot;，只有&quot;标签&quot;2. 关系是一等公民，不是外键3. JOIN通过模式匹配自动完成4. 数据模型更灵活，没有固定模式5. 擅长深度关联查询，不适合大批量简单查询","categories":["-DB-notes"]},{"title":"linux指令&shell脚本","url":"/2026/02/26/linux%E6%8C%87%E4%BB%A4-shell%E8%84%9A%E6%9C%AC/","content":" 文件操作\n 一、文件查看类\n\ncat : 显示文件内容\n\ncat filename           # 显示文件内容cat file1 file2        # 显示多个文件cat &gt; newfile          # 创建新文件（输入内容，Ctrl+D 结束）cat data.txt | less    # 分页查看大文件\n\nfile : 检测文件类型\n\nfile filename          # 检查单个文件类型file ./*               # 检查当前目录所有文件类型file -b filename       # 简洁输出（只显示类型）file -L filename       # 跟随符号链接\n\nstrings : 提取二进制文件中的可打印字符串\n\nstrings filename       # 提取所有≥4个可打印字符的字符串strings -n 10 filename # 提取≥10个字符的字符串strings data.bin | grep &quot;password&quot;  # 在二进制中搜索文本\n4.head ：显示文件开头部分\nhead filename                 # 显示前10行head -n 20 filename           # 显示前20行head -c 100 filename          # 显示前100字节head -v filename              # 显示文件名标题\n\ntail : 显示文件结尾部分\n\ntail filename                 # 显示最后10行tail -n 20 filename           # 显示最后20行tail -f filename              # 实时追踪文件变化tail -F filename              # 实时追踪（文件重命名后仍追踪）\n\nless : 分页查看文件\n\nless filename                 # 分页查看# 操作键: 空格翻页, b上一页, /搜索, n下一个匹配, q退出less -N filename              # 显示行号less -S filename              # 不换行显示\n\nmore : 分页查看文件\n\nmore filename                 # 分页查看# 操作键: 空格翻页, Enter下一行, q退出more -d filename              # 显示提示信息more +10 filename             # 从第10行开始显示\n8、diff ：比较文件差异\ndiff file1 file2               # 比较两个文件diff -u file1 file2           # 输出统一格式（便于打补丁）diff -r dir1 dir2             # 递归比较目录diff -N file1 file2           # 将不存在的文件视为空文件比较\n\n 二、文件操作类\n\nfind : 查找文件\n\nfind . -name &quot;*.txt&quot;          # 按文件名查找find . -type f -size +100k    # 查找大于100KB的文件find . -perm 644              # 按权限查找find . -mtime -7              # 查找7天内修改的文件find . -exec file &#123;&#125; \\\\;       # 对每个找到的文件执行命令\n\nmkdir : 创建目录\n\nmkdir dirname           # 创建目录mkdir -p a/b/c          # 递归创建多层目录（父目录不存在则创建）mkdir -m 755 dirname    # 创建目录并设置权限mktemp -d               # 创建唯一临时目录（Bandit推荐）\n\ncp : 复制文件/目录\n\ncp source dest          # 复制文件cp -r sourcedir dest    # 递归复制目录cp ~/file.txt .         # 复制到家目录文件到当前目录cp -p file dest         # 保留权限、时间戳等属性cp -u source dest       # 仅当源文件更新时才复制\n\nmv : 移动/重命名\n\nmv oldname newname      # 重命名文件mv file dir/            # 移动到目录mv *.txt backup/        # 移动多个文件mv -i file dest         # 交互式（覆盖前询问）mv -n file dest         # 不覆盖已存在文件\n\nrmdir : 删除空目录\n\nrmdir dirname                 # 删除空目录rmdir -p a/b/c                # 递归删除空目录rmdir -v dirname              # 显示删除信息\n\ntouch : 创建空文件/修改时间戳\n\ntouch filename                # 创建空文件或更新时间为当前时间touch -t 202512131200 filename  # 设置特定时间戳(YYYYMMDDhhmm)touch -a filename             # 只修改访问时间touch -m filename             # 只修改修改时间touch -c filename             # 不创建新文件，只修改时间戳\n\nln : 创建链接\n\nln source target              # 创建硬链接ln -s source target           # 创建软链接（符号链接）ln -sf source target          # 强制创建符号链接（覆盖）ln -i source target           # 交互式（覆盖前询问）\n\n 三、特殊工具类\n\nxxd : 十六进制转储/还原\n\nxxd filename           # 生成hexdump（二进制→十六进制文本）xxd -r hexdump.txt &gt; binary  # 还原hexdump（文本→二进制）xxd -l 100 filename    # 只显示前100字节xxd -p filename        # 纯十六进制输出（无地址和文本）\n\ndu : 查看磁盘使用量\n\ndu filename           # 显示文件大小（单位：块）du -h filename        # 人类可读格式（K、M）du -sh directory      # 显示目录总大小du -s                 # 显示所有文件大小\n\ncd : 切换目录\n\ncd dirname           # 进入目录cd ..               # 返回上级目录cd ~                # 返回用户家目录cd -                # 返回上一个目录cd /tmp             # 进入系统临时目录\n\nwhich : 查找命令位置\n\nwhich command                 # 显示命令完整路径which -a command              # 显示所有匹配路径which --skip-alias command    # 跳过别名\n\nwhereis : 查找命令相关文件\n\nwhereis command               # 查找命令的二进制、源码、手册页whereis -b command            # 只查找二进制whereis -m command            # 只查找手册页whereis -s command            # 只查找源码\n\nlocate : 快速文件查找\n\nlocate filename               # 查找文件locate -i filename            # 忽略大小写locate -c filename            # 统计找到的数量locate -r &quot;\\\\.txt$&quot;            # 使用正则表达式（查找.txt文件）# 注意：需要先运行 sudo updatedb 更新数据库\n\n 四、包管理与软件类\n\napt (Debian/Ubuntu)\n\napt update                   # 更新包列表apt upgrade                  # 升级所有包apt install package          # 安装软件包apt remove package           # 移除软件包apt search keyword           # 搜索软件包\n\nyum (RedHat/CentOS)\n\nyum install package          # 安装软件包yum update                   # 更新软件包yum remove package           # 移除软件包yum search keyword           # 搜索软件包\n\n 五、系统监控与性能类\n\nfree : 显示内存使用情况\n\nfree                          # 显示内存信息free -h                       # 人类可读格式free -m                       # 以MB为单位free -s 5                     # 每5秒刷新一次\n\nvmstat : 虚拟内存统计\n\nvmstat                        # 显示一次统计vmstat 2                      # 每2秒显示一次vmstat 2 10                   # 每2秒一次，共10次vmstat -s                     # 显示事件计数器\n\niostat : 输入输出统计\n\niostat                        # 显示一次统计iostat 2                      # 每2秒显示一次iostat -x                     # 扩展统计信息iostat -c                     # 只显示CPU统计\n\nnetstat / ss : 网络连接统计\n\nnetstat -tuln                 # 显示监听端口netstat -an                   # 显示所有连接netstat -rn                   # 显示路由表ss -tuln                      # ss替代netstat（更快）\n\nlsof : 列出打开文件\n\nlsof                          # 列出所有打开文件lsof -i :80                   # 列出使用80端口的进程lsof -u username              # 列出用户打开的文件lsof /path/to/file            # 列出打开指定文件的进程\n\n 六、链接与引用类\n\nln : 创建链接\n\nln source target              # 创建硬链接ln -s source target           # 创建软链接（符号链接）ln -sf source target          # 强制创建符号链接ln -nfs source target         # 不追踪目录符号链接\n\nreadlink : 读取符号链接目标\n\nreadlink linkname             # 显示符号链接指向readlink -f path              # 显示规范化的绝对路径readlink -e path              # 显示存在文件的规范路径\n\nrealpath : 获取绝对路径\n\nrealpath file                 # 显示文件的绝对路径realpath -s file              # 不解析符号链接realpath -q file              # 静默模式\n\n 七、查找与定位类\n\nlocate : 快速文件查找\n\nlocate filename               # 查找文件locate -i filename            # 忽略大小写locate -c filename            # 统计找到的数量locate -r &quot;pattern&quot;           # 使用正则表达式# 注意：需要先运行 sudo updatedb 更新数据库\n\nwhich : 查找命令位置\n\nwhich command                 # 显示命令完整路径which -a command              # 显示所有匹配路径which --skip-alias command    # 跳过别名\n\nwhereis : 查找命令相关文件\n\nwhereis command               # 查找命令的二进制、源码、手册页whereis -b command            # 只查找二进制whereis -m command            # 只查找手册页whereis -s command            # 只查找源码\n\ntype : 显示命令类型\n\ntype command                  # 显示命令类型（别名/内置/外部）type -a command               # 显示所有可能的解释type -t command               # 只显示类型（file/alias/builtin）\n 权限与用户管理\n 一、权限与用户管理类\n\nsudo : 以超级用户权限执行\n\nsudo command                   # 执行需要root权限的命令sudo -l                       # 列出当前用户可执行的sudo命令sudo -u username command       # 以指定用户身份执行\n\nsu : 切换用户\n\nsu                             # 切换到rootsu username                    # 切换到指定用户su - username                  # 切换用户并加载环境变量\n\nchmod : 修改文件权限\n\nchmod 755 file                # 数字模式设置权限chmod u+x file                # 给所有者添加执行权限chmod a-w file                # 移除所有用户的写权限chmod g=rx file               # 设置组权限为读执行\n\nchown : 修改文件所有者\n\nchown user file               # 修改文件所有者chown user:group file         # 同时修改所有者和组chown -R user dir/            # 递归修改目录下所有文件\n\nId : 显示用户身份信息\n\nid                            # 显示当前用户信息id username                   # 显示指定用户信息id -u                         # 显示用户IDid -g                         # 显示组ID\n\n 二、权限绕过与工作空间类\n相关指令用法\n\nmktemp : 创建临时文件/目录\n\nmktemp -d                  # 创建临时目录，返回路径mktemp file.XXXXXX         # 创建临时文件mktemp -t prefix.XXXXXX    # 在/tmp下创建带前缀的文件mktemp -p /custom/path     # 在指定路径创建\n\ncd : 切换目录\n\ncd /tmp                    # 切换到系统临时目录（总是可写）cd /dev/shm               # 切换到内存文件系统（速度最快）cd ~                      # 回到家目录（可能只读）cd -                      # 回到上一个目录\n\ncp : 复制文件\n\ncp ~/readonly_file .      # 从只读位置复制到当前目录cp -r source_dir dest     # 递归复制目录cp -p file dest           # 保留文件属性\n\nrm : 删除文件/目录\n\nrm -rf dirname            # 强制递归删除目录rm -f filename            # 强制删除文件rm -v file               # 显示删除信息\n\ndf : 查看磁盘空间\n\ndf -h /tmp               # 查看/tmp空间使用（人类可读）df -i /tmp               # 查看inode使用情况\n\nmount : 查看/操作挂载点\n\nmount | grep &quot; ro,&quot;       # 查找只读挂载点mount | grep /tmp         # 查看/tmp挂载属性\n 管道与重定向\n 基础\n\n管道符 | : 连接命令，传递数据\n\ncommand1 | command2          # 将command1的输出作为command2的输入ls -l | grep &quot;.txt&quot;          # 列出文件并过滤txt文件ps aux | sort -nk4           # 列出进程并按内存排序cat file | head -20 | tail -5 # 取文件的第16-20行\n\n重定向符 &gt; : 输出到文件（覆盖）\n\ncommand &gt; file               # 将输出保存到文件（覆盖原有内容）ls &gt; filelist.txt            # 将ls结果保存到文件echo &quot;hello&quot; &gt; greeting.txt  # 创建文件并写入内容\n\n重定向符 &gt;&gt; : 输出到文件（追加）\n\ncommand &gt;&gt; file              # 将输出追加到文件末尾date &gt;&gt; log.txt              # 将当前时间追加到日志echo &quot;new entry&quot; &gt;&gt; data.txt # 在文件末尾添加新行\n\n输入重定向 &lt; : 从文件读取输入\n\ncommand &lt; file               # 从文件读取输入（代替键盘输入）sort &lt; unsorted.txt          # 从文件读取内容进行排序wc -l &lt; data.txt             # 统计文件行数\n\nhere文档 &lt;&lt; : 内联输入\n\ncommand &lt;&lt; EOF多行输入直到遇到EOFEOFcat &lt;&lt; END这是多行文本直接作为输入END\n\n标准错误重定向 2&gt; : 处理错误信息\n\ncommand 2&gt; error.log         # 将错误信息保存到文件find / -name &quot;*.conf&quot; 2&gt;/dev/null  # 丢弃错误信息command 2&gt;&amp;1                 # 将错误重定向到标准输出command &gt; output.txt 2&gt;&amp;1    # 将输出和错误都保存到文件\n\ntee : 分流输出（同时输出到屏幕和文件）\n\ncommand | tee file           # 输出到屏幕并保存到文件ls | tee list.txt | wc -l    # 保存列表并统计行数command | tee -a log.txt     # 追加到文件（-a参数）\n\nxargs : 将管道输入转为命令行参数\n\necho &quot;file1 file2&quot; | xargs rm    # 删除file1和file2find . -name &quot;*.txt&quot; | xargs grep &quot;pattern&quot;  # 在所有txt文件中搜索ls *.txt | xargs -I &#123;&#125; cp &#123;&#125; backup/  # 复制所有txt文件\n\n命名管道 mkfifo : 创建先进先出管道\n\nmkfifo mypipe                # 创建命名管道ls -l &gt; mypipe &amp;             # 在后台写入管道cat &lt; mypipe                 # 从管道读取\n\n进程替换 &lt;( ) 和 &gt;( ) : 将命令输出作为文件\n\ndiff &lt;(ls dir1) &lt;(ls dir2)   # 比较两个目录的内容tar czf &gt;(ssh host &quot;cat &gt; backup.tar.gz&quot;) /data  # 直接压缩传输\n\n 管道组合模式\n模式1：过滤链\ncat log.txt | grep &quot;ERROR&quot; | sort | uniq -c | sort -nr# 读取日志 → 过滤错误 → 排序 → 统计重复 → 按数量降序\n模式2：解码链\ncat encoded.txt | base64 -d | tr &#x27;A-Z&#x27; &#x27;a-z&#x27; | grep &quot;secret&quot;# 读取文件 → base64解码 → 转小写 → 搜索关键词\n模式3：统计报告\nnetstat -an | grep &quot;:80 &quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d: -f1 | sort | uniq -c# 网络连接 → 过滤80端口 → 提取IP → 去端口 → 排序 → 统计每个IP连接数\n\n 注意事项\n1. 管道缓冲区：默认64KB，大数据可能阻塞2. 二进制安全：文本工具可能损坏二进制数据3. 错误处理：管道中某个命令失败不影响后续4. 性能：长管道链可能降低性能\n 文本处理\n 一、文本处理\n\ngrep : 文本搜索工具\n\ngrep &quot;pattern&quot; filename      # 搜索包含&quot;pattern&quot;的行grep -i &quot;pattern&quot; filename   # 忽略大小写搜索grep -r &quot;pattern&quot; dir/       # 递归搜索目录grep -v &quot;pattern&quot; filename   # 显示不包含pattern的行（反转）grep -n &quot;pattern&quot; filename   # 显示行号grep -c &quot;pattern&quot; filename   # 统计匹配行数grep -E &quot;regex&quot; filename     # 使用扩展正则表达式\n\nsort : 排序文本行\n\nsort filename          # 按字母顺序排序sort -n filename       # 按数字大小排序sort -r filename       # 反向排序sort -u filename       # 去重并排序sort data.txt | uniq -u  # 组合使用：找唯一行\n\nuniq : 报告或忽略重复行\n\nuniq filename          # 去重（需先排序）uniq -c filename       # 统计每行出现次数uniq -u filename       # 只显示唯一行（不重复的）uniq -d filename       # 只显示重复行\n\ntr : 字符替换/删除\n\ntr &#x27;a-z&#x27; &#x27;A-Z&#x27; &lt; file  # 小写转大写tr -d &#x27;\\\\n&#x27; &lt; file      # 删除换行符tr -d &#x27;0-9&#x27; &lt; file     # 删除所有数字# ROT13解码：tr &#x27;A-Za-z&#x27; &#x27;N-ZA-Mn-za-m&#x27; &lt; data.txt\n\nbase64 : base64编解码\n\nbase64 filename        # 编码base64 -d filename     # 解码（-d 参数）echo &quot;hello&quot; | base64  # 管道编码echo &quot;aGVsbG8=&quot; | base64 -d  # 管道解码\n\nwc : 统计行数、单词数、字节数\n\nwc filename                   # 统计行数、单词数、字节数wc -l filename                # 只统计行数wc -w filename                # 只统计单词数wc -c filename                # 只统计字节数wc -m filename                # 只统计字符数\n\ncut : 剪切文件中的列\n\ncut -d: -f1 filename          # 以冒号分隔，取第一列cut -c1-10 filename           # 取第1-10个字符cut -f2,5 filename            # 取第2列和第5列cut -d&#x27; &#x27; -f2- filename       # 以空格分隔，取第二列到最后一列\n\npaste : 合并文件行\n\npaste file1 file2             # 并排合并文件paste -d&#x27;,&#x27; file1 file2       # 用逗号分隔合并paste -s file1                # 将文件所有行合并为一行paste -d&#x27;\\\\t&#x27; file1 file2      # 用制表符分隔\n\njoin : 基于共同字段合并文件\n\njoin file1 file2              # 基于第一列合并join -1 2 -2 3 file1 file2    # 指定列合并（file1第2列，file2第3列）join -t&#x27;:&#x27; file1 file2        # 指定分隔符join -a1 file1 file2          # 显示file1所有行（类似左连接）\n\n 二、压缩归档类\n\ntar : 打包/解包归档文件\n\ntar xf archive.tar           # 解包（提取）tar tf archive.tar           # 查看包内文件列表tar czf archive.tar.gz dir/  # 打包并用gzip压缩tar xzf archive.tar.gz       # 解压gzip压缩的tar包tar cjf archive.tar.bz2 dir/ # 打包并用bzip2压缩tar xjf archive.tar.bz2      # 解压bzip2压缩的tar包tar xO archive.tar           # 解包到标准输出（不保存文件）\n\ngzip / gunzip : gzip格式压缩/解压\n\ngzip filename           # 压缩，生成 filename.gzgzip -d filename.gz     # 解压（同 gunzip filename.gz）zcat filename.gz        # 不解压直接查看内容gzip -c file &gt; file.gz  # 压缩并保留原文件\n\nbzip2 / bunzip2 : bzip2格式压缩/解压\n\nbzip2 filename          # 压缩，生成 filename.bz2bzip2 -d filename.bz2   # 解压（同 bunzip2 filename.bz2）bzcat filename.bz2      # 不解压直接查看内容bzip2 -k filename       # 压缩并保留原文件（-k 参数）\n\n 三、文本编辑与处理（高级）\n\nvim / vi : 文本编辑器\n\nvim file                      # 用vim打开文件# 常用操作: i插入, Esc退出插入, :wq保存退出, :q!强制退出\n\nnano : 简单文本编辑器\n\nnano file                     # 用nano打开文件# Ctrl+O保存, Ctrl+X退出\n\nawk : 文本处理语言\n\nawk &#x27;&#123;print $1&#125;&#x27; file        # 打印第一列awk -F: &#x27;&#123;print $1&#125;&#x27; file    # 以冒号为分隔符awk &#x27;/pattern/ &#123;print $0&#125;&#x27;   # 匹配模式的行\n\nsed : 流编辑器\n\nsed &#x27;s/old/new/g&#x27; file       # 替换所有old为newsed -n &#x27;5,10p&#x27; file          # 打印5-10行sed &#x27;/pattern/d&#x27; file        # 删除匹配行\n 网络操作\n\nssh : 安全远程登录\n\nssh user@host                  # 基本连接ssh -p 2220 user@host          # 指定端口ssh -i key.pem user@host       # 使用密钥登录ssh -L 8080:localhost:80 user@host  # 本地端口转发\n\ntelnet : 明文远程登录（测试服务）\n\ntelnet host 端口号             # 连接服务telnet bandit.labs.overthewire.org 2220  # Bandit连接方式\n\nnc (netcat) : 网络瑞士军刀\n\nnc -l -p 1234                  # 监听端口nc host 端口号                 # 连接主机nc -z host 端口范围            # 端口扫描echo &quot;data&quot; | nc host port     # 发送数据\n\ncurl : 传输数据（HTTP/FTP等）\n\ncurl &lt;http://example.com&gt;        # 获取网页curl -o file.txt &lt;http://url&gt;    # 下载文件curl -X POST -d &quot;data&quot; &lt;http://url&gt;  # POST请求curl -u user:pass &lt;http://url&gt;   # 基本认证\n 系统信息与进程\n\nps : 显示进程状态\n\nps aux                        # 显示所有进程详细信息ps -ef                        # 完整格式列表ps -u username                # 显示指定用户的进程ps aux | grep process_name    # 查找特定进程\n\ntop / htop : 动态显示进程\n\ntop                           # 实时进程监控htop                          # 增强版top（需要安装）\n\nkill : 终止进程\n\nkill PID                      # 终止指定PID进程kill -9 PID                   # 强制终止killall process_name          # 终止所有同名进程pkill pattern                 # 按模式终止进程\n\njobs / fg / bg : 作业控制\n\njobs                          # 显示后台作业fg %1                         # 将作业1调到前台bg %1                         # 将作业1放到后台command &amp;                     # 在后台运行命令\n\ndf / du : 磁盘空间\n\ndf -h                         # 显示磁盘使用情况（人类可读）du -sh dir/                   # 显示目录总大小du -h --max-depth=1           # 显示一级子目录大小挂载存储U盘```bash# 1. 创建挂载目录（如果不存在）$ sudo mkdir -p /mnt/vm_disk# 2. 挂载 U 盘（假设 U 盘设备为 /dev/sdb1）$ sudo mount /dev/sdb1 /mnt/vm_disk# 3. 使用完毕后安全卸载 U 盘$ sudo umount /mnt/vm_disk如果想进一步判断 U 盘设备名，可以先用以下命令查看：# 查看当前存储设备信息$ lsblk# 或$ sudo fdisk -l\n\n shell脚本\n 变量定义\n一、变量定义（赋值）\n\n基本定义（不加$）\n\n# 定义变量（赋值时不用$）name=&quot;张三&quot;age=25file=&quot;test.zip&quot;PATH=&quot;/usr/bin:/bin&quot;\n\n规则\n\n· 等号两边不能有空格：name=“张三” ✅ name = “张三” ❌\n· 变量名：字母/数字/下划线，不能数字开头\n· 值可以加引号，也可以不加（但推荐加）\n二、变量使用（要加$）\n\n基本使用\n\nname=&quot;张三&quot;echo $name      # 输出：张三echo &quot;$name&quot;    # 输出：张三（推荐）echo &#x27;$name&#x27;    # 输出：$name（单引号不替换）\n\n变量+文本的三种写法\n\nprefix=&quot;INFO_&quot;# 方法1：大括号（最推荐！）echo &quot;$&#123;prefix&#125;message&quot;    # INFO_message# 方法2：空格分隔echo &quot;$prefix message&quot;     # INFO_ message（有空格）# 方法3：引号外拼接（不推荐）echo $prefix&quot;message&quot;      # INFO_message\n\n必须用大括号的情况\n\n# 当变量名后紧跟文本时count=5echo &quot;我有$&#123;count&#125;个苹果&quot;  # ✅ 正确：我有5个苹果echo &quot;我有$count个苹果&quot;    # ❌ 错误：找$count个苹果变量\n三、输出前缀模式\n\n定义前缀变量\n\n# 定义输出前缀（标签）INFO=&quot;[INFO] &quot;ERROR=&quot;[ERROR] &quot;SUCCESS=&quot;[SUCCESS] &quot;WARNING=&quot;[WARNING] &quot;\n\n使用前缀（必须用{}）\n\nfile=&quot;test.zip&quot;# 正确用法echo &quot;$&#123;INFO&#125;检查文件: $file&quot;     # [INFO] 检查文件: test.zipecho &quot;$&#123;ERROR&#125;文件不存在: $file&quot;  # [ERROR] 文件不存在: test.zipecho &quot;$&#123;SUCCESS&#125;解压成功&quot;         # [SUCCESS] 解压成功# 错误用法echo &quot;$INFO检查文件&quot;    # ❌ 找 $INFO检查文件 变量echo &quot;$ERROR文件不存在&quot; # ❌ 找 $ERROR文件不存在 变量\n\n后期添加颜色（只需修改定义）\n\n# 无颜色版本# INFO=&quot;[INFO] &quot;# ERROR=&quot;[ERROR] &quot;# 有颜色版本（只需改这里！）RED=&#x27;\\\\033[0;31m&#x27;GREEN=&#x27;\\\\033[0;32m&#x27;NC=&#x27;\\\\033[0m&#x27;INFO=&quot;$&#123;RED&#125;[INFO]$&#123;NC&#125; &quot;      # 红色INFOERROR=&quot;$&#123;GREEN&#125;[ERROR]$&#123;NC&#125; &quot;  # 绿色ERROR# 其他地方代码完全不变！\n四、局部变量 vs 全局变量\n\n局部变量（函数内使用）\n\nprocess_file() &#123;    local file=&quot;$1&quot;      # local声明局部变量    local name=&quot;临时&quot;    # 这里的变量不会影响函数外部&#125;# 调用process_file &quot;test.zip&quot;echo $file  # ❌ 为空，因为file是局部变量\n\n全局变量（不加local）\n\nglobal_var=&quot;我是全局的&quot;my_function() &#123;    file=&quot;$1&quot;           # ❌ 危险！影响全局    echo &quot;处理: $file&quot;&#125;# 调用后，file变量在脚本任何地方都可以访问\n五、特殊变量\n变量      含义        $0       脚本名称    $1 - $9  第1-9个参数$#       参数个数$@       所有参数列表$*       所有参数（一个字符串）$?       上一个命令的退出码 0=成功，非0=失败$$       当前进程PID$!       最后一个后台进程PID\n六、命令替换：将命令输出保存到变量\n$()（新写法，推荐）\ncurrent_date=$(date)file_count=$(ls | wc -l)filename=$(basename &quot;/path/to/file.zip&quot;)  # 你的脚本用法\n 条件判断\n 一、基本语法结构\n\nif 基础结构\n\n# 基本格式if [ 条件 ]; then    # 条件成立执行的代码fi# 或写成多行if [ 条件 ]then    # 代码fi\n\nif-else 结构\n\nif [ 条件 ]; then    echo &quot;条件成立&quot;else    echo &quot;条件不成立&quot;fi\n\nif-elif-else 结构\n\nif [ 条件1 ]; then    echo &quot;条件1成立&quot;elif [ 条件2 ]; then    echo &quot;条件2成立&quot;else    echo &quot;都不成立&quot;fi\n 二、测试条件语法\n\n旧语法：test 或 [ ]\n\n# 两种等价写法if test -f &quot;file.txt&quot;; then    echo &quot;文件存在&quot;fiif [ -f &quot;file.txt&quot; ]; then    echo &quot;文件存在&quot;fi\n\n新语法：[[ ]]（推荐）\n\nif [[ -f &quot;file.txt&quot; ]]; then    echo &quot;文件存在&quot;fi\n 三、测试条件\n\n文件存在性\n\n-e 文件/目录存在 -f 是普通文件 -d 是目录 检查是否是目录\n\n文件权限\n\n-r 文件可读 [ ! -r &quot;$file&quot; ] 检查不可读-w 文件可写 检查是否可写-x 文件可执行 检查是否可执行-s 文件非空（大小&gt;0） [ ! -s &quot;$file&quot; ] 检查为空文件\n\n文件类型\n\n-L 是符号链接 [ -L &quot;link&quot; ]-b 是块设备文件 [ -b &quot;/dev/sda&quot; ]-c 是字符设备文件 [ -c &quot;/dev/tty&quot; ]-p 是命名管道 [ -p &quot;fifo&quot; ]\n\n数值比较（整数）\n\n-eq 等于（equal） [ $a -eq $b ]-ne 不等于（not equal） [ $a -ne $b ]-gt 大于（greater than） [ $a -gt $b ]-ge 大于等于 [ $a -ge $b ]-lt 小于（less than） [ $a -lt $b ]-le 小于等于 [ $a -le $b ]\n\n字符串比较\n\n-z 字符串为空 [ -z &quot;$str&quot; ]-n 字符串非空 [ -n &quot;$str&quot; ]= 字符串相等 [ &quot;$str1&quot; = &quot;$str2&quot; ]!= 字符串不等 [ &quot;$str1&quot; != &quot;$str2&quot; ]\n\n逻辑操作符\n\n# 传统写法（不推荐）[ 条件1 -a 条件2 ]  # 与[ 条件1 -o 条件2 ]  # 或[ ! 条件 ]          # 非# 现代写法（推荐）[ 条件1 ] &amp;&amp; [ 条件2 ]   # 与[ 条件1 ] || [ 条件2 ]   # 或! [ 条件 ]              # 非\n\n[[ ]] 增强测试（bash特有）\n\n# 模式匹配[[ $file == *.txt ]]# 正则表达式[[ $input =~ ^[0-9]+$ ]] ^       # 开头（像Ctrl+Home）$       # 结尾（像Ctrl+End）.       # 任意一个字符（像？通配符）*       # 前面的东西出现0次或多次（&quot;随便有没有&quot;）+       # 前面的东西出现1次或多次（&quot;至少要有&quot;）# 字符串比较（不用引号）[[ $str1 &lt; $str2 ]]# 逻辑运算符（不用-a/-o）[[ -f file &amp;&amp; -r file ]]# 处理空值安全[[ $var ]]          # var非空（安全）\n 一、while 循环\n基本结构\nwhile [ 条件 ]do    命令done\n无限循环\n# 服务器监控脚本while truedo    if ! ping -c 1 google.com &gt;/dev/null 2&gt;&amp;1; then        echo &quot;$(date): 网络断开！&quot; &gt;&gt; network.log    fi    sleep 60  # 每60秒检查一次done\n 二、for 循环\n\n遍历列表\n\n# 解压多个指定文件for file in archive1.zip archive2.tar.gz backup.rardo    echo &quot;正在处理: $file&quot;    ./unlock_nest.sh &quot;$file&quot;done\n\n遍历文件\n\n# 解压当前目录所有压缩文件for file in *.zip *.tar.gz *.rar *.7zdo    if [ -f &quot;$file&quot; ]; then        echo &quot;批量解压: $file&quot;        ./unlock_nest.sh &quot;$file&quot;    fidone\n\n遍历命令输出\n\n# 处理find找到的所有zip文件for zipfile in $(find /path -name &quot;*.zip&quot;)do    echo &quot;找到: $zipfile&quot;    unzip &quot;$zipfile&quot;done\n 三、until 循环\n与 while 相反：条件为假时执行\n# 等待服务启动until curl -s &lt;http://localhost:8080&gt; &gt;/dev/nulldo    echo &quot;等待服务启动...&quot;    sleep 2doneecho &quot;服务已启动！&quot;\n 四、循环控制语句\nbreak：跳出循环\n# 找到第一个可解压文件就停止for file in *do    if [[ &quot;$file&quot; =~ \\\\.(zip|tar|rar)$ ]]; then        echo &quot;找到: $file&quot;        ./unlock_nest.sh &quot;$file&quot;        break  # 只处理第一个    fidone\ncontinue：跳过本次循环\n# 跳过空文件for file in *do    if [ ! -s &quot;$file&quot; ]; then        echo &quot;跳过空文件: $file&quot;        continue    fi    echo &quot;处理: $file&quot;done\n 常用命令\n command\ncommand 是一个内置命令，用来查找和执行原始命令，绕过别名和函数。\n一、command 的三大功能\n\n查找命令（最常用）\n\n# 检查命令是否存在（你的脚本用法）if command -v unzip &gt;/dev/null 2&gt;&amp;1; then    echo &quot;unzip已安装&quot;fi# 获取命令路径unzip_path=$(command -v unzip)echo &quot;unzip路径: $unzip_path&quot;\n\n绕过别名和函数\n\n# 假设用户定义了：alias rm=&#x27;rm -i&#x27;           # 删除前询问ls() &#123; echo &quot;自定义函数&quot;; &#125; # 自定义函数# 执行：rm file.txt         # 会询问确认（受别名影响）command rm file.txt # 直接删除（原始行为）ls                  # 输出：&quot;自定义函数&quot;command ls          # 列出文件（原始行为）\n\n执行原始命令\n\n# 强制使用系统命令command echo &quot;hello&quot;  # 使用bash内置的echo/bin/echo &quot;hello&quot;     # 使用外部echo（如果有）\n二、参数详解\n-v    显示命令信息     command -v ls-V    显示详细信息     command -V ls-p    使用默认PATH查找 command -p ls无参数  执行命令        command ls\n\nv 参数详细\n\n# 对不同类型命令的输出command -v cd      # 输出：cd （内置命令）command -v ls      # 输出：/bin/ls （外部命令）command -v ll      # 输出：alias ll=&#x27;ls -l&#x27; （别名）command -v myfunc  # 输出：myfunc （函数）\n\n read\nread = 从键盘读取用户输入，保存到变量中\nread [选项] 变量名\n常用选项\n选项 作用 示例-p 显示提示 read -p &quot;提示: &quot; var-s 静默输入（密码） read -s -p &quot;密码: &quot; pass-t N 超时N秒 read -t 5 -p &quot;输入: &quot;-n N 读取N个字符 read -n 1 -p &quot;按键: &quot;-r 禁用反斜杠转义 read -r line-a 读取为数组 read -a arr\n\n set\n# 安全模式三件套（脚本开头必加）set -e   # 出错就退出set -u   # 未定义变量报错set -o pipefail  # 管道失败也退出# 调试模式set -x   # 打开调试（显示每行命令）set +x   # 关闭调试# 组合使用set -euo pipefail  # 专业脚本标配\n\n 重定向\n 三种标准流\n文件描述符  名称     默认目标 缩写\n0 标准输入 (stdin)  键盘    &lt;\n1 标准输出 (stdout) 屏幕    &gt;\n2 标准错误 (stderr) 屏幕    2&gt;\n 基本重定向语法\n\n输出到文件\n\n# 覆盖写入command &gt; file.txtecho &quot;Hello&quot; &gt; output.txt# 追加写入command &gt;&gt; file.txtecho &quot;World&quot; &gt;&gt; output.txt\n\n错误输出\n\n# 错误输出到文件command 2&gt; error.log# 错误追加到文件command 2&gt;&gt; error.log\n\n所有输出\n\n# 所有输出重定向（覆盖）command &amp;&gt; all_output.log# 所有输出重定向（追加）command &amp;&gt;&gt; all_output.log\n 组合重定向\n\n标准输出和错误输出合并\n\n# 方法1：旧写法command &gt; output.log 2&gt;&amp;1# 方法2：新写法（推荐）command &amp;&gt; output.log# 解释：# &gt; output.log    → 标准输出到文件# 2&gt;&amp;1           → 错误输出也重定向到标准输出（即文件）\n\n分别重定向\n\n# 输出到文件，错误到屏幕command &gt; output.log# 输出到屏幕，错误到文件command 2&gt; error.log# 输出到文件A，错误到文件Bcommand &gt; output.log 2&gt; error.log\n特殊设备：/dev/null\n&quot;黑洞&quot;设备\n# 丢弃所有输出command &gt; /dev/null 2&gt;&amp;1# 只丢弃正常输出，显示错误command &gt; /dev/null# 只丢弃错误，显示正常输出command 2&gt; /dev/null\n 输入重定向\n\n从文件读取输入\n\n# 文件内容作为命令输入command &lt; input.txt# 统计文件行数wc -l &lt; data.txt\n\nHere Document\n\n# 多行输入cat &lt;&lt; EOF第一行第二行第三行EOF# 带变量替换cat &lt;&lt; EOF用户名: $USER时间: $(date)EOF\n\nHere String\n\n# 字符串作为输入tr &#x27;a-z&#x27; &#x27;A-Z&#x27; &lt;&lt;&lt; &quot;hello world&quot;\n 高级技巧\n\n重定向到进程（管道）\n\n# 标准用法command1 | command2# 同时重定向错误command1 2&gt;&amp;1 | command2# 只传递错误command1 2&gt;&amp;1 &gt;/dev/null | command2\n\n进程替换\n\n# 将命令输出作为文件使用diff &lt;(ls dir1) &lt;(ls dir2)# 作为输入文件cat &lt;(echo &quot;第一行&quot;) &lt;(echo &quot;第二行&quot;)\n\n同时输出到文件和屏幕\n\n# 使用 tee 命令command | tee output.log          # 覆盖command | tee -a output.log       # 追加# 同时输出到多个地方command | tee file1.log file2.log &gt;/dev/null\n 常见错误\n错误1：忘记文件描述符\n# 错误：以为这样能重定向错误command &gt; file.log 2&gt;1   # ❌ 创建文件名为&quot;1&quot;的文件！# 正确：需要&amp;符号command &gt; file.log 2&gt;&amp;1  # ✅ 正确\n错误2：noclobber保护\n# 防止意外覆盖文件set -o noclobberecho &quot;test&quot; &gt; existing.txt  # ❌ 失败，文件已存在echo &quot;test&quot; &gt;| existing.txt # ✅ 强制覆盖\n\n自定义流（3-9）\n# 打开自定义文件描述符exec [n]&lt; file    # 打开用于输入（读）exec [n]&gt; file    # 打开用于输出（写，覆盖）exec [n]&gt;&gt; file   # 打开用于输出（写，追加）# 使用自定义描述符command &lt;&amp;n       # 从描述符n读取输入  command &gt;&amp;n       # 向描述符n写入输出# 关闭自定义描述符exec n&gt;&amp;-         # 关闭输出描述符exec n&lt;&amp;-         # 关闭输入描述符\n\n 变量拓展符\n删除操作符\n$&#123;var#pattern&#125;      # 从左删除最短匹配$&#123;var##pattern&#125;     # 从左删除最长匹配$&#123;var%pattern&#125;      # 从右删除最短匹配$&#123;var%%pattern&#125;     # 从右删除最长匹配\n替换操作符\n$&#123;var/pattern/replace&#125;    # 替换第一个匹配$&#123;var//pattern/replace&#125;   # 替换所有匹配$&#123;var/#pattern/replace&#125;   # 替换开头匹配（前缀）$&#123;var/%pattern/replace&#125;   # 替换结尾匹配（后缀）\n默认值操作符\n$&#123;var:-default&#125;    # 如果var空/未设，用default（不赋值）$&#123;var:=default&#125;    # 如果var空/未设，用default并赋值给var$&#123;var:?error_msg&#125;  # 如果var空/未设，显示error_msg并退出$&#123;var:+alt_value&#125;  # 如果var已设，用alt_value\n切片操作符\n$&#123;var:start&#125;          # 从start到结尾$&#123;var:start:length&#125;   # 从start截取length长度# 例子：str=&quot;0123456789&quot;$&#123;str:3&#125;       → &quot;3456789&quot;$&#123;str:3:4&#125;     → &quot;3456&quot;$&#123;str: -3&#125;     → &quot;789&quot;（注意空格）\n大小写转换\n$&#123;var^&#125;        # 首字母大写$&#123;var^^&#125;       # 全部大写$&#123;var,&#125;        # 首字母小写$&#123;var,,&#125;       # 全部小写$&#123;var~&#125;        # 首字母大小写反转$&#123;var~~&#125;       # 全部大小写反转\n","categories":["-Linux"],"tags":["-Linux"]},{"title":"Rust","url":"/2026/02/21/Rust/","content":"","tags":["Rust"]},{"title":"python","url":"/2026/02/22/python/","content":"","tags":["python"]},{"title":"Linux操作系统","url":"/2026/02/26/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":" Linux文件系统\n 一、Linux文件系统层次结构\n1.1 文件系统类型总览\nLinux支持的文件系统：├── 磁盘文件系统│   ├── ext2/ext3/ext4 (主流)│   ├── XFS (高性能)│   ├── Btrfs (高级特性)│   └── ZFS (企业级)│├── 闪存文件系统│   ├── F2FS (Flash Friendly)│   └── JFFS2/UBIFS (嵌入式)│├── 网络文件系统│   ├── NFS (Unix网络)│   ├── CIFS/SMB (Windows兼容)│   └── 9P (分布式)│├── 特殊文件系统│   ├── proc (进程信息)│   ├── sysfs (内核对象)│   ├── tmpfs (内存文件系统)│   └── devtmpfs (设备文件)│└── 虚拟文件系统(VFS)    └── 所有文件系统的抽象层\n 二、磁盘布局与分区结构\n2.1 物理磁盘布局\n磁盘物理结构：┌─────────────────────────────────────┐│ 主引导记录(MBR) 或 GPT头部              ← 扇区0├─────────────────────────────────────┤│ 分区表                              ├─────────────────────────────────────┤│ 分区1: /boot (ext4)                 │   ├── 引导加载器(GRUB)              │   ├── 内核镜像(vmlinuz)             │   └── 初始内存盘(initramfs)         ├─────────────────────────────────────┤│ 分区2: / (根文件系统, ext4)             ← 主要分析对象├─────────────────────────────────────┤│ 分区3: /home (XFS)                  ├─────────────────────────────────────┤│ 分区4: swap (交换分区)              └─────────────────────────────────────┘\n2.2 ext4文件系统详细布局\next4文件系统结构（以4KB块大小为例）：┌─────────────────────────────────────┐│ 块组0                              │ ├── 超级块(Superblock)              ← 文件系统元数据│ ├── 组描述符(Group Descriptors)    │ ├── 块位图(Block Bitmap)            ← 块使用情况│ ├── inode位图(inode Bitmap)         ← inode使用情况│ ├── inode表(inode Table)           ← 所有inode│ └── 数据块(Data Blocks)             ← 文件内容├─────────────────────────────────────┤│ 块组1                              │ ├── 备份超级块                     │ ├── 组描述符                       │ ├── 块位图                         │ ├── inode位图                      │ ├── inode表                        │ └── 数据块                         ├─────────────────────────────────────┤│ ...                                ├─────────────────────────────────────┤│ 块组N                              │ └── ...                            └─────────────────────────────────────┘\n\n3 /boot里面有什么？\n\n# &quot;可以用的文件&quot;！$ ls -lh /boot/vmlinuz-*-rw-r--r-- 1 root root 12M Jan 15 10:30 /boot/vmlinuz-6.7.0-generic# vmlinuz 的结构：┌─────────────────────────────────────┐│ 头部信息                            │├─────────────────────────────────────┤│ 解压缩代码                          │├─────────────────────────────────────┤│ 压缩的内核镜像（gzip压缩）          │ ← 真正的内核代码├─────────────────────────────────────┤│ 可能的内置initramfs                 │└─────────────────────────────────────┘#其他重要文件$ ls -lh /boot/总用量 120M-rw-r--r-- 1 root root  12M Jan 15 vmlinuz-6.7.0-generic      # ★ 内核本体-rw-r--r-- 1 root root  80M Jan 15 initrd.img-6.7.0-generic   # 临时根文件系统-rw-r--r-- 1 root root 5.5M Jan 15 System.map-6.7.0-generic   # 符号地址表-rw-r--r-- 1 root root 230K Jan 15 config-6.7.0-generic       # 编译配置\n 三、关键数据结构详解\n3.1 超级块(Superblock)\n// ext4超级块结构（部分）struct ext4_super_block &#123;    __le32  s_inodes_count;        // inode总数    __le32  s_blocks_count;        // 块总数    __le32  s_r_blocks_count;      // 保留块数    __le32  s_free_blocks_count;   // 空闲块数    __le32  s_free_inodes_count;   // 空闲inode数    __le32  s_first_data_block;    // 第一个数据块号    __le32  s_log_block_size;      // 块大小(2^(10+s_log_block_size))    __le32  s_blocks_per_group;    // 每组块数    __le32  s_inodes_per_group;    // 每组inode数    __le16  s_magic;               // 魔数0xEF53    __le16  s_state;               // 文件系统状态    __le32  s_first_ino;           // 第一个非保留inode    __le16  s_inode_size;          // inode大小(128/256)    // 日志相关    __le32  s_journal_inum;        // 日志文件inode号    __le32  s_journal_dev;         // 日志设备号    // ... 更多字段&#125;;\n超级块内容示例：\n$ dumpe2fs /dev/sda1 | head -50Filesystem volume name:   &lt;none&gt;Last mounted on:          /Filesystem UUID:          12345678-1234-1234-1234-123456789abcFilesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csumInode count:              2621440Block count:              10485760Reserved block count:     524288Free blocks:              8123456Free inodes:              1987654First block:              0Block size:               4096\n3.2 inode结构\n// ext4 inode结构（内存中）struct ext4_inode &#123;    __le16  i_mode;           // 文件类型和权限    __le16  i_uid;            // 所有者ID低位    __le32  i_size_lo;        // 文件大小（字节）    __le32  i_atime;          // 最后访问时间    __le32  i_ctime;          // 最后更改时间    __le32  i_mtime;          // 最后修改时间    __le32  i_dtime;          // 删除时间    __le16  i_gid;            // 组ID低位    __le16  i_links_count;    // 硬链接数    __le32  i_blocks_lo;      // 512字节块数    __le32  i_flags;          // 标志位    union &#123;        struct &#123;            __le32  l_i_version;        &#125; linux1;        // ... 其他OS特定字段    &#125; osd1;    __le32  i_block[15];      // 数据块指针！    // ... 更多字段&#125;;\ninode中的块指针数组：\ni_block[15] 的布局：[0-11]:  直接块指针（直接指向数据块）[12]:    一级间接块指针（指向包含块指针的块）[13]:    二级间接块指针[14]:    三级间接块指针容量计算（4KB块大小）：- 直接块：12 × 4KB = 48KB- 一级间接：每个块1024个指针 × 4KB = 4MB- 二级间接：1024 × 4MB = 4GB- 三级间接：1024 × 4GB = 4TB\n3.3 目录项结构\n// ext4目录项（旧格式）struct ext4_dir_entry_2 &#123;    __le32  inode;           // inode号    __le16  rec_len;         // 目录项长度    __le8   name_len;        // 文件名长度    __le8   file_type;       // 文件类型    char    name[];          // 文件名（变长）&#125;;// 新格式：哈希树目录（dir_index）struct dx_entry &#123;    __le32 hash;    __le32 block;&#125;;// 目录内容示例：$ ls -la /bin总用量 123456drwxr-xr-x  2 root root    4096 1月  1 00:00 .drwxr-xr-x 20 root root    4096 1月  1 00:00 ..-rwxr-xr-x  1 root root   34888 1月  1 00:00 bash    ← 每个都是一个目录项-rwxr-xr-x  1 root root   35064 1月  1 00:00 cat\n3.4 扩展属性(xattr)\n# 扩展属性存储位置1. inode内部（如果空间足够）2. 单独的数据块（ibody外部的xattr块）3. EA inode（大扩展属性）# 查看扩展属性$ getfattr -d /etc/passwd# file: etc/passwduser.myattr=&quot;secret&quot;security.selinux=&quot;system_u:object_r:passwd_file_t:s0&quot;\n 四、文件系统操作流程\n4.1 文件读取过程\n用户请求：read(&quot;/home/user/file.txt&quot;, buf, 4096)内核处理流程：1. 路径解析   ├── VFS层：将路径分解为分量   ├── 遍历目录项：&quot;/&quot; → &quot;home&quot; → &quot;user&quot; → &quot;file.txt&quot;   └── 获取file.txt的inode号2. 权限检查   ├── 检查inode的i_mode权限位   ├── 检查进程凭据（uid/gid）   └── 检查SELinux/AppArmor策略3. 数据定位   ├── 计算要读取的偏移对应的块号   │   └── 偏移8192 → 第2个块（8192/4096=2）   ├── 查找块指针   │   ├── 直接块：i_block[2]   │   ├── 间接块：通过i_block[12]等查找   └── 获取物理块号4. 读取数据   ├── 块设备层：将逻辑块号转换为物理扇区   ├── 发送读请求到磁盘   └── 数据返回用户缓冲区5. 更新元数据   └── 更新inode的i_atime（访问时间）\n4.2 文件写入过程\n// 文件创建流程int fd = open(&quot;/tmp/newfile&quot;, O_CREAT | O_WRONLY, 0644);内核处理：1. 路径查找失败（文件不存在）2. 分配新inode   ├── 查找空闲inode（通过inode位图）   ├── 初始化inode结构   │   ├── i_mode = 0644 | S_IFREG   │   ├── i_uid = 当前uid   │   ├── i_gid = 当前gid   │   ├── i_size = 0   │   └── i_blocks = 0   └── 更新inode位图3. 创建目录项   ├── 在/tmp目录中添加新条目   │   ├── inode = 新分配的inode号   │   ├── name_len = 8 (&quot;newfile&quot;)   │   └── file_type = EXT4_FT_REG_FILE   ├── 更新目录的i_size（如果需要）   └── 更新目录的mtime4. 写入数据   write(fd, &quot;Hello&quot;, 5);   ├── 分配数据块（通过块位图）   ├── 设置inode的i_block[0]指向新块   ├── 写入数据到块   ├── 更新inode的i_size = 5   └── 更新inode的mtime\n4.3 文件删除过程\n# 删除命令$ rm /tmp/newfile内核处理：1. 减少硬链接计数   inode.i_links_count--2. 如果links_count &gt; 0   └── 只删除目录项，inode保留3. 如果links_count == 0   ├── 释放数据块（标记块位图为0）   ├── 释放inode（标记inode位图为0）   ├── 删除所有目录项引用   └── 设置inode.i_dtime为当前时间注意：数据并未立即擦除，只是标记为可用！\n 五、特殊文件系统详解\n5.1 /proc文件系统\n/proc/ 内存中的进程信息文件系统关键目录结构：/proc/├── [pid]/                    # 每个进程的目录│   ├── cmdline              # 命令行参数│   ├── cwd -&gt;               # 当前工作目录符号链接│   ├── environ              # 环境变量│   ├── exe -&gt;               # 可执行文件符号链接│   ├── fd/                  # 打开的文件描述符│   ├── maps                 # 内存映射│   ├── mem                  # 进程内存│   ├── root -&gt;              # 根目录符号链接│   └── status               # 进程状态├── cpuinfo                  # CPU信息├── meminfo                  # 内存信息├── mounts                   # 挂载信息├── net/                     # 网络信息├── sys/                     # 到/sys的符号链接└── version                  # 内核版本\n/proc/[pid]/maps示例：\n$ cat /proc/self/maps00400000-00401000 r-xp 00000000 08:01 1048600    /bin/cat     # 代码段00600000-00601000 r--p 00000000 08:01 1048600    /bin/cat     # 只读数据00601000-00602000 rw-p 00001000 08:01 1048600    /bin/cat     # 可写数据7ffff7a0d000-7ffff7bd0000 r-xp 00000000 08:01 524295         /lib/x86_64-linux-gnu/libc-2.31.so7ffff7bd0000-7ffff7dcf000 ---p 001c3000 08:01 524295         /lib/x86_64-linux-gnu/libc-2.31.so7ffff7dcf000-7ffff7dd3000 r--p 001c2000 08:01 524295         /lib/x86_64-linux-gnu/libc-2.31.so7ffff7dd3000-7ffff7dd5000 rw-p 001c6000 08:01 524295         /lib/x86_64-linux-gnu/libc-2.31.so7ffff7dd5000-7ffff7dd9000 rw-p 00000000 00:00 0              # 匿名映射7ffff7dd9000-7ffff7dfe000 r-xp 00000000 08:01 524291         /lib/x86_64-linux-gnu/ld-2.31.so7ffff7ff8000-7ffff7ffb000 r--p 00000000 00:00 0              [vvar]7ffff7ffb000-7ffff7ffc000 r-xp 00000000 00:00 0              [vdso]7ffff7ffc000-7ffff7ffe000 rw-p 00000000 00:00 0              # 栈7ffff7ffe000-7ffff7fff000 r--p 00025000 08:01 524291         /lib/x86_64-linux-gnu/ld-2.31.so7ffff7fff000-7ffff8000000 rw-p 00026000 08:01 524291         /lib/x86_64-linux-gnu/ld-2.31.so\n5.2 /sys文件系统\n/sys/ 内核对象层次结构主要目录：/sys/├── block/                  # 块设备├── bus/                    # 总线（pci, usb, etc.）├── class/                  # 设备类（net, input, etc.）├── dev/                    # 设备文件├── devices/                # 系统设备树└── kernel/                 # 内核参数    ├── kexec_loaded    ├── mm/                 # 内存管理    └── security/示例：查看CPU信息$ ls /sys/devices/system/cpu/cpu0/cache/    cpuidle/  topology/  crash_notes       onlinecpufreq/  node0/    uevent     crash_notes_size  subsystem\n5.3 /dev文件系统\n/dev/ 设备文件设备文件类型：1. 块设备（b开头） - 随机访问，有缓存   /dev/sda1      # SATA硬盘第一个分区   /dev/nvme0n1p1 # NVMe SSD第一个分区2. 字符设备（c开头） - 顺序访问，无缓存   /dev/tty       # 当前终端   /dev/null      # 空设备   /dev/zero      # 零设备   /dev/random    # 随机数生成器3. 特殊设备文件   /dev/stdin -&gt; /proc/self/fd/0   /dev/stdout -&gt; /proc/self/fd/1   /dev/stderr -&gt; /proc/self/fd/2\n设备号查看：\n$ ls -l /dev/sdabrw-rw---- 1 root disk 8, 0 Jan  1 00:00 /dev/sda# 主设备号: 8 (SCSI/SATA磁盘)# 次设备号: 0 (第一个磁盘)\n 六、文件系统元数据与取证\n6.1 时间戳信息\n# stat命令查看所有时间戳$ stat /etc/passwd  File: /etc/passwd  Size: 2823      \tBlocks: 8          IO Block: 4096   regular fileDevice: 801h/2049d\tInode: 133121      Links: 1Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)Access: 2024-01-15 10:30:00.000000000 +0800  # atimeModify: 2024-01-10 14:25:00.000000000 +0800  # mtimeChange: 2024-01-10 14:25:00.000000000 +0800  # ctime Birth: 2024-01-01 00:00:00.000000000 +0800  # crtime (创建时间，部分FS支持)# 时间戳修改（注意：需要root权限）$ touch -t 202401011200.00 file.txt      # 修改atime和mtime$ touch -a -t 202401011200.00 file.txt   # 只修改atime$ touch -m -t 202401011200.00 file.txt   # 只修改mtime# ctime无法直接修改，会随inode变化自动更新\n6.2 文件系统取证信息\n# 1. 查看已删除但未覆盖的文件$ debugfs /dev/sda1debugfs: lsdel Inode  Owner  Mode    Size    Blocks   Time deleted 1337   root   100644  4096    1/1      Tue Jan 15 10:30:00 2024# 2. 恢复删除的文件debugfs: dump &lt;1337&gt; /tmp/recovered_file# 3. 查看inode详细信息debugfs: stat &lt;133121&gt;Inode: 133121   Type: regular    Mode:  0644   Flags: 0x80000Generation: 1234567890    Version: 0x00000000:00000001User:     0   Group:     0   Size: 2823File ACL: 0    Directory ACL: 0Links: 1   Blockcount: 8Fragment:  Address: 0    Number: 0    Size: 0ctime: 0x659f3b00:00000000 -- Mon Jan 10 14:25:00 2024atime: 0x65a4a788:00000000 -- Mon Jan 15 10:30:00 2024mtime: 0x659f3b00:00000000 -- Mon Jan 10 14:25:00 2024crtime: 0x659f3b00:00000000 -- Mon Jan 10 14:25:00 2024Size of extra inode fields: 32Extended attributes stored in inode body:  security.selinux (37)BLOCKS:(0):1024001TOTAL: 1\n6.3 日志(journal)分析\n# ext4日志信息$ dumpe2fs /dev/sda1 | grep -i journalFilesystem features:      has_journalJournal inode:            8Journal backup:           inode blocksJournal size:             128M# 查看日志内容（需要特殊工具）$ debugfs -R &quot;journal -p 0-100&quot; /dev/sda1Journal starts at block 1, transaction 12345  Sequence: 12345, Type: descriptor, Blocks: 1-5  Sequence: 12345, Type: commit, Blocks: 6  Transaction 12345:    Inode 133121: dirty, committing    Block 1024001: written\n 七、文件系统性能与调优\n7.1 挂载选项\n# /etc/fstab示例UUID=12345678-1234-1234-1234-123456789abc / ext4 defaults,noatime,nodiratime,errors=remount-ro 0 1# 重要挂载选项：defaults          # 默认选项（rw, suid, dev, exec, auto, nouser, async）noatime/nodiratime # 不更新访问时间，提升性能data=ordered      # 数据写入顺序（ordered/journal/writeback）barrier=1         # 写入屏障，保证数据一致性discard           # 启用TRIM（SSD优化）noacl             # 禁用ACLnouser_xattr      # 禁用用户扩展属性\n7.2 文件系统创建参数\n# mkfs.ext4高级选项mkfs.ext4 -t ext4 \\\\  -b 4096 \\\\          # 块大小  -i 16384 \\\\         # bytes/inode比率（每16KB一个inode）  -I 256 \\\\           # inode大小  -J size=128M \\\\     # 日志大小  -O ^has_journal \\\\  # 禁用日志（嵌入式系统）  -E stride=16,stripe-width=64 \\\\  # RAID优化  -L ROOT \\\\          # 卷标  /dev/sda1\n7.3 性能监控工具\n# 1. iostat - 磁盘I/O统计$ iostat -x 1Device     r/s     w/s     rkB/s     wkB/s   await  %utilsda       45.2    12.3    1234.5     567.8    2.34   12.3# 2. iotop - 进程级I/O监控$ iotop -oPa# 3. vmstat - 系统整体性能$ vmstat 1procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 1  0      0 1234567 89012 345678    0    0    45    12  345  789 10  5 85  0  0# 4. blktrace - 块层跟踪$ blktrace -d /dev/sda -o trace$ blkparse trace &gt; analysis.txt\n 八、安全相关文件系统位置\n8.1 敏感文件位置\n系统配置文件：/etc/├── passwd           # 用户账户信息├── shadow           # 加密密码（root可读）├── group            # 组信息├── sudoers          # sudo权限配置├── ssh/             # SSH配置│   ├── sshd_config│   └── authorized_keys├── pam.d/           # PAM认证配置└── crontab          # 计划任务用户数据：/home/├── user1/│   ├── .bash_history    # 命令历史│   ├── .ssh/            # SSH密钥│   ├── .cache/          # 缓存文件│   └── .local/share/    # 应用程序数据└── user2/日志文件：/var/log/├── auth.log         # 认证日志├── syslog           # 系统日志├── kern.log         # 内核日志├── apache2/         # Web服务器日志└── audit/           # 审计日志\n8.2 文件权限与属性\n# 特殊权限位-rwsr-xr-x  # setuid（执行时以文件所有者权限运行）-rwxr-sr-x  # setgid（执行时以文件所属组权限运行）drwxrwxrwt  # sticky bit（目录中只有所有者能删除文件）# ACL访问控制列表$ setfacl -m u:alice:rwx file.txt    # 给alice添加rwx权限$ getfacl file.txt                   # 查看ACL# file: file.txt# owner: root# group: rootuser::rw-user:alice:rwxgroup::r--mask::rwxother::r--# 文件属性（chattr）$ chattr +i important_file    # 设置不可变标志（immutable）$ chattr +a log_file          # 设置只追加标志（append-only）$ lsattr file.txt             # 查看文件属性----i----------- file.txt     # i表示不可变\n 九、文件系统故障恢复\n9.1 常见问题与修复\n# 1. 文件系统损坏检测$ fsck -f /dev/sda1Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary information# 2. 超级块损坏恢复# 使用备份超级块（每个块组一个）$ mke2fs -n /dev/sda1          # 查看备份超级块位置$ fsck -b 32768 /dev/sda1      # 使用备份超级块修复# 3. 误删除恢复# 使用extundelete$ extundelete /dev/sda1 --restore-file /home/user/lost.txt$ extundelete /dev/sda1 --restore-all# 4. 文件系统只读挂载修复# 常见原因：日志错误或磁盘错误$ mount -o remount,rw /      # 尝试重新挂载为读写$ journalctl -xe             # 查看系统日志$ dmesg | tail -50           # 查看内核消息\n 十、文件系统检查工具速查\n10.1 信息查看工具\n# 1. 查看文件系统信息$ df -hT                     # 磁盘使用情况$ lsblk                      # 块设备信息$ blkid                      # 块设备UUID和类型$ mount                      # 挂载信息$ findmnt                    # 树形显示挂载点# 2. 查看inode使用情况$ df -i                      # inode使用统计$ tune2fs -l /dev/sda1 | grep -i inode# 3. 文件系统详细信息$ dumpe2fs /dev/sda1         # ext2/3/4详细信息$ xfs_info /dev/sda2         # XFS信息$ btrfs filesystem show      # Btrfs信息\n10.2 调试与取证工具\n# 1. 低级磁盘查看$ hexdump -C /dev/sda1 | head -100     # 查看原始磁盘内容$ dd if=/dev/sda1 bs=4096 count=1 | od -Ax -tx1 -v  # 查看第一个块# 2. inode和块查看$ debugfs /dev/sda1debugfs: stat &lt;inode号&gt;      # 查看inode信息debugfs: ncheck &lt;inode号&gt;    # 根据inode找文件名debugfs: icat &lt;inode号&gt;      # 查看inode内容debugfs: testb &lt;块号&gt;        # 测试块是否被使用# 3. 文件恢复工具# extundelete, photorec, testdisk, foremost\n Linux内核\n核心子系统\nLinux内核层级结构（自底向上）：┌─────────────────────────────────────────────────────┐│                   系统调用接口                        ← 用户空间接口├─────────────────────────────────────────────────────┤│               进程管理 (Process)                    │               内存管理 (Memory)                     │               文件系统 (Filesystem)                 │               设备驱动 (Driver)                      ← 核心子系统│               网络协议栈 (Network)                  ├─────────────────────────────────────────────────────┤│             进程间通信 (IPC)                        │             虚拟文件系统 (VFS)                      │             设备模型 (Device Model)                  ← 中间层├─────────────────────────────────────────────────────┤│              体系结构相关代码                       │              中断处理 (Interrupt)                  │              定时器 (Timer)                         ← 硬件抽象│              同步原语 (Synchronization)            └─────────────────────────────────────────────────────┘                     硬件\nLinux启动的10个关键阶段：1. BIOS/UEFI阶段   └── 硬件自检，加载引导程序2. Bootloader阶段 (GRUB)   └── 加载内核镜像和initramfs3. 内核入口 (arch/x86/boot/)   └── 汇编代码，初始化基本环境4. 早期初始化 (start_kernel())   └── 初始化体系结构相关部分5. 内存初始化   └── 建立页表，初始化内存管理6. 进程初始化   └── 创建第一个进程 (init_task)7. 驱动初始化   └── 按顺序初始化各个子系统8. 根文件系统挂载   └── 从initramfs切换到真实根文件系统9. 用户空间启动   └── 执行第一个用户进程 (/sbin/init)10. 系统运行    └── 启动各种服务，显示登录界面\n ELF格式\n 一、三个阶段概述\n源码 → 编译器 → 目标文件(.o) → 链接器 → 可执行文件 → 加载器 → 内存映像      (阶段1)               (阶段2)             (阶段3)\n 二、阶段1：目标文件（.o文件）格式\n2.1 目标文件的用途\n· 单个源文件编译的结果\n· 包含未链接的代码和数据\n· 等待链接器合并成可执行文件\n2.2 目标文件的物理布局\n目标文件磁盘布局（64位系统）：偏移量     大小      内容───────────────────────────────────────────────0x0000     64字节    ELF头部 (Elf64_Ehdr)0x0040    可变       节头表 (Elf64_Shdr数组)0x00??    可变       .text节 (代码)0x0???    可变       .rodata节 (只读数据)0x0???    可变       .data节 (已初始化数据)0x0???    可变       .bss节 (占位符，实际无内容)0x0???    可变       .symtab节 (符号表)0x0???    可变       .strtab节 (字符串表)0x0???    可变       .shstrtab节 (节名字符串表)0x0???    可变       .rela.text节 (代码重定位)0x0???    可变       .rela.data节 (数据重定位)\n2.3 目标文件的ELF头部\n// 典型目标文件的ELF头部值Elf64_Ehdr ehdr = &#123;    .e_ident = &#123;0x7F, &#x27;E&#x27;, &#x27;L&#x27;, &#x27;F&#x27;, ELFCLASS64, ...&#125;,    .e_type = ET_REL,           // 类型：可重定位文件    .e_machine = EM_X86_64,     // 架构：x86-64    .e_version = EV_CURRENT,    .e_entry = 0,               // 无入口点（未链接）    .e_phoff = 0,               // 无程序头表    .e_shoff = 0x40,            // 节头表在0x40    .e_flags = 0,    .e_ehsize = 64,             // ELF头大小64字节    .e_phentsize = 0,           // 程序头表项大小（无）    .e_phnum = 0,               // 程序头表项数量（无）    .e_shentsize = 64,          // 节头表项大小64字节    .e_shnum = 12,              // 有12个节    .e_shstrndx = 11,           // 节名字符串表是第11个节&#125;;\n2.4 目标文件的节头表示例\n# 查看目标文件的节$ readelf -S hello.oSection Headers:  [Nr] Name              Type            Address          Offset    Size  [ 0]                   NULL            0000000000000000 00000000 000000  [ 1] .text             PROGBITS        0000000000000000 00000040 00001a  [ 2] .data             PROGBITS        0000000000000000 0000005a 000004  [ 3] .bss              NOBITS          0000000000000000 0000005e 000004  [ 4] .rodata           PROGBITS        0000000000000000 0000005e 000006  [ 5] .comment          PROGBITS        0000000000000000 00000064 00002e  [ 6] .note.GNU-stack   PROGBITS        0000000000000000 00000092 000000  [ 7] .eh_frame         PROGBITS        0000000000000000 00000098 000038  [ 8] .rela.text        RELA            0000000000000000 000000d0 000030  [ 9] .symtab           SYMTAB          0000000000000000 00000100 0000a8  [10] .strtab           STRTAB          0000000000000000 000001a8 00003d  [11] .shstrtab         STRTAB          0000000000000000 000001e5 000061\n2.5 目标文件的符号表\n# 查看目标文件的符号$ readelf -s hello.oSymbol table &#x27;.symtab&#x27; contains 7 entries:   Num:    Value          Size Type    Bind   Vis      Ndx Name     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 .rodata     4: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    4 msg     5: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    2 global     6: 0000000000000000    26 FUNC    GLOBAL DEFAULT    1 main\n 三、阶段2：可执行文件格式\n3.1 可执行文件的用途\n· 链接后的完整程序\n· 可以直接由操作系统加载执行\n· 包含所有需要的代码和数据\n3.2 可执行文件的物理布局\n可执行文件磁盘布局：偏移量     大小      内容───────────────────────────────────────────────0x0000     64字节    ELF头部 (Elf64_Ehdr)0x0040     56×N字节  程序头表 (Elf64_Phdr数组，N=e_phnum)0x0???     可变       解释器路径(.interp节)0x0???     可变       代码段(包含.text, .plt, .rodata等节)0x????     可变       数据段(包含.data, .got, .dynamic等节)0x????     可变       节头表 (Elf64_Shdr数组) ← 可选，可去掉0x????     可变       节名字符串表(.shstrtab) ← 可选\n3.3 可执行文件的ELF头部\n// 典型可执行文件的ELF头部Elf64_Ehdr ehdr = &#123;    .e_ident = &#123;0x7F, &#x27;E&#x27;, &#x27;L&#x27;, &#x27;F&#x27;, ELFCLASS64, ...&#125;,    .e_type = ET_EXEC,          // 类型：可执行文件    .e_machine = EM_X86_64,    .e_version = EV_CURRENT,    .e_entry = 0x4004d0,        // 入口点地址    .e_phoff = 0x40,            // 程序头表在0x40    .e_shoff = 0x1c00,          // 节头表在0x1c00（调试信息）    .e_flags = 0,    .e_ehsize = 64,    .e_phentsize = 56,          // 程序头表项大小56字节    .e_phnum = 9,               // 有9个程序头    .e_shentsize = 64,    .e_shnum = 28,              // 有28个节（调试用）    .e_shstrndx = 27,&#125;;\n3.4 可执行文件的程序头表\n# 查看可执行文件的段$ readelf -l /bin/lsProgram Headers:  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x0001f8 0x0001f8 R   0x8  INTERP         0x000238 0x0000000000400238 0x0000000000400238 0x00001c 0x00001c R   0x1      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x01e584 0x01e584 R E 0x200000  LOAD           0x01ee10 0x000000000061ee10 0x000000000061ee10 0x0008fc 0x001558 RW  0x200000  DYNAMIC        0x01ee28 0x000000000061ee28 0x000000000061ee28 0x0001d0 0x0001d0 RW  0x8  NOTE           0x000254 0x0000000000400254 0x0000000000400254 0x000044 0x000044 R   0x4  GNU_EH_FRAME   0x01c4f0 0x00000000005fc4f0 0x00000000005fc4f0 0x000a7c 0x000a7c R   0x4  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10  GNU_RELRO      0x01ee10 0x000000000061ee10 0x000000000061ee10 0x0005f0 0x0005f0 R   0x1\n3.5 段与节的映射关系\n# 查看段包含哪些节$ readelf -l /bin/ls | grep -A20 &quot;Section to Segment&quot;Section to Segment mapping:  Segment Sections...   00   01     .interp   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr           .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got           .text .fini .rodata .eh_frame_hdr .eh_frame   03     .init_array .fini_array .dynamic .got .data .bss   04     .dynamic   05     .note.ABI-tag .note.gnu.build-id   06     .eh_frame_hdr   07   08     .init_array .fini_array .dynamic .got\n 四、阶段3：内存映像格式\n4.1 内存映像的用途\n· 程序在内存中的运行状态\n· 由操作系统根据可执行文件创建\n· 包含栈、堆等运行时内存区域\n4.2 进程虚拟内存布局（64位Linux）\n高地址 0x7fffffffffff      ┌─────────────────┐      │    内核空间        (用户不可访问)      ├─────────────────┤ 0x7fffffffffff      │   栈(stack)       (向下增长)      │      ↓                ├─────────────────┤      │      ↓                │   (未映射区域)         │      ↑                ├─────────────────┤      │   堆(heap)        (向上增长)      │      ↑                ├─────────────────┤      │   共享库           (libc.so等)      ├─────────────────┤      │  数据段            (.data, .bss)      │  权限: RW             ├─────────────────┤      │  只读数据段        (.rodata)      │  权限: R              ├─────────────────┤      │  代码段           (.text, .plt)      │  权限: R-X            └─────────────────┘低地址 0x400000\n4.3 内存中的关键数据结构\n4.3.1 进程控制块（内核中）\nstruct task_struct &#123;          // 每个进程一个    // ...    struct mm_struct *mm;     // 内存管理结构    // ELF相关信息    unsigned long start_code, end_code;   // 代码段范围    unsigned long start_data, end_data;   // 数据段范围    unsigned long start_brk, brk;         // 堆范围    unsigned long start_stack;            // 栈底    unsigned long arg_start, arg_end;     // 参数区    unsigned long env_start, env_end;     // 环境变量区&#125;;\n4.3.2 内存区域（VMA）\nstruct vm_area_struct &#123;       // 每个内存区域一个    unsigned long vm_start;    // 区域起始地址    unsigned long vm_end;      // 区域结束地址    // 权限和属性    pgprot_t vm_page_prot;     // 页保护位    unsigned long vm_flags;    // VM_READ, VM_WRITE, VM_EXEC    // 映射的文件    struct file *vm_file;    unsigned long vm_pgoff;    // 文件内偏移（页单位）    struct vm_area_struct *vm_next;  // 链表下一个&#125;;\n4.4 从文件到内存的映射示例\n# 查看运行中进程的内存映射$ cat /proc/self/maps  # 查看cat进程自身的内存00400000-0040c000 r-xp 00000000 fd:01 656402     /bin/cat       # 代码段0060b000-0060c000 r--p 0000b000 fd:01 656402     /bin/cat       # 只读数据0060c000-0060d000 rw-p 0000c000 fd:01 656402     /bin/cat       # 数据段7ffff7a0e000-7ffff7bd0000 r-xp 00000000 fd:01 656398           /lib/x86_64-linux-gnu/libc-2.27.so  # libc代码7ffff7bd0000-7ffff7dd0000 ---p 001c2000 fd:01 656398           # 保护间隙7ffff7dd0000-7ffff7dd4000 r--p 001c2000 fd:01 656398           /lib/x86_64-linux-gnu/libc-2.27.so  # libc只读数据7ffff7dd4000-7ffff7dd6000 rw-p 001c6000 fd:01 656398           /lib/x86_64-linux-gnu/libc-2.27.so  # libc数据7ffff7dd6000-7ffff7dda000 rw-p 00000000 00:00 0                # 匿名映射7ffff7dda000-7ffff7dfd000 r-xp 00000000 fd:01 656399           /lib/x86_64-linux-gnu/ld-2.27.so    # 动态链接器7ffff7ff8000-7ffff7ffb000 r--p 00000000 00:00 0                [vvar]7ffff7ffb000-7ffff7ffc000 r-xp 00000000 00:00 0                [vdso]7ffff7ffc000-7ffff7ffd000 r--p 00022000 fd:01 656399           /lib/x86_64-linux-gnu/ld-2.27.so7ffff7ffd000-7ffff7ffe000 rw-p 00023000 fd:01 656399           /lib/x86_64-linux-gnu/ld-2.27.so7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0                # 匿名映射7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                [stack]  # 栈ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0        [vsyscall]\n 五、关键数据流示例\n5.1 代码地址的演变\n源码中的函数地址：main()在hello.c中（无具体地址）↓ 编译后（目标文件）main在.text节偏移0x0处（相对地址）↓ 链接后（可执行文件）main在虚拟地址0x4004d0处（绝对地址）↓ 加载后（内存映像）main在进程地址空间0x4004d0处（实际映射）\n5.2 数据地址的演变\n源码中的全局变量：int global = 42;↓ 编译后global在.data节偏移0x0处，值42↓ 链接后global在虚拟地址0x601028处，值42↓ 加载后global在内存地址0x601028处，可读写\n 内存分区\n 一、内存分区概述\n┌─────────────────────────────────────────────┐│ **1. 内核空间**                              │    用户程序不可直接访问                        ├─────────────────────────────────────────────┤│ **2. 栈区 (Stack)**                          │    增长方向：向低地址扩展（向下增长）           │    特性：后调用的函数栈帧地址更低                │    内容：局部变量、函数参数、返回地址            │              ├─────────────────────────────────────────────┤│ **3. 内存映射区域**     （libc）                      │    动态库、mmap分配、文件映射、线程栈           │    关键：堆栈间的&quot;缓冲地带&quot;，ASLR随机化重点区域   ├─────────────────────────────────────────────┤│ **4. 堆区 (Heap) - 重点详解见第二部分**        │    增长方向：向高地址扩展（向上增长）           │    起始：紧接.bss段向高地址方向                ├─────────────────────────────────────────────┤│ **5. 未初始化数据区 (.bss段)**                │    内容：未初始化的全局/静态变量                │                   ├─────────────────────────────────────────────┤│ **6. 已初始化数据区 (.data段)**               │    内容：已初始化的全局/静态变量                │                      ├─────────────────────────────────────────────┤│ **7. 只读数据区 (.rodata段)**                 │    内容：字符串常量、const全局变量             │              ├─────────────────────────────────────────────┤│ **8. 代码区 (.text段)**                       │    内容：程序执行代码、函数体                  │    CPU从此读取指令执行                        └─────────────────────────────────────────────┘**低地址 0x400000**\n 二、堆区详解\n 一、堆区本质与操作\n1.1 堆区是什么\n动态内存仓库，程序运行时按需分配/释放，生命周期由程序员控制（需手动free）。\n1.2 核心操作函数\nvoid* malloc(size_t size);      // 分配（不初始化）void* calloc(size_t n, size_t s); // 分配并清零void* realloc(void* ptr, size_t s); // 调整大小void free(void* ptr);           // 释放（free(NULL)安全）\n\n 二、堆块（Chunk）结构与对齐\n2.1 Chunk物理布局（64位系统示例）\n一个已分配的堆块（chunk）在内存中：┌─────────────────────────────────────────┐│ chunk头 (16字节)                         │   prev_size (8字节): 前一块大小（若空闲）   │   size (8字节): 本块大小+标志位(P,A,M)        ← malloc管理区├─────────────────────────────────────────┤ ← malloc()返回给用户的指针│ 用户数据区 (分配的大小)                       ← 程序实际使用区├─────────────────────────────────────────┤│ 对齐填充区 (可能0-N字节)                      ← 关键的“浪费”区域└─────────────────────────────────────────┘\n2.2 对齐的根源与计算\n根本原因：CPU/内存控制器硬件要求，不对齐访问会导致性能暴跌或崩溃。\n实际分配大小计算（64位Linux，glibc）：\n请求大小 = N 字节实际分配 = ((N + 16 + 15) &amp; ~15)  // 16字节对齐（含头部）\n示例：\n· malloc(1) → 实际分配 32字节（头部16+用户1+填充15）\n· malloc(24) → 实际分配 48字节（头部16+用户24+填充8）\n2.3 对齐填充区的关键特性\n· 内容不确定：通常是上次使用的残留数据（信息泄露源）\n· 无法被用户直接寻址：位于返回指针指向的用户区之外\n· 攻击利用点：可隐藏shellcode片段或遗留敏感数据\n\n 三、堆管理器（ptmalloc2）组织结构\n3.1 按大小分级管理的“货架系统”\n快速抽屉 (fastbins) - 放小件，不整理├─ 32字节抽屉： [空闲块1]→[空闲块2]→NULL├─ 48字节抽屉： [空闲块3]→NULL├─ 64字节抽屉： 空└─ ... (共10个，到160字节)个人抽屉 (tcache) - 每线程独立，最快├─ 抽屉0 (16字节)： 最多存7个块├─ 抽屉1 (32字节)： [块A]→[块B]→[块C]├─ 抽屉2 (48字节)： 空└─ ... (共64个抽屉，到1032字节)整齐抽屉 (smallbins) - 中等物品，整理有序  ├─ 32字节抽屉： ↔[块X]↔[块Y]↔[块Z]↔ (双向链表)├─ 48字节抽屉： ↔[块M]↔[块N]↔└─ ... (62个，到1008字节)大件仓库 (largebins) - 放大东西，找起来慢├─ 512-576字节区： 按大小排序├─ 576-672字节区： 空└─ ... (63个大小范围) top chunk           ← 堆顶备用空间临时堆放区 (unsorted bin) - 刚free的块先放这└─ 混在一起，等待分类到上面抽屉\n3.2 堆块重用规则（堆风水基础）\n大小匹配      只从相同大小的bin中分配          精确预测成为可能\ntcache优先    优先使用线程缓存                 最容易控制的攻击入口\nLIFO/FIFO     tcache/fastbins后进先出；        smallbins先进先出   控制分配顺序\n不合并        fastbins释放后不立即合并         维持空洞，延长攻击窗口\n 栈区详解\n一、栈的本质与特性\n函数调用的实时工作区，用于存放函数参数、局部变量和调用上下文。自动管理（编译器分配/释放）、后进先出、与函数生命周期严格绑定。\n特点：动态扩张，静态计算\n· 动态扩张：运行时根据函数调用实时向下扩展\n· 静态计算：编译器在编译时精确计算每个函数所需的栈空间大小\n\n二、栈帧结构与编译器对齐\n2.1 完整栈帧布局（x86-64，调用后）\n高地址├─────────────────┤│ 调用者栈帧        ├─────────────────┤│ 参数7~n（若需要）   ← 通过寄存器传递优先├─────────────────┤│ 返回地址           ← 8字节，call指令压入（关键攻击目标！）├─────────────────┤│ 保存的RBP          ← 上一个栈帧基址├─────────────────┤ ← RBP通常指向这里│ 局部变量区          ← 编译器精心布局的区域│   char buf[10]   │   int auth_flag  │   ...            ├─────────────────┤│ 对齐填充区         ← 编译器自动插入的“隐形”区域├─────────────────┤ ← RSP指向这里│ 可能有的临时空间   └─────────────────┘低地址\n2.2 编译器的“自动对齐填充”机制\n根本原因：CPU硬件强制要求。例如：\n· x86-64 System V ABI规定：栈指针必须保持16字节对齐\n· SSE/AVX指令要求：movaps等指令操作的内存地址必须16/32字节对齐\n编译器实际操作：\n// 你写的代码void example() &#123;    char a = &#x27;A&#x27;;      // 1字节    int  b = 100;      // 4字节（需4字节对齐）    long c = 1000;     // 8字节（需8字节对齐）&#125;// 编译器实际布局（64位Linux）：地址         内容rbp-1        char a     (1字节)rbp-8        long c     (8字节对齐地址) ← 为了对齐c，中间有7字节填充！rbp-12       int b      (4字节)             // 编译器可能再插入4字节填充，保证函数开始/结束时RSP对齐\n关键点：这些填充字节是编译器自动插入的，内容通常是随机的（上次函数调用遗留的数据）。\n\n三、栈溢出攻击的核心原理\n3.1 核心攻击路径：覆盖\n栈溢出的本质是：用连续的输入数据，暴力覆盖编译器精心构建的栈帧结构。\n正常栈帧：[局部变量][对齐填充][保存的RBP][返回地址]溢出覆盖顺序（假设从局部变量开始溢出）：1. 填满局部变量区2. 覆盖对齐填充区3. 覆盖保存的RBP4. 覆盖返回地址 ← 🎯 控制程序执行流！5. 继续向上覆盖调用者栈帧...\n3.2 为什么“对齐填充区”如此关键？\n\n信息泄露渠道：填充区包含随机遗留数据，可能含有敏感信息（指针、之前函数的局部变量等）。\n攻击跳板：为攻击payload提供额外的写入空间，特别是当局部变量空间不足时。\n偏移计算的干扰项：攻击者必须准确计算到返回地址的偏移，需要考虑所有编译器插入的填充。\n\n\n四、编译器视角 vs 攻击者视角\n4.1 编译器的“精心设计”\n编译器目标：1. 保证所有数据访问对齐 → 插入填充字节2. 维持栈指针对齐 → 在函数头尾调整RSP3. 优化访问速度 → 重排局部变量顺序4. 生成高效代码 → 假设栈结构不会被破坏\n4.2 攻击者的“暴力破坏”\n攻击者操作：1. 无视所有对齐和布局 → 用数据流淹没一切2. 利用填充区内容 → 可能泄露信息或藏payload3. 精确计算偏移 → 必须逆向编译器布局4. 目标明确：覆盖返回地址或关键变量\n4.3 关键对抗：Stack Canary（栈金丝雀）\n现代编译器防护：┌─────────────────┐│ 局部变量         ├─────────────────┤│ 栈金丝雀          ← 编译器插入的随机值├─────────────────┤│ 保存的RBP        ├─────────────────┤│ 返回地址         └─────────────────┘函数返回前检查金丝雀值是否被改变，若改变 → 立即终止程序（Stack Smashing Detected）\n\n","tags":["-Linux"]},{"title":"C++学习笔记","url":"/2026/02/25/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":" main函数\nint main(int argc, char** argv, char** envp)#argc：命令行参数个数#argv：命令行参数字符串数组#envp：环境变量数组\n一、情况\nint main() &#123;    // 无法获取命令行参数    // 适用于不需要输入的程序&#125;\nint main(int argc, char** argv) &#123;    // 这是最常见的写法    // 可以获取命令行参数，但无法直接访问环境变量    // 但可以用 getenv(&quot;PATH&quot;) 等函数获取&#125;\nint main(int argc, char** argv, char** envp) &#123;    // 可以获取所有信息    // envp 是以NULL结尾的字符串数组    // 每个字符串格式： &quot;NAME=VALUE&quot;&#125;\n二、参数\nargc = 程序名 + 用户输入的参数个数你输入的：     [./vulnerable]  [&quot;AAAAA&quot;]操作系统解析为： argv[0]         argv[1]                 ↓              ↓               程序名          第一个用户参数\n 条件控制\n 一、基础选择结构\nif if (条件) &#123;    // 条件为真时执行&#125;​if-else if (条件) &#123;    // 条件为真时执行&#125; else &#123;    // 条件为假时执行&#125;​if-else if-else if (条件1) &#123;    // 条件1为真&#125; else if (条件2) &#123;    // 条件2为真&#125; else if (条件3) &#123;    // 条件3为真&#125; else &#123;    // 以上都不为真&#125;\n​\n 二、循环结构\nwhile while (条件) &#123;    // 条件为真时重复执行    // 记得在循环内改变条件，否则会无限循环！&#125;​do-while do &#123;    // 至少执行一次    // 然后检查条件&#125; while (条件);  // 注意分号！​for 循环 - 最常用的计数循环for (初始化; 条件; 更新) &#123;    // 循环体&#125;​范围 for 循环 (C++11) - 遍历容器for (类型 变量 : 容器) &#123;    // 使用变量 &#125;\n​\n 三、分支结构\nswitch 语句 - 多路分支switch (表达式) &#123;    case 值1:        // 代码        break;  // 重要！不加会继续执行下一个case    case 值2:        // 代码        break;    case 值3:        // 代码        break;    default:    // 可选，相当于else        // 代码&#125;\n​\n 四、流程控制关键字\nbreak - 跳出当前循环或switchfor (int i = 0; i &lt; 10; i++) &#123;    if (i == 5)     &#123;        break;  // 当i==5时跳出整个循环    &#125;    cout &lt;&lt; i &lt;&lt; endl;&#125;​continue - 跳过本次循环剩余部分for (int i = 0; i &lt; 10; i++) &#123;    if (i % 2 == 0)     &#123;        continue;  // 跳过偶数    &#125;    cout &lt;&lt; i &lt;&lt; endl;  // 只打印奇数&#125;​return - 从函数返回int max(int a, int b) &#123;    if (a &gt; b)     &#123;        return a;  // 提前返回    &#125;    return b;  // 默认返回&#125;\n​\n 五、条件表达式技巧\n常用条件写法：// 1. 比较if (a == b)    // 等于if (a != b)    // 不等于if (a &gt; b)     // 大于if (a &lt; b)     // 小于if (a &gt;= b)    // 大于等于if (a &lt;= b)    // 小于等于// 2. 逻辑组合if (a &amp;&amp; b)    // 与：两者都为真if (a || b)    // 或：至少一个为真if (!a)        // 非：a为假// 3. 简洁写法if (ptr)       // 检查指针非空（ptr != nullptr）if (!str.empty())  // 检查字符串非空if (count)     // 检查非零（count != 0）\n​\n 六、bool\n基本声明与初始化// 声明并初始化bool isReady = true;     // truebool isEmpty = false;    // false// C++11 统一初始化bool isValid&#123;true&#125;;bool isDone&#123;false&#125;;// 自动推断（C++17）auto isFound = true;     // bool 类型bool 定义的完整分类1. 直接 true/false（字面值）bool flag1 = true;     // 直接 truebool flag2 = false;    // 直接 falsebool flag3&#123;true&#125;;      // C++11 统一初始化2. 数字转换（隐式转换）bool flag4 = 1;        // true（非0 → true）bool flag5 = 0;        // false（0 → false）bool flag6 = 100;      // truebool flag7 = -5;       // true（负数也是非0）bool flag8 = 3.14;     // true（小数也是非0）3. 条件表达式（最常见）int age = 20;int score = 85;bool flag9 = (age &gt;= 18);              // 简单条件bool flag10 = (score &gt; 90);            // 比较条件bool flag11 = (!name.empty());         // 函数调用条件bool flag12 = (x &gt; 0 &amp;&amp; y &lt; 100);      // 组合条件4. 函数返回值（本质也是条件）bool isEven(int n) &#123; return n % 2 == 0; &#125;bool isPrime(int n) &#123; /* 判断质数 */ &#125;bool flag13 = isEven(4);        // 调用返回 bool 的函数bool flag14 = checkFile(&quot;a.txt&quot;); // 返回 bool 的任意函数​输入输出bool flag;cin &gt;&gt; flag;           // 输入 1 或 0cin &gt;&gt; boolalpha &gt;&gt; flag;  // 输入 true 或 falsebool flag = true;cout &lt;&lt; flag;               // 输出：1cout &lt;&lt; boolalpha &lt;&lt; flag;  // 输出：truecout &lt;&lt; noboolalpha &lt;&lt; flag;// 输出：1​常见使用场景标志变量bool found = false;for (int num : numbers) &#123;    if (num == target) &#123;        found = true;        break;    &#125;&#125;​状态检查bool isLoggedIn = false;bool isValidInput = true;bool hasPermission = false;​条件控制bool shouldContinue = true;while (shouldContinue) &#123;    // 处理逻辑    if (/* 满足条件 */) &#123;        shouldContinue = false;  // 改变状态    &#125;&#125;​函数中的 bool返回值bool isEven(int number) &#123;    return (number % 2 == 0);&#125;bool isPrime(int n) &#123;    if (n &lt;= 1)         return false;    for (int i = 2; i*i &lt;= n; i++) &#123;        if (n % i == 0) return false;    &#125;    return true;&#125;​参数void printMessage(const string&amp; msg, bool verbose = false) &#123;    cout &lt;&lt; msg;    if (verbose) &#123;        cout &lt;&lt; &quot; [详细信息]&quot;;    &#125;&#125;// 使用printMessage(&quot;完成&quot;, true);   // 输出：完成 [详细信息]printMessage(&quot;完成&quot;);         // 输出：完成​数组与容器中的 boolbool 数组bool flags[3] = &#123;true, false, true&#125;;// 常用于标记状态bool visited[100] = &#123;false&#125;;  // 全部初始化为 false​vector&lt;bool&gt; 特例#include &lt;vector&gt;vector&lt;bool&gt; bits = &#123;true, false, true, true&#125;;// 注意：vector&lt;bool&gt; 是特化版本，节省空间bits[1] = true;  // 修改\n 异或操作（XOR）\n\n基本概念\n\n运算符：^\nint a = 5;    // 二进制: 0101int b = 3;    // 二进制: 0011int c = a ^ b; // 结果: 0110 (十进制 6)\n异或运算规则表\nA  B    A ^ B\n0  0    0\n0  1    1\n1  0    1\n1  1    0\n口诀：相同为0，不同为1\n\n基本性质\n\n// 1. 自反性x ^ x = 0       // 自己异或自己等于0// 2. 与0异或x ^ 0 = x       // 任何数异或0等于自己// 3. 交换律a ^ b = b ^ a// 4. 结合律(a ^ b) ^ c = a ^ (b ^ c)// 5. 可逆性（重要！）if a ^ b = cthen a = c ^ band b = c ^ a\n\n常见用途\n\n3.1 交换两个数（不推荐！）\nint a = 5, b = 3;a = a ^ b;  // a = 5 ^ 3 = 6b = a ^ b;  // b = 6 ^ 3 = 5a = a ^ b;  // a = 6 ^ 5 = 3// 现在 a=3, b=5// ⚠️ 问题：如果 a 和 b 是同一个变量int x = 5;x = x ^ x;  // x = 0x = x ^ x;  // x = 0x = x ^ x;  // x = 0// 结果 x 变成了 0！\n3.2 找出唯一不重复的数\n// 题目：数组中除了一个数出现一次，其他都出现两次vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 3, 2, 1&#125;;int result = 0;for (int num : nums) &#123;    result ^= num;  // 依次异或&#125;// result = 4（只出现一次的数）// 原理：a ^ a = 0，成对的会抵消// 1^1=0, 2^2=0, 3^3=0，最后剩下4\n3.3 判断两个数是否符号相反\nbool oppositeSign(int x, int y) &#123;    return (x ^ y) &lt; 0;  // 异或结果的最高位为1表示符号不同&#125;// 示例oppositeSign(5, -3);   // trueoppositeSign(5, 3);    // falseoppositeSign(-5, -3);  // false\n3.4 加密/解密（简单XOR加密）\nchar encrypt(char data, char key) &#123;    return data ^ key;&#125;char decrypt(char encrypted, char key) &#123;    return encrypted ^ key;  // 同一个key异或两次恢复原数据&#125;// 示例char data = &#x27;A&#x27;;     // 65char key = 0x55;     // 密钥char encrypted = encrypt(data, key);char decrypted = decrypt(encrypted, key);// decrypted 又变回 &#x27;A&#x27;\n\n位操作技巧\n\n4.1 翻转特定位\n// 翻转第k位（0-based）int flipBit(int num, int k) &#123;    return num ^ (1 &lt;&lt; k);&#125;// 示例：翻转 13(1101) 的第1位// 13 ^ (1&lt;&lt;1) = 13 ^ 2 = 15(1111)\n4.2 判断某位是否为1\nbool isBitSet(int num, int k) &#123;    return (num &gt;&gt; k) &amp; 1;  // 与运算，不是异或&#125;// 如果用异或判断会怎样？bool wrongWay(int num, int k) &#123;    return (num ^ (1 &lt;&lt; k)) &lt; num;  // ❌ 不准确&#125;\n4.3 不用比较找最小值/最大值\n// 找到两个数中的最小值（不用if）int min(int x, int y) &#123;    return y ^ ((x ^ y) &amp; -(x &lt; y));&#125;// 找到两个数中的最大值int max(int x, int y) &#123;    return x ^ ((x ^ y) &amp; -(x &lt; y));&#125;\n\n实际应用示例\n\n5.1 校验和计算\n// 简单的奇偶校验int parityCheck(const vector&lt;int&gt;&amp; data) &#123;    int checksum = 0;    for (int byte : data) &#123;        checksum ^= byte;  // 异或所有字节    &#125;    return checksum;&#125;// 传输时：发送 data + checksum// 接收时：重新计算checksum，与收到的比较\n5.2 图形学中的透明混合\n// XOR绘图模式（老式图形编程）void drawXorMode() &#123;    // 第一次画：显示    pixel = pixel ^ color;    // 在同一位置再画一次：擦除（恢复原状）    pixel = pixel ^ color;&#125;\n5.3 游戏开发：切换状态\n// 使用异或切换布尔状态bool toggle(bool state) &#123;    return state ^ true;  // 等价于 !state&#125;// 或直接state ^= 1;  // 0变1，1变0\n\n注意事项和陷阱\n\n6.1 优先级问题\nint a = 5, b = 3, c = 2;int result1 = a ^ b &amp; c;   // 错误！&amp; 优先级高于 ^// 实际是：a ^ (b &amp; c) = 5 ^ 2 = 7int result2 = (a ^ b) &amp; c; // 正确：先异或，再与// (5^3) &amp; 2 = 6 &amp; 2 = 2// 总是加括号！\n6.2 类型转换问题\nchar c1 = 0xFF;    // -1 (有符号)char c2 = 0x7F;    // 127int result = c1 ^ c2;  // 会进行符号扩展！// 最好使用无符号类型unsigned char uc1 = 0xFF;  // 255unsigned char uc2 = 0x7F;  // 127\n6.3 不要用于浮点数！\nfloat f1 = 3.14f;float f2 = 2.71f;float bad = f1 ^ f2;  // ❌ 编译错误！不能对浮点数异或\n\n性能考虑\n\n// 异或通常是CPU最快的操作之一// 在现代CPU上，与加法/减法速度相当// 但编译器优化可能更好int traditionalSwap(int&amp; a, int&amp; b) &#123;    int temp = a;    a = b;    b = temp;&#125;// 编译器可能会优化为寄存器交换// 不要手动用异或&quot;优化&quot;，编译器更聪明\n 输入与输出\n 输入\n\n基本语法\n#include &lt;iostream&gt;using namespace std;// 单个变量cin &gt;&gt; variable;// 多个变量（链式输入）cin &gt;&gt; var1 &gt;&gt; var2 &gt;&gt; var3;\n\n数据类型  读取行为             停止条件           示例输入 → 结果int      读取整数             遇到非数字字符      &quot;123abc&quot; → 123double   读取浮点数           遇到非数字/非小数点  &quot;3.14abc&quot; → 3.14char     读取第一个非空白字符   读取1个字符         &quot;  A&quot; → &#x27;A&#x27;string   读取到下一个空白字符   空格/制表符/换行     &quot;Hello World&quot; → &quot;Hello&quot;bool     读取布尔值           0/1 或 true/false  &quot;1&quot; → true\n\n重要注意事项\n\n空白字符处理\n\n// 空白字符包括：空格(&#x27; &#x27;)、制表符(&#x27;\\\\t&#x27;)、换行符(&#x27;\\\\n&#x27;)cin &gt;&gt; var;  // 会自动跳过前导空白字符\n\n读取会留下分隔符\n\nint a;char ch;string s;cin &gt;&gt; a;    // 输入 &quot;123\\\\n&quot;，读取 123，留下 \\\\ncin &gt;&gt; ch;   // 直接读取 \\\\n，不会等待输入！\n\n混合类型输入问题\n\nint age;string name;//  错误写法cout &lt;&lt; &quot;年龄: &quot;;cin &gt;&gt; age;          // 输入 &quot;25\\\\n&quot;cout &lt;&lt; &quot;姓名: &quot;;getline(cin, name);  // 立即读取到空字符串！//  正确写法cout &lt;&lt; &quot;年龄: &quot;;cin &gt;&gt; age;cin.ignore();        // 清除缓冲区的换行符cout &lt;&lt; &quot;姓名: &quot;;getline(cin, name);  // 正常等待输入\n\n成员函数\n\nget() - 读取字符\n\nchar ch;// 读取单个字符（包括空白字符）ch = cin.get();           // 读取1字符// 读取到缓冲区char buffer[100];cin.get(buffer, 100);     // 读取一行，不丢弃换行符cin.get(buffer, 100, &#x27;;&#x27;);// 读取到分号\n\ngetline() - 读取一行\n\nchar buffer[100];cin.getline(buffer, 100);      // 读取一行，丢弃换行符cin.getline(buffer, 100, &#x27;#&#x27;); // 读取到 # 号\n\nignore() - 忽略字符\n\n// 忽略下一个字符cin.ignore();// 忽略最多100个字符，或直到遇到换行符cin.ignore(100, &#x27;\\\\n&#x27;);// 忽略所有剩余字符直到换行cin.ignore(numeric_limits&lt;streamsize&gt;::max(), &#x27;\\\\n&#x27;);\n\npeek() - 查看下一个字符\n\nchar next = cin.peek();  // 查看但不提取下一个字符\n\nputback() - 放回字符\n\nchar ch = cin.get();cin.putback(ch);  // 将字符放回输入流\n\n 输出\n核心输出对象\n#include &lt;iostream&gt;using namespace std;cout    // 标准输出（屏幕）cerr    // 标准错误输出（无缓冲，立即显示）clog    // 标准日志输出（有缓冲）\n\n基础输出语法\n\n基本用法\n\ncout &lt;&lt; &quot;Hello World!&quot;;           // 输出字符串cout &lt;&lt; 42;                       // 输出整数cout &lt;&lt; 3.14;                     // 输出浮点数cout &lt;&lt; true;                     // 输出布尔值\n\n链式输出\n\nint age = 25;double salary = 5000.5;string name = &quot;张三&quot;;cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; name     &lt;&lt; &quot;, 年龄: &quot; &lt;&lt; age     &lt;&lt; &quot;, 工资: &quot; &lt;&lt; salary &lt;&lt; endl;\n\n换行控制\n\ncout &lt;&lt; &quot;第一行&quot; &lt;&lt; endl;        // 换行并刷新缓冲区cout &lt;&lt; &quot;第二行\\\\n&quot;;              // 只换行，不刷新缓冲区cout &lt;&lt; &quot;第三行&quot; &lt;&lt; &#x27;\\\\n&#x27;;        // 字符换行\n\n数组输出\n\n#include &lt;iostream&gt;using namespace std;int main() &#123;    int arr[5] = &#123;1, 2, 3, 4, 5&#125;;        // 使用 for 循环    for(int i = 0; i &lt; 5; i++) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        // 使用范围 for 循环（C++11 及以上）    for(int num : arr) &#123;        cout &lt;&lt; num &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        return 0;&#125;#include &lt;iostream&gt;using namespace std;int main() &#123;    int arr[5] = &#123;10, 20, 30, 40, 50&#125;;    int* ptr = arr; // 指向数组首元素        for(int i = 0; i &lt; 5; i++) &#123;        cout &lt;&lt; *(ptr + i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        return 0;&#125;\n\n格式化输出（头文件：）\n\n整数格式化\n\n#include &lt;iomanip&gt;int num = 255;// 进制输出cout &lt;&lt; dec &lt;&lt; num &lt;&lt; endl;      // 255（十进制，默认）cout &lt;&lt; hex &lt;&lt; num &lt;&lt; endl;      // ff（十六进制）cout &lt;&lt; oct &lt;&lt; num &lt;&lt; endl;      // 377（八进制）// 显示进制前缀cout &lt;&lt; showbase;cout &lt;&lt; hex &lt;&lt; num &lt;&lt; endl;      // 0xffcout &lt;&lt; oct &lt;&lt; num &lt;&lt; endl;      // 0377// 控制字母大小写cout &lt;&lt; uppercase &lt;&lt; hex &lt;&lt; num &lt;&lt; endl;   // 0xFFcout &lt;&lt; nouppercase &lt;&lt; hex &lt;&lt; num &lt;&lt; endl; // 0xff\n\n浮点数格式化\n\ndouble pi = 3.14159265358979;// 固定小数位数cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; pi &lt;&lt; endl;    // 3.14cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; pi &lt;&lt; endl;    // 3.1416// 科学计数法cout &lt;&lt; scientific &lt;&lt; setprecision(2) &lt;&lt; pi &lt;&lt; endl;  // 3.14e+00// 显示小数点cout &lt;&lt; showpoint &lt;&lt; 10.0 &lt;&lt; endl;     // 10.0000（默认精度）cout &lt;&lt; noshowpoint &lt;&lt; 10.0 &lt;&lt; endl;   // 10// 显示正数符号cout &lt;&lt; showpos &lt;&lt; 42 &lt;&lt; endl;         // +42cout &lt;&lt; noshowpos &lt;&lt; 42 &lt;&lt; endl;       // 42\n\n字段宽度和对齐\n\nint num = 123;string text = &quot;Hello&quot;;// 设置宽度（只对下一个输出有效）cout &lt;&lt; setw(10) &lt;&lt; num &lt;&lt; endl;       // &quot;       123&quot;cout &lt;&lt; setw(10) &lt;&lt; text &lt;&lt; endl;      // &quot;     Hello&quot;// 对齐方式cout &lt;&lt; left &lt;&lt; setw(10) &lt;&lt; num &lt;&lt; endl;                // &quot;123       &quot;cout &lt;&lt; right &lt;&lt; setw(10) &lt;&lt; num &lt;&lt; endl;               // &quot;       123&quot;cout &lt;&lt; internal &lt;&lt; setw(10) &lt;&lt; showpos &lt;&lt; num &lt;&lt; endl; // &quot;+      123&quot;                           //  noshowpos（控制符号显示或隐藏）// 填充字符cout &lt;&lt; setfill(&#x27;*&#x27;) &lt;&lt; setw(10) &lt;&lt; num &lt;&lt; endl;  // &quot;*******123&quot;cout &lt;&lt; setfill(&#x27; &#x27;);  // 恢复空格填充\n\n特殊字符输出\n\n转义字符\n\ncout &lt;&lt; &quot;换行: 第一行\\n第二行&quot; &lt;&lt; endl;cout &lt;&lt; &quot;制表符: 姓名\\t年龄&quot; &lt;&lt; endl;cout &lt;&lt; &quot;双引号: \\&quot;Hello\\&quot;&quot; &lt;&lt; endl;cout &lt;&lt; &quot;单引号: \\&#x27;C++\\&#x27;&quot; &lt;&lt; endl;cout &lt;&lt; &quot;反斜杠: C:\\\\Program Files\\\\&quot; &lt;&lt; endl;cout &lt;&lt; &quot;回车: 进度条&quot; &lt;&lt; &quot;\\r&quot; &lt;&lt; &quot;完成&quot; &lt;&lt; endl;  // 回车到行首cout &lt;&lt; &quot;蜂鸣: \\a&quot; &lt;&lt; endl;  // 发出声音\n\n转义字符标\n\n转义序列 含义 ASCII码 说明\\a 警报 (Alert/蜂鸣) 7 发出声音\\b 退格 (Backspace) 8 后退一格\\t 水平制表符 (Tab) 9 对齐用\\n 换行 (Newline) 10 新的一行\\v 垂直制表符 11 垂直对齐\\f 换页 (Form feed) 12 打印机换页\\r 回车 (Carriage return) 13 回到行首\\\\ 反斜杠 92 输出 \\\\&#x27; 单引号 39 输出 &#x27;\\&quot; 双引号 34 输出 &quot;\\? 问号 63 输出 ?\\0 空字符 (Null) 0 字符串结束符\n 内置函数\n 一、字符串处理（）\n\n长度相关\n\n#include &lt;string&gt;using namespace std;string str = &quot;Hello&quot;;// 获取长度/大小（效果一样）int len1 = str.length();    // 5int len2 = str.size();      // 5（推荐用这个，和容器一致）// 检查是否为空bool isEmpty = str.empty();  // false\n\n查找与截取\n\nstring str = &quot;Hello World&quot;;// 查找子串位置size_t pos = str.find(&quot;World&quot;);  // 6（从0开始计数）size_t notFound = str.find(&quot;abc&quot;); // string::npos（很大的数）// 从后往前查找pos = str.rfind(&quot;o&quot;);  // 7（最后一个o的位置）// 检查是否包含if (str.find(&quot;World&quot;) != string::npos) &#123;    cout &lt;&lt; &quot;包含World&quot; &lt;&lt; endl;&#125;// 截取子串string sub1 = str.substr(6);      // &quot;World&quot;（从位置6到结尾）string sub2 = str.substr(0, 5);   // &quot;Hello&quot;（从0开始，取5个字符）string sub3 = str.substr(6, 5);   // &quot;World&quot;\n\n修改与连接\n\n// 追加str.append(&quot;!!!&quot;);        // &quot;Hello World!!!&quot;str += &quot;!!!&quot;;             // 同样效果// 插入str.insert(5, &quot; C++&quot;);    // &quot;Hello C++ World&quot;// 替换str.replace(6, 5, &quot;C++&quot;); // &quot;Hello C++&quot;（从位置6开始替换5个字符）// 删除str.erase(5, 4);          // 删除位置5开始的4个字符str.clear();              // 清空字符串\n\n字符访问与修改\n\n// 访问字符（类似数组）char ch = str[0];      // &#x27;H&#x27;char ch2 = str.at(0);  // &#x27;H&#x27;（会检查边界，越界会抛异常）// 修改字符str[0] = &#x27;h&#x27;;          // &quot;hello World&quot;str.at(1) = &#x27;E&#x27;;       // &quot;hEllo World&quot;// 获取C风格字符串const char* cstr = str.c_str();  // 用于需要char*参数的函数\n 二、字符处理（）\n#include &lt;cctype&gt;char ch = &#x27;A&#x27;;// 类型判断isalpha(ch);  // 是否字母（a-z, A-Z）→ trueisdigit(ch);  // 是否数字（0-9）→ falseisalnum(ch);  // 是否字母或数字 → trueisspace(ch);  // 是否空白（空格、制表符、换行等）→ falseislower(ch);  // 是否小写字母 → falseisupper(ch);  // 是否大写字母 → true// 大小写转换char lower = tolower(&#x27;A&#x27;);  // &#x27;a&#x27;char upper = toupper(&#x27;a&#x27;);  // &#x27;A&#x27;// 检查可打印字符isprint(ch);  // 是否可打印字符（非控制字符）→ true\n 三、输入输出处理（）\n#include &lt;iostream&gt;using namespace std;// 输出cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl;    // 输出并换行cout &lt;&lt; &quot;Hello\\\\n&quot;;          // 同样效果// 输入int num;string name;cin &gt;&gt; num;     // 读取整数（跳过空白）cin &gt;&gt; name;    // 读取单词（遇到空白停止）// 读取整行string line;getline(cin, line);  // 读取一行（包括空格）// 注意：cin &gt;&gt; 和 getline 混用时的问题int age;string fullName;cin &gt;&gt; age;               // 读取数字cin.ignore();             // 清除缓冲区中的换行符getline(cin, fullName);   // 现在可以正确读取整行\n 四、数学函数（）\n#include &lt;cmath&gt;// 基本运算abs(-10);      // 绝对值：10fabs(-3.14);   // 浮点数绝对值：3.14pow(2, 3);     // 2的3次方：8sqrt(16);      // 平方根：4// 四舍五入round(3.6);    // 4（四舍五入）ceil(3.2);     // 4（向上取整）floor(3.8);    // 3（向下取整）// 三角函数（参数为弧度）sin(3.14159);  // 正弦cos(3.14159);  // 余弦tan(3.14159);  // 正切// 对数和指数log(10);       // 自然对数log10(100);    // 以10为底的对数：2exp(1);        // e的1次方：约2.718// 最大值最小值（C++11后）max(5, 10);    // 10min(5, 10);    // 5\n 五、算法函数（）\n#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; nums = &#123;3, 1, 4, 1, 5, 9&#125;;// 排序sort(nums.begin(), nums.end());  // 升序：1, 1, 3, 4, 5, 9sort(nums.rbegin(), nums.rend()); // 降序// 查找auto it = find(nums.begin(), nums.end(), 4);if (it != nums.end()) &#123;    cout &lt;&lt; &quot;找到了，位置：&quot; &lt;&lt; distance(nums.begin(), it) &lt;&lt; endl;&#125;// 反转reverse(nums.begin(), nums.end());// 统计int countOnes = count(nums.begin(), nums.end(), 1);  // 2// 最大最小值int maxVal = *max_element(nums.begin(), nums.end());  // 9int minVal = *min_element(nums.begin(), nums.end());  // 1// 去重（需要先排序）sort(nums.begin(), nums.end());auto last = unique(nums.begin(), nums.end());nums.erase(last, nums.end());\n 六、实用工具函数\n\n类型转换\n\n#include &lt;string&gt;#include &lt;sstream&gt;// 字符串转数字string strNum = &quot;123&quot;;int num1 = stoi(strNum);     // string to intdouble num2 = stod(&quot;3.14&quot;);  // string to doublelong num3 = stol(&quot;1000&quot;);    // string to long// 数字转字符串int num = 456;string str1 = to_string(num);  // &quot;456&quot;string str2 = to_string(3.1415); // &quot;3.141500&quot;// 使用stringstream（更灵活）stringstream ss;ss &lt;&lt; &quot;年龄：&quot; &lt;&lt; 25 &lt;&lt; &quot;，分数：&quot; &lt;&lt; 98.5;string info = ss.str();  // &quot;年龄：25，分数：98.5&quot;\n\n随机数（C++11）\n\n#include &lt;random&gt;#include &lt;ctime&gt;// 生成0-99的随机整数mt19937 rng(time(0));  // 随机数引擎uniform_int_distribution&lt;int&gt; dist(0, 99);int randomNum = dist(rng);  // 每次运行都不同// 生成0.0-1.0的随机浮点数uniform_real_distribution&lt;double&gt; dist2(0.0, 1.0);double randomDouble = dist2(rng);\n 读取文本文件\n 最基础：读取整个文件\n#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;int main() &#123;    // 方法1：逐行读取    std::ifstream file1(&quot;example.txt&quot;);    std::string line;    if (file1.is_open()) &#123;        while (std::getline(file1, line)) &#123;            std::cout &lt;&lt; line &lt;&lt; std::endl;        &#125;        file1.close();    &#125; else &#123;        std::cout &lt;&lt; &quot;无法打开文件！&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;\n​\n 读取整个文件到字符串（一次性）\n#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;string&gt;std::string readEntireFile(const std::string&amp; filename) &#123;    // 方法2：使用stringstream    std::ifstream file(filename);    std::stringstream buffer;    if (!file.is_open()) &#123;        return &quot;&quot;;  // 返回空字符串表示失败    &#125;    buffer &lt;&lt; file.rdbuf();  // 读取整个文件    file.close();    return buffer.str();&#125;// 或者更现代的方式std::string readEntireFile2(const std::string&amp; filename) &#123;    std::ifstream file(filename, std::ios::ate);  // ate: 直接到文件末尾    if (!file.is_open()) &#123;        return &quot;&quot;;    &#125;    size_t fileSize = file.tellg();  // 获取文件大小    file.seekg(0);  // 回到开头    std::string content;    content.resize(fileSize);  // 预分配空间    file.read(&amp;content[0], fileSize);  // 直接读取到string    file.close();    return content;&#125;\n​\n 读取着色器文件的完整示例\n#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;string&gt;// 读取着色器文件 - 完整版本std::string readShaderFile(const char* filePath) &#123;    // 1. 打开文件（二进制模式可选）    std::ifstream file(filePath, std::ios::in);    // 2. 检查是否成功打开    if (!file.is_open()) &#123;        std::cerr &lt;&lt; &quot;错误：无法打开文件 &quot; &lt;&lt; filePath &lt;&lt; std::endl;        // 调试信息：列出当前目录        #ifdef _WIN32            system(&quot;dir&quot;);        #else            system(&quot;ls -la&quot;);        #endif        return &quot;&quot;;    &#125;    // 3. 读取内容    std::stringstream contentStream;    // 方法A：逐行读取（保留换行符）    std::string line;    while (std::getline(file, line)) &#123;        contentStream &lt;&lt; line &lt;&lt; &quot;\\\\n&quot;;  // 添加换行    &#125;    // 方法B：一次性读取（更快）    // contentStream &lt;&lt; file.rdbuf();    // 4. 关闭文件    file.close();    return contentStream.str();&#125;\n​\n 读取二进制文件\n#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;// 读取二进制文件（如图片、模型）std::vector&lt;char&gt; readBinaryFile(const std::string&amp; filename) &#123;    // 以二进制模式打开    std::ifstream file(filename, std::ios::binary | std::ios::ate);    if (!file.is_open()) &#123;        throw std::runtime_error(&quot;无法打开文件: &quot; + filename);    &#125;    // 获取文件大小    std::streamsize size = file.tellg();    file.seekg(0, std::ios::beg);    // 读取到vector    std::vector&lt;char&gt; buffer(size);    if (!file.read(buffer.data(), size)) &#123;        throw std::runtime_error(&quot;读取文件失败: &quot; + filename);    &#125;    file.close();    return buffer;&#125;​读取配置文件（CSV/键值对）#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;vector&gt;// 读取CSV文件std::vector&lt;std::vector&lt;std::string&gt;&gt; readCSV(const std::string&amp; filename) &#123;    std::ifstream file(filename);    std::vector&lt;std::vector&lt;std::string&gt;&gt; data;    std::string line;    while (std::getline(file, line)) &#123;        std::vector&lt;std::string&gt; row;        std::stringstream lineStream(line);        std::string cell;        while (std::getline(lineStream, cell, &#x27;,&#x27;)) &#123;  // 逗号分隔            row.push_back(cell);        &#125;        data.push_back(row);    &#125;    return data;&#125;// 读取键值对配置文件std::map&lt;std::string, std::string&gt; readConfig(const std::string&amp; filename) &#123;    std::ifstream file(filename);    std::map&lt;std::string, std::string&gt; config;    std::string line;    while (std::getline(file, line)) &#123;        // 跳过注释和空行        if (line.empty() || line[0] == &#x27;#&#x27;) &#123;            continue;        &#125;        size_t pos = line.find(&#x27;=&#x27;);        if (pos != std::string::npos) &#123;            std::string key = line.substr(0, pos);            std::string value = line.substr(pos + 1);            // 去除空格            key.erase(0, key.find_first_not_of(&quot; \\\\t&quot;));            key.erase(key.find_last_not_of(&quot; \\\\t&quot;) + 1);            value.erase(0, value.find_first_not_of(&quot; \\\\t&quot;));            value.erase(value.find_last_not_of(&quot; \\\\t&quot;) + 1);            config[key] = value;        &#125;    &#125;    return config;&#125;​错误处理最佳实践#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;system_error&gt;  // C++11错误处理class FileReader &#123;private:    std::string filename_;public:    explicit FileReader(const std::string&amp; filename) : filename_(filename) &#123;&#125;    // 方法1：返回bool表示成功/失败    bool readToString(std::string&amp; content) &#123;        std::ifstream file(filename_);        if (!file) &#123;            std::cerr &lt;&lt; &quot;无法打开文件: &quot; &lt;&lt; filename_ &lt;&lt; std::endl;            return false;        &#125;        std::stringstream buffer;        buffer &lt;&lt; file.rdbuf();        content = buffer.str();        return true;    &#125;    // 方法2：抛出异常    std::string readOrThrow() &#123;        std::ifstream file(filename_);        if (!file) &#123;            throw std::runtime_error(&quot;无法打开文件: &quot; + filename_);        &#125;        std::stringstream buffer;        buffer &lt;&lt; file.rdbuf();        return buffer.str();    &#125;    // 方法3：使用std::error_code（现代C++）    std::string readWithError(std::error_code&amp; ec) &#123;        std::ifstream file(filename_);        if (!file) &#123;            ec = std::make_error_code(std::errc::no_such_file_or_directory);            return &quot;&quot;;        &#125;        std::stringstream buffer;        buffer &lt;&lt; file.rdbuf();        ec.clear();  // 清除错误码        return buffer.str();    &#125;&#125;;\n​\n 实用工具函数集合\n#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;namespace FileUtils &#123;    // 检查文件是否存在    bool fileExists(const std::string&amp; path) &#123;        std::ifstream file(path);        return file.good();    &#125;    // 获取文件大小    size_t getFileSize(const std::string&amp; filename) &#123;        std::ifstream file(filename, std::ios::binary | std::ios::ate);        if (!file.is_open()) return 0;        return file.tellg();    &#125;    // 读取前N行    std::vector&lt;std::string&gt; readFirstNLines(const std::string&amp; filename, int n) &#123;        std::ifstream file(filename);        std::vector&lt;std::string&gt; lines;        std::string line;        for (int i = 0; i &lt; n &amp;&amp; std::getline(file, line); i++) &#123;            lines.push_back(line);        &#125;        return lines;    &#125;    // 统计文件行数    int countLines(const std::string&amp; filename) &#123;        std::ifstream file(filename);        if (!file.is_open()) return -1;        int count = 0;        std::string line;        while (std::getline(file, line)) &#123;            count++;        &#125;        return count;    &#125;    // 查找文件中是否包含特定文本    bool containsText(const std::string&amp; filename, const std::string&amp; searchText) &#123;        std::ifstream file(filename);        std::string line;        while (std::getline(file, line)) &#123;            if (line.find(searchText) != std::string::npos) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;\n 指针\n 一、指针基础概念\n1.1 什么是指针指针是一个变量，其值为另一个变量的内存地址。int var = 10;      // 普通整型变量int* ptr = &amp;var;   // ptr是指向var的指针​1.2 指针声明和初始化// 声明指针int* p1;       // 指向int的指针double* p2;    // 指向double的指针char* p3;      // 指向char的指针// 初始化指针int x = 5;int* ptr = &amp;x;  // &amp; 取地址运算符// 空指针（推荐使用nullptr，C++11以后）int* p4 = nullptr;  // 现代C++int* p5 = NULL;     // 传统C/C++int* p6 = 0;        // 字面量0\n 二、指针基本操作\n2.1 取地址和间接访问int value = 42;int* ptr = &amp;value;    // ptr保存value的地址cout &lt;&lt; &quot;value的值: &quot; &lt;&lt; value &lt;&lt; endl;      // 42cout &lt;&lt; &quot;value的地址: &quot; &lt;&lt; &amp;value &lt;&lt; endl;   // 0x7ffeeb5c...cout &lt;&lt; &quot;ptr的值: &quot; &lt;&lt; ptr &lt;&lt; endl;          // 与&amp;value相同cout &lt;&lt; &quot;ptr指向的值: &quot; &lt;&lt; *ptr &lt;&lt; endl;     // 42，*是解引用运算符// 通过指针修改变量*ptr = 100;cout &lt;&lt; &quot;修改后value的值: &quot; &lt;&lt; value &lt;&lt; endl;  // 100​2.2 指针运算int arr[5] = &#123;10, 20, 30, 40, 50&#125;;int* p = arr;  // p指向数组第一个元素cout &lt;&lt; *p &lt;&lt; endl;        // 10cout &lt;&lt; *(p + 1) &lt;&lt; endl;  // 20，指针加法cout &lt;&lt; *(p + 2) &lt;&lt; endl;  // 30p++;  // 移动到下一个元素cout &lt;&lt; *p &lt;&lt; endl;        // 20// 指针比较int* p1 = &amp;arr[0];int* p2 = &amp;arr[3];if (p1 &lt; p2) &#123;    cout &lt;&lt; &quot;p1在p2之前&quot; &lt;&lt; endl;&#125;\n 三、指针与数组\n3.1 数组名即指针int numbers[5] = &#123;1, 2, 3, 4, 5&#125;;// 数组名是指向第一个元素的指针cout &lt;&lt; numbers &lt;&lt; endl;    // 数组首地址cout &lt;&lt; &amp;numbers[0] &lt;&lt; endl; // 与numbers相同// 访问数组元素cout &lt;&lt; numbers[2] &lt;&lt; endl;      // 3cout &lt;&lt; *(numbers + 2) &lt;&lt; endl;  // 3，等价于numbers[2]// 遍历数组的三种方式// 1. 使用下标for (int i = 0; i &lt; 5; i++) &#123;    cout &lt;&lt; numbers[i] &lt;&lt; &quot; &quot;;&#125;// 2. 使用指针算术for (int i = 0; i &lt; 5; i++) &#123;    cout &lt;&lt; *(numbers + i) &lt;&lt; &quot; &quot;;&#125;// 3. 使用指针变量int* ptr = numbers;for (int i = 0; i &lt; 5; i++) &#123;    cout &lt;&lt; *ptr++ &lt;&lt; &quot; &quot;;&#125;​3.2 指针数组 vs 数组指针// 指针数组：数组的元素是指针int a = 1, b = 2, c = 3;int* ptrArr[3] = &#123;&amp;a, &amp;b, &amp;c&#125;;// 数组指针：指向数组的指针int arr[5] = &#123;1, 2, 3, 4, 5&#125;;int (*arrPtr)[5] = &amp;arr;  // 指向整个数组的指针// 访问cout &lt;&lt; (*arrPtr)[2] &lt;&lt; endl;  // 3\n 四、指针与函数\n4.1 指针作为函数参数（传地址）// 通过指针修改实参void swap(int* a, int* b) &#123;    int temp = *a;    *a = *b;    *b = temp;&#125;int main() &#123;    int x = 5, y = 10;    cout &lt;&lt; &quot;交换前: x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl;    swap(&amp;x, &amp;y);    cout &lt;&lt; &quot;交换后: x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl;    return 0;&#125;​4.2 数组作为函数参数// 三种等价形式void printArray(int arr[], int size) &#123;    for (int i = 0; i &lt; size; i++) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;&#125;void printArray(int* arr, int size) &#123;  // 更明确的指针形式    for (int i = 0; i &lt; size; i++) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;&#125;// 使用int main() &#123;    int data[5] = &#123;1, 2, 3, 4, 5&#125;;    printArray(data, 5);  // 数组名自动转换为指针    return 0;&#125;​4.3 函数指针// 函数原型int add(int a, int b) &#123;    return a + b;&#125;int multiply(int a, int b) &#123;    return a * b;&#125;int main() &#123;    // 声明函数指针    int (*funcPtr)(int, int);    // 指向add函数    funcPtr = &amp;add;  // 或直接 funcPtr = add;    cout &lt;&lt; &quot;10 + 5 = &quot; &lt;&lt; funcPtr(10, 5) &lt;&lt; endl;    // 指向multiply函数    funcPtr = multiply;    cout &lt;&lt; &quot;10 * 5 = &quot; &lt;&lt; funcPtr(10, 5) &lt;&lt; endl;    return 0;&#125;\n 五、动态内存管理\n5.1 new和delete操作符// 单个变量的动态分配int* p = new int;     // 分配一个int*p = 42;cout &lt;&lt; *p &lt;&lt; endl;delete p;             // 释放内存p = nullptr;          // 避免野指针// 数组的动态分配int size = 5;int* arr = new int[size];  // 分配数组for (int i = 0; i &lt; size; i++) &#123;    arr[i] = i * 10;&#125;delete[] arr;  // 释放数组arr = nullptr;​5.2 动态二维数组// 创建动态二维数组int rows = 3, cols = 4;int** matrix = new int*[rows];  // 创建行指针数组for (int i = 0; i &lt; rows; i++) &#123;    matrix[i] = new int[cols];  // 为每行创建列数组&#125;// 初始化for (int i = 0; i &lt; rows; i++) &#123;    for (int j = 0; j &lt; cols; j++) &#123;        matrix[i][j] = i * cols + j;    &#125;&#125;// 释放内存（逆序）for (int i = 0; i &lt; rows; i++) &#123;    delete[] matrix[i];&#125;delete[] matrix;matrix = nullptr;\n 六、特殊指针类型\n6.1 void指针（泛型指针）void print(void* data, char type) &#123;    switch(type) &#123;        case &#x27;i&#x27;:            cout &lt;&lt; *((int*)data) &lt;&lt; endl;            break;        case &#x27;f&#x27;:            cout &lt;&lt; *((float*)data) &lt;&lt; endl;            break;        case &#x27;c&#x27;:            cout &lt;&lt; *((char*)data) &lt;&lt; endl;            break;    &#125;&#125;int main() &#123;    int n = 5;    float f = 3.14;    char c = &#x27;A&#x27;;    print(&amp;n, &#x27;i&#x27;);    print(&amp;f, &#x27;f&#x27;);    print(&amp;c, &#x27;c&#x27;);    return 0;&#125;​6.2 const与指针int value = 10;int another = 20;// 指向常量的指针（指针指向的内容不能修改）const int* ptr1 = &amp;value;// *ptr1 = 20;  // 错误！不能通过ptr1修改valueptr1 = &amp;another;  // 但可以改变指针的指向// 常量指针（指针的指向不能修改）int* const ptr2 = &amp;value;*ptr2 = 30;       // 可以修改指向的值// ptr2 = &amp;another;  // 错误！不能改变指针的指向// 指向常量的常量指针const int* const ptr3 = &amp;value;// *ptr3 = 40;        // 错误！// ptr3 = &amp;another;  // 错误！​七、指针操作符 -&gt; 和 * 深度解析* 和 -&gt; 操作符对比1.1 基本概念区分#include &lt;iostream&gt;using namespace std;struct Point &#123;    int x;    int y;    void print() &#123;        cout &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    Point p1 = &#123;10, 20&#125;;    Point* ptr = &amp;p1;    // 两种访问方式的对比    // 1. 使用 . 操作符（对象直接访问）    cout &lt;&lt; &quot;p1.x = &quot; &lt;&lt; p1.x &lt;&lt; endl;      // 10    p1.print();                              // (10, 20)    // 2. 使用 * 和 . 组合（指针解引用后访问）    cout &lt;&lt; &quot;(*ptr).x = &quot; &lt;&lt; (*ptr).x &lt;&lt; endl;  // 10    (*ptr).print();                              // (10, 20)    // 3. 使用 -&gt; 操作符（指针直接访问）    cout &lt;&lt; &quot;ptr-&gt;x = &quot; &lt;&lt; ptr-&gt;x &lt;&lt; endl;      // 10    ptr-&gt;print();                               // (10, 20)    return 0;&#125;​1.2 语法等价关系// 以下三种形式完全等价：ptr-&gt;member;     // 最简洁的指针访问方式(*ptr).member;   // 解引用后使用点操作符(*(ptr)).member; // 更明确的解引用​-&gt; 操作符详解2.1 -&gt; 操作符的工作原理class Student &#123;private:    string name;    int age;public:    Student(string n, int a) : name(n), age(a) &#123;&#125;    void display() &#123;        cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; name &lt;&lt; &quot;, 年龄: &quot; &lt;&lt; age &lt;&lt; endl;    &#125;    void setName(string n) &#123;        name = n;    &#125;    string getName() const &#123;        return name;    &#125;&#125;;int main() &#123;    // 在栈上创建对象    Student s1(&quot;张三&quot;, 20);    s1.display();           // 对象直接使用 .    // 在堆上动态创建对象    Student* s2 = new Student(&quot;李四&quot;, 22);    // 访问成员函数    s2-&gt;display();          // 使用 -&gt;    s2-&gt;setName(&quot;王五&quot;);    cout &lt;&lt; &quot;新名字: &quot; &lt;&lt; s2-&gt;getName() &lt;&lt; endl;    // 访问数据成员（如果public）    // s2-&gt;name;  // 如果name是public才可以    delete s2;  // 记得释放内存    return 0;&#125;​2.2 为什么需要 -&gt; 操作符struct Node &#123;    int data;    Node* next;  // 指向下一个节点的指针    Node(int val) : data(val), next(nullptr) &#123;&#125;&#125;;int main() &#123;    // 创建链表节点    Node* head = new Node(1);    head-&gt;next = new Node(2);    head-&gt;next-&gt;next = new Node(3);  // 链式调用    // 遍历链表    Node* current = head;    while (current != nullptr) &#123;        cout &lt;&lt; current-&gt;data &lt;&lt; &quot; &quot;;        current = current-&gt;next;  // 移动到下一个节点    &#125;    // 对比：如果没有-&gt;操作符，代码会很繁琐    // (*head).next = new Node(2);    // (*(*head).next).next = new Node(3);    return 0;&#125;\n 引用\n 一、引用基础概念\n1.1 什么是引用\n引用是变量的别名，是一个已存在变量的另一个名字。\nint var = 10;int&amp; ref = var;  // ref是var的引用（别名）\n// 值传递 - 创建副本（不修改原数组）void bubbleSort(vector&lt;int&gt; arr) &#123;    // arr 是原数组的副本    // 修改这里的 arr 不会影响 main 中的原数组&#125;// 引用传递 - 直接操作原数组void bubbleSort(vector&lt;int&gt;&amp; arr) &#123;    // arr 是原数组的&quot;别名&quot;    // 修改这里的 arr 会影响 main 中的原数组&#125;\n1.2 引用特性\n· 必须初始化：引用在声明时必须初始化\n· 不能重新绑定：一旦绑定到一个变量，就不能再绑定到其他变量\n· 没有独立内存：引用与被引用变量共享同一内存地址\nint x = 5;int y = 10;int&amp; r1 = x;  // 正确：声明时初始化// int&amp; r2;    // 错误：引用必须初始化r1 = 20;      // 修改x的值为20// r1 = y;    // 不是重新绑定，而是把y的值赋给xcout &lt;&lt; x &lt;&lt; endl;  // 20\n 二、引用声明和初始化\n2.1 基本类型引用\n// 基本类型的引用int a = 42;int&amp; refA = a;         // refA是a的引用const int&amp; constRefA = a;  // 常引用double d = 3.14;double&amp; refD = d;char c = &#x27;A&#x27;;char&amp; refC = c;// 注意：引用类型必须与变量类型匹配// double&amp; refInt = a;  // 错误：类型不匹配\n2.2 数组引用\n// 一维数组引用int arr[5] = &#123;1, 2, 3, 4, 5&#125;;int (&amp;refArr)[5] = arr;  // 引用整个数组// 通过引用访问数组refArr[2] = 30;  // 修改arr[2]cout &lt;&lt; arr[2] &lt;&lt; endl;  // 30// 遍历数组引用for (int i = 0; i &lt; 5; i++) &#123;    cout &lt;&lt; refArr[i] &lt;&lt; &quot; &quot;;&#125;\n2.3 指针的引用\nint x = 100;int* ptr = &amp;x;int*&amp; refPtr = ptr;  // 指针的引用cout &lt;&lt; *ptr &lt;&lt; endl;     // 100cout &lt;&lt; *refPtr &lt;&lt; endl;  // 100，通过引用访问int y = 200;refPtr = &amp;y;  // 通过引用修改指针指向cout &lt;&lt; *ptr &lt;&lt; endl;  // 200\n 三、引用与函数\n3.1 引用作为函数参数（传引用）\n// 通过引用修改实参void increment(int&amp; num) &#123;    num++;&#125;void swap(int&amp; a, int&amp; b) &#123;    int temp = a;    a = b;    b = temp;&#125;int main() &#123;    int x = 5;    cout &lt;&lt; &quot;原始值: &quot; &lt;&lt; x &lt;&lt; endl;  // 5    increment(x);    cout &lt;&lt; &quot;增加后: &quot; &lt;&lt; x &lt;&lt; endl;  // 6    int a = 10, b = 20;    cout &lt;&lt; &quot;交换前: a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; endl;    swap(a, b);    cout &lt;&lt; &quot;交换后: a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; endl;    return 0;&#125;\n3.2 引用作为函数返回值\n// 返回局部变量的引用是危险的！int&amp; badFunction() &#123;    int local = 42;  // 局部变量    return local;    // 危险！返回后local被销毁&#125;// 正确的用法：返回静态变量、全局变量或传入参数的引用int&amp; getElement(int arr[], int index) &#123;    return arr[index];  // 安全：返回数组元素的引用&#125;// 返回静态变量的引用int&amp; getCounter() &#123;    static int counter = 0;  // 静态变量，生命周期贯穿程序    counter++;    return counter;&#125;int main() &#123;    int array[5] = &#123;1, 2, 3, 4, 5&#125;;    // 修改数组元素    getElement(array, 2) = 100;    cout &lt;&lt; array[2] &lt;&lt; endl;  // 100    // 使用返回的引用    int&amp; countRef = getCounter();    cout &lt;&lt; &quot;计数器: &quot; &lt;&lt; countRef &lt;&lt; endl;  // 1    countRef = 50;  // 通过引用修改静态变量    cout &lt;&lt; &quot;修改后: &quot; &lt;&lt; getCounter() &lt;&lt; endl;  // 51    return 0;&#125;\n3.3 常引用（const引用）\n// 常引用：只读引用，不能通过它修改原变量int x = 10;const int&amp; constRef = x;// constRef = 20;  // 错误：不能通过常引用修改x = 20;            // 正确：可以直接修改原变量cout &lt;&lt; constRef &lt;&lt; endl;  // 20// 常引用的优势：可以绑定到临时对象int getValue() &#123;    return 42;&#125;int main() &#123;    // const int&amp; r1 = getValue();  // 正确：可以绑定到临时值    // int&amp; r2 = getValue();        // 错误：非常引用不能绑定到临时值    const int&amp; r = 100;  // 正确：常引用可以绑定到字面量    cout &lt;&lt; r &lt;&lt; endl;   // 100    return 0;&#125;\n 四、引用与指针对比\n4.1 语法对比\nint value = 42;// 指针方式int* ptr = &amp;value;  // 取地址*ptr = 50;          // 解引用修改int x = *ptr;       // 解引用读取// 引用方式int&amp; ref = value;   // 直接绑定ref = 60;           // 直接修改int y = ref;        // 直接读取\n4.2 关键区别\n特性              指针                 引用初始化            可以不初始化           必须初始化重新赋值          可以指向不同变量        不能重新绑定空值              可以为null            ptr 不能为空内存占用          有自己的内存地址        与原始变量共享地址多级              可以有多级指针         只有一级引用运算符            需要*和-&gt;操作符        像普通变量一样使用\n4.3 使用场景对比\n// 场景1：函数参数传递void funcByPointer(int* p) &#123;    if (p != nullptr) &#123;  // 需要检查空指针        *p = 100;    &#125;&#125;void funcByReference(int&amp; r) &#123;    r = 100;  // 无需检查，引用不能为空&#125;// 场景2：返回多个值void getMinMaxByPointer(const int* arr, int size, int* min, int* max) &#123;    if (min != nullptr) *min = arr[0];    if (max != nullptr) *max = arr[0];    // ... 计算逻辑&#125;void getMinMaxByReference(const int* arr, int size, int&amp; min, int&amp; max) &#123;    min = arr[0];    max = arr[0];    // ... 计算逻辑&#125;\n 五、引用高级用法\n5.1 引用与const\n// 四种组合int data = 10;// 1. 非常量引用（可以修改）int&amp; ref1 = data;ref1 = 20;  // 可以修改// 2. 常量引用（只读）const int&amp; ref2 = data;// ref2 = 30;  // 错误：不能通过ref2修改// 3. 对常量的引用（绑定到常量）const int constData = 40;// int&amp; ref3 = constData;  // 错误：不能绑定非常量引用到常量const int&amp; ref4 = constData;  // 正确// 4. 临时对象的引用// int&amp; ref5 = 50;  // 错误：不能绑定非常量引用到字面量const int&amp; ref6 = 50;  // 正确：常引用可以\n5.2 引用在范围for循环中的应用\nvector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;// 值传递：复制每个元素（效率低）for (int num : vec) &#123;    num *= 2;  // 只修改副本&#125;// vec内容不变：1, 2, 3, 4, 5// 引用传递：直接操作元素（效率高）for (int&amp; num : vec) &#123;    num *= 2;  // 修改原元素&#125;// vec内容变为：2, 4, 6, 8, 10// 常引用：只读访问for (const int&amp; num : vec) &#123;    // num *= 2;  // 错误：不能修改    cout &lt;&lt; num &lt;&lt; &quot; &quot;;&#125;\n5.3 右值引用（C++11新特性）\n// 左值引用：绑定到左值（有名字、有地址的对象）int x = 10;int&amp; lref = x;  // 左值引用// 右值引用：绑定到右值（临时对象、字面量）int&amp;&amp; rref1 = 42;         // 字面量是右值int&amp;&amp; rref2 = x + 5;      // 表达式结果是右值// 移动语义：高效转移资源所有权class MyString &#123;private:    char* data;public:    // 移动构造函数    MyString(MyString&amp;&amp; other) noexcept        : data(other.data) &#123;        other.data = nullptr;  // 置空原指针    &#125;    // 移动赋值运算符    MyString&amp; operator=(MyString&amp;&amp; other) noexcept &#123;        if (this != &amp;other) &#123;            delete[] data;            data = other.data;            other.data = nullptr;        &#125;        return *this;    &#125;&#125;;\n 六、引用在类中的应用\n6.1 成员引用\nclass Student &#123;private:    string&amp; nameRef;  // 引用成员public:    // 引用成员必须在构造函数的初始化列表中初始化    Student(string&amp; name) : nameRef(name) &#123;&#125;    void display() const &#123;        cout &lt;&lt; &quot;学生姓名: &quot; &lt;&lt; nameRef &lt;&lt; endl;    &#125;    void rename(string&amp; newName) &#123;        // nameRef = newName;  // 重新绑定？错误！        // 引用不能重新绑定，所以这里实际上不能修改    &#125;&#125;;int main() &#123;    string studentName = &quot;张三&quot;;    Student s(studentName);    s.display();    string newName = &quot;李四&quot;;    // s.rename(newName);  // 不能修改引用绑定    return 0;&#125;\n6.2 返回*this（链式调用）\nclass Calculator &#123;private:    double result;public:    Calculator() : result(0) &#123;&#125;    // 返回引用支持链式调用    Calculator&amp; add(double value) &#123;        result += value;        return *this;  // 返回当前对象的引用    &#125;    Calculator&amp; subtract(double value) &#123;        result -= value;        return *this;    &#125;    Calculator&amp; multiply(double value) &#123;        result *= value;        return *this;    &#125;    double getResult() const &#123;        return result;    &#125;&#125;;int main() &#123;    Calculator calc;    // 链式调用    calc.add(10).subtract(3).multiply(2).add(5);    cout &lt;&lt; &quot;结果: &quot; &lt;&lt; calc.getResult() &lt;&lt; endl;  // 19    return 0;&#125;\n 七、引用常见陷阱\n7.1 返回局部变量的引用\n// 错误示例int&amp; badExample() &#123;    int localVar = 100;  // 局部变量    return localVar;     // 返回局部变量的引用&#125;  // localVar被销毁，返回的引用变成悬空引用int main() &#123;    int&amp; ref = badExample();    // 危险！ref现在指向已销毁的内存    // cout &lt;&lt; ref &lt;&lt; endl;  // 未定义行为    return 0;&#125;\n7.2 引用与指针的混淆\nint x = 10;// 正确的引用用法int&amp; ref = x;// 常见的混淆错误// int&amp; ref = &amp;x;        // 错误：引用不需要取地址// int&amp; ref = *(&amp;x);     // 虽然能编译，但不推荐// 指针和引用的混合使用int* ptr = &amp;x;int&amp; refFromPtr = *ptr;  // 正确：解引用指针得到引用// 但这样更清晰int&amp; refDirect = x;\n7.3 引用数组元素时的越界\nint arr[5] = &#123;1, 2, 3, 4, 5&#125;;// 返回引用时要注意边界检查int&amp; getElement(int index) &#123;    // 危险：没有边界检查    return arr[index];&#125;// 改进版本int&amp; safeGetElement(int index) &#123;    if (index &gt;= 0 &amp;&amp; index &lt; 5) &#123;        return arr[index];    &#125;    // 返回静态变量或抛出异常    static int error = -1;    return error;&#125;\n 递归\n 一、什么是递归？\n函数调用自身，把大问题拆成小问题，小问题再拆成更小的问题…\nvoid func() &#123;    // ...    func();  // 👈 调用自己    // ...&#125;\n\n 二、递归的两个核心要素\n\n终止条件（必须要有！）\n\nif (终止条件) &#123;    return;  // 不再调用自己&#125;\n没有终止条件 = 死循环 → 栈溢出\n\n递归调用（问题规模缩小）\n\nfunc(更小的范围);  // 向终止条件靠近\n\n 三、递归的执行过程\nvoid func(int n) &#123;    if (n == 0) return;  // 终止条件    cout &lt;&lt; &quot;递: &quot; &lt;&lt; n;    func(n - 1);         // 递归调用    cout &lt;&lt; &quot;归: &quot; &lt;&lt; n;&#125;\n调用 func(3)：\n递: 3 → 递: 2 → 递: 1 → 触底                        ← 归: 1 ← 归: 2 ← 归: 3\n阶段 动作  栈状态\n递 向下调用 栈帧增加\n归 向上返回 栈帧释放\n\n 四、递归的核心认知（最难但也最重要）\n✅ 每一层都是独立的函数调用！\nvoid quickSort(arr, 0, 5) &#123;  // 第1层    int pi = partition(...); // pi=2    quickSort(arr, 0, 1);    // 👈 第2层    quickSort(arr, 3, 5);    // 👈 另一第2层&#125;\n    每一层有       是否独立\n\n参数    low, high     独立，值可能相同但互不影响\n局部变量 i, pi         独立，同名但不是同一个\n返回值   给上一层用，不是给下一层\n递归不是代码在重复，是函数的每一层分身各干各的活！\n\n 六、递归 vs 循环\n维度 递归             循环\n本质 函数调用自己    重复执行代码块\n内存 每层新栈帧      共享同一栈帧\n速度 略慢（调用开销）    快\n代码 简洁，符合数学思维  直观\n终止 必须显式条件    条件不成立即止\n适用 树、分治、回溯    线性遍历\n递归能做的循环都能做，但有些问题递归更自然（如快排、二叉树）。\n\n 七、常见误区\n误区1：递归是“代码复用”\n真相：是函数复用，不是代码复用\n误区2：下一层能用上一层的变量\n真相：参数传值，不是共享变量\n误区3：没创建新数组怎么递归\n真相：用指针/索引画圈，不复制数据\nquickSort(arr, low, pi - 1);  // 没创建新数组，只是移动指针！\n误区4：返回值是给自己用\n真相：返回值是给上一层用的！\n\n 八、快排中的递归（完美案例）\nvoid quickSort(vector&lt;int&gt;&amp; arr, int low, int high) &#123;    if (low &lt; high) &#123;                          // 1. 终止条件        int pi = partition(arr, low, high);    // 2. 当前层工作        quickSort(arr, low, pi - 1);           // 3. 递归左半（规模缩小）        quickSort(arr, pi + 1, high);          // 4. 递归右半（规模缩小）    &#125;&#125;\n代码行 作用\nif (low &lt; high) 终止条件：只剩0/1个元素就停\npartition(…) 当前层：归位一个数\nquickSort(…, pi-1) 递归：处理更小的左区间\nquickSort(…, pi+1) 递归：处理更小的右区间\n每层只归位一个数，n个元素需要n层递归（最坏情况）。\n—​\n Struct、Class\n 一、基本概念与区别\n1.1 什么是结构体(struct)和类(class)· 结构体(struct)：用于将不同类型的数据组合成一个复合数据类型· 类(class)：面向对象编程的核心，包含数据和操作数据的方法1.2 主要区别对比表特性                      结构体(struct)                  类(class)默认访问权限               public（公共）                  private（私有）设计思想                  数据聚合                        对象封装典型用途                  简单数据存储、配置参数             复杂对象建模、业务逻辑继承                     支持（但少用）                    支持（面向对象核心）构造函数                  支持                            支持\n 二、结构体(struct)的功能与使用\n2.1 主要功能\n数据打包：            将相关变量组合成一个单元创建自定义数据类型：    定义新的数据类型传递复杂数据：         函数参数可以传递整个结构体\n2.2 使用方式\n// 1. 定义结构体struct Student &#123;    int id;    string name;    int age;&#125;;// 2. 创建结构体变量Student s1;                     // 方式1：默认创建Student s2 = &#123;1001, &quot;张三&quot;, 20&#125;; // 方式2：初始化Student s3&#123;1002, &quot;李四&quot;, 21&#125;;    // 方式3：C++11统一初始化// 3. 访问成员s1.id = 1003;s1.name = &quot;王五&quot;;s1.age = 22;// 4. 作为函数参数void printStudent(Student s) &#123;    cout &lt;&lt; s.name &lt;&lt; &quot; &quot; &lt;&lt; s.age &lt;&lt; &quot;岁&quot;;&#125;\n2.3 何时使用结构体\n· 只有数据，没有方法· 简单的数据记录（如坐标点、颜色）· 配置参数集合· 函数需要返回多个值\n 三、类(class)的功能与使用\n3.1 主要功能\n封装：隐藏内部实现，暴露安全接口数据保护：通过访问控制保护数据安全对象建模：模拟现实世界中的对象代码复用：通过继承和多态实现\n3.2 使用方式\n// 1. 定义类（带访问控制）class BankAccount &#123;private:    // 私有：只能在类内部访问    double balance;    string password;public:     // 公共：外部可以访问    // 构造函数    BankAccount(double initial) &#123;        balance = initial;    &#125;    // 公共方法（接口）    void deposit(double amount) &#123;        if (amount &gt; 0) balance += amount;    &#125;    double getBalance() &#123;        return balance;    &#125;&#125;;// 2. 创建对象BankAccount account(1000.0);  // 调用构造函数// 3. 使用对象account.deposit(500.0);       // 调用公共方法double money = account.getBalance();// 4. 不能直接访问私有成员// account.balance = 10000;   // 错误！balance是私有的\n3.3 访问控制关键字\n· public：任何地方都可以访问· private：只能在类内部访问· protected：类内部和派生类可以访问\n3.4 何时使用类\n· 需要数据隐藏和保护· 有复杂的业务逻辑· 需要继承和多态· 对象有状态和行为· 需要控制数据的访问方式\n 四、实际选择指南\n4.1 选择结构体的场景\n情况：定义二维坐标点选择：struct Point &#123; double x; double y; &#125;理由：只有数据，没有复杂逻辑情况：配置文件参数选择：struct Config &#123; int width; int height; string theme; &#125;理由：简单数据聚合情况：函数返回多个值选择：struct Result &#123; bool success; string message; int code; &#125;理由：打包返回数据\n4.2 选择类的场景\n情况：银行账户选择：class BankAccount &#123; private余额; public存款/取款方法 &#125;理由：需要保护余额，控制访问方式情况：游戏角色选择：class Character &#123; private生命值; public攻击/防御方法 &#125;理由：有状态和行为，需要封装情况：数据库连接选择：class Database &#123; private连接句柄; public查询/关闭方法 &#125;理由：需要资源管理，隐藏实现细节\n vector、array\n 一、Array（数组）基础\n1.1 数组是什么\n数组是固定大小、连续内存存储的相同类型元素的集合。\n1.2 两种数组类型\n传统C风格数组\n// 声明和初始化int arr1[5];                    // 未初始化，值是随机的int arr2[5] = &#123;1, 2, 3&#125;;        // 部分初始化，后面自动补0int arr3[] = &#123;1, 2, 3, 4, 5&#125;;   // 自动推断大小为5int arr4[3] = &#123;0&#125;;              // 全部初始化为0// 二维数组int matrix[2][3] = &#123;    &#123;1, 2, 3&#125;,    &#123;4, 5, 6&#125;&#125;;// 使用arr2[0] = 10;                   // 修改第一个元素int x = arr2[1];                // 读取第二个元素\nC++11 std::array（推荐）\n#include &lt;array&gt;std::array&lt;int, 5&gt; arr1;                 // 5个int，默认初始化为0std::array&lt;int, 3&gt; arr2 = &#123;1, 2, 3&#125;;     // 初始化列表auto arr3 = std::array&lt;int, 4&gt;&#123;1, 2, 3, 4&#125;;  // C++11统一初始化// 有更多成员函数int size = arr1.size();                   // 获取大小bool empty = arr1.empty();                // 判断是否为空int first = arr1.front();                 // 第一个元素int last = arr1.back();                   // 最后一个元素int val = arr1.at(2);                     // 带边界检查的访问\n 二、Vector（向量）基础\n2.1 Vector是什么\nVector是动态数组，大小可以运行时改变，自动管理内存。\n2.2 Vector基本使用\n#include &lt;vector&gt;#include &lt;iostream&gt;// 创建vectorstd::vector&lt;int&gt; vec1;                    // 空vectorstd::vector&lt;int&gt; vec2(5);                 // 5个元素，都初始化为0std::vector&lt;int&gt; vec3(5, 10);             // 5个元素，都初始化为10std::vector&lt;int&gt; vec4 = &#123;1, 2, 3, 4, 5&#125;;  // 初始化列表std::vector&lt;int&gt; vec5(vec4);              // 拷贝构造// 添加元素vec1.push_back(10);      // 在末尾添加10vec1.push_back(20);      // 在末尾添加20vec1.push_back(30);      // 在末尾添加30// 访问元素int first = vec1[0];     // 通过下标访问（无边界检查）int second = vec1.at(1); // 通过at访问（有边界检查，越界会抛出异常）// 删除元素vec1.pop_back();         // 删除最后一个元素\n 三、核心区别对比\n3.1 内存管理方式\n数组（Array）：栈上： [元素][元素][元素]...（直接存储）大小在编译时确定向量（Vector）：栈上： [指针][大小][容量]        ↓堆上： [元素][元素][元素]...\n3.2 大小变化能力\n// Array：固定大小int arr[5];  // 永远只有5个元素// arr[5] = 10;  // 错误！数组越界// Vector：动态大小std::vector&lt;int&gt; vec;vec.push_back(1);  // 大小：1vec.push_back(2);  // 大小：2vec.push_back(3);  // 大小：3vec.pop_back();    // 大小：2\n 四、常用操作详解\n4.1 Vector的容量管理\nstd::vector&lt;int&gt; vec;// 容量相关vec.size();        // 当前元素个数vec.capacity();    // 当前分配的内存能容纳的元素数vec.empty();       // 是否为空vec.reserve(100);  // 预留100个元素的空间（避免多次扩容）// 调整大小vec.resize(10);    // 调整为10个元素，新增的用0填充vec.resize(15, 5); // 调整为15个元素，新增的用5填充vec.resize(3);     // 调整为3个元素，删除多余的元素\n4.2 遍历方式对比\n// 两种结构都支持的遍历方式：// 1. 下标遍历（最常用）for (size_t i = 0; i &lt; vec.size(); i++) &#123;    std::cout &lt;&lt; vec[i] &lt;&lt; &quot; &quot;;&#125;// 2. 范围for循环（C++11）for (int num : vec) &#123;    std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;&#125;// 3. 迭代器遍历for (auto it = vec.begin(); it != vec.end(); it++) &#123;    std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;\n4.3 插入和删除\nstd::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;// 在指定位置插入vec.insert(vec.begin() + 2, 100);  // 在第3个位置插入100// 结果：&#123;1, 2, 100, 3, 4, 5&#125;// 删除指定位置vec.erase(vec.begin() + 1);        // 删除第2个元素// 结果：&#123;1, 100, 3, 4, 5&#125;// 删除指定范围vec.erase(vec.begin() + 1, vec.begin() + 3);// 结果：&#123;1, 4, 5&#125;// 清空所有vec.clear();  // 大小变为0，但容量不变\n 左值和右值\n 一、基本概念\n1.1 左值 vs 右值\n左值（Lvalue）：像“左手拿的容器”· 有名字的变量· 有明确的内存地址· 可以取地址（&amp;）· 可以放在赋值语句左边右值（Rvalue）：像“右手拿的值”· 临时的、一次性的值· 没有名字· 通常不能取地址· 只能放在赋值语句右边\n1.2 简单例子\nint a = 10;      // a是左值（容器），10是右值（值）int b = a;       // b是左值，a是左值（但这里a被当作右值使用）a = 5;           // ✅ 正确：a是左值，可以放左边5 = a;           // ❌ 错误：5是右值，不能放左边(a + 1) = 5;     // ❌ 错误：(a+1)是右值（计算结果）\n 二、分类详解\n2.1 什么是左值？\n左值特征：有身份、有地址、可持久\nint x = 5;              // x是左值int arr[10];            // arr是左值int* ptr = &amp;x;          // ptr是左值string str = &quot;hello&quot;;   // str是左值// 验证：可以取地址&amp;x;     // ✅ 可以&amp;arr;   // ✅ 可以&amp;str;   // ✅ 可以\n2.2 什么是右值？\n右值特征：临时的、一次性的、用完即弃\n// 常见的右值：5;                     // 字面量（纯右值）x + 3;                 // 表达式结果（纯右值）func();                // 函数返回值（纯右值）std::move(x);          // 将亡值（xvalue）string(&quot;hello&quot;);       // 临时对象// 验证：不能取地址&amp;5;                    // ❌ 错误&amp;(x + 3);              // ❌ 错误&amp;func();               // ❌ 错误\n 三、实际代码判断\n3.1 左值例子\nint main() &#123;    // 这些都是左值    int a = 10;                // ✅ a是左值    int&amp; ref = a;              // ✅ ref是左值引用    const int c = 20;          // ✅ c是左值（常量左值）    int arr[5] = &#123;1,2,3,4,5&#125;;  // ✅ arr是左值    // 左值可以放左边    a = 100;                   // ✅    arr[0] = 10;              // ✅    // 左值可以取地址    int* p1 = &amp;a;             // ✅    int* p2 = &amp;arr[0];        // ✅    return 0;&#125;\n3.2 右值例子\nint getNumber() &#123;    return 42;&#125;int main() &#123;    int x = 5;    // 这些都是右值    int a = 10;             // 10是右值（字面量）    int b = x + 3;          // (x+3)是右值（表达式）    int c = getNumber();    // getNumber()是右值    // 典型的右值位置（只能放右边）    x = 20;                 // 20是右值    x = x * 2;              // (x*2)是右值    // 下面这些都是错误的    // 10 = x;              // ❌ 错误：10是右值    // (x+1) = 10;          // ❌ 错误：(x+1)是右值    // getNumber() = 100;   // ❌ 错误：函数返回值是右值    return 0;&#125;\n 四、左值引用 vs 右值引用\n4.1 左值引用（&amp;）\nint a = 10;int&amp; ref1 = a;     // ✅ 正确：左值引用绑定到左值// int&amp; ref2 = 5;  // ❌ 错误：左值引用不能绑定到右值// int&amp; ref3 = a+1; // ❌ 错误：不能绑定到表达式结果const int&amp; ref4 = 5;  // ✅ 正确：const左值引用可以绑定到右值const int&amp; ref5 = a+2; // ✅ 正确\n4.2 右值引用（&amp;&amp;，C++11新特性）\nint a = 10;int&amp;&amp; rref1 = 5;           // ✅ 正确：右值引用绑定到字面量int&amp;&amp; rref2 = a + 3;       // ✅ 正确：绑定到表达式结果int&amp;&amp; rref3 = std::move(a);// ✅ 正确：将左值转为右值引用// int&amp;&amp; rref4 = a;        // ❌ 错误：右值引用不能直接绑定到左值\n 五、移动语义（为什么要有右值引用？）\n5.1 问题的由来\nclass BigObject &#123;    int* data;  // 大量数据public:    // 传统拷贝：深拷贝，性能差    BigObject(const BigObject&amp; other) &#123;        data = new int[100];        // 复制所有数据... 很慢！    &#125;&#125;;BigObject createObject() &#123;    BigObject obj;    // ... 填充数据    return obj;  // 这里会发生拷贝！&#125;\n5.2 解决方案：移动语义\nclass BigObject &#123;    int* data;public:    // 移动构造函数：&quot;偷取&quot;资源，不复制    BigObject(BigObject&amp;&amp; other) noexcept &#123;        data = other.data;    // 直接接管指针        other.data = nullptr; // 原对象置空        // 没有复制数据！性能极高    &#125;    // 移动赋值运算符    BigObject&amp; operator=(BigObject&amp;&amp; other) noexcept &#123;        delete[] data;        // 释放自己的资源        data = other.data;    // 接管别人的资源        other.data = nullptr;        return *this;    &#125;&#125;;BigObject obj1;BigObject obj2 = std::move(obj1);  // 调用移动构造函数，高效！\n 六、std::move 的作用\n6.1 std::move 是什么？\n· 不是移动，而是类型转换· 将左值转换为右值引用· 告诉编译器：&quot;这个对象可以被移动&quot;\nstring str1 = &quot;Hello&quot;;string str2 = &quot;World&quot;;// 传统拷贝（效率低）string str3 = str1;  // 调用拷贝构造函数，复制所有字符// 使用移动（效率高）string str4 = std::move(str1);  // 调用移动构造函数// 现在：str1变成空字符串，str4得到&quot;Hello&quot;// 没有字符复制，只是指针转移\n 七、实际应用场景\n7.1 什么时候考虑右值？\n✅ 使用右值引用和移动语义的场景：1. 函数返回大对象时2. 容器插入元素时3. 实现资源管理类（智能指针、字符串等）4. 避免不必要的深拷贝\n 八、快速判断技巧\n8.1 如何判断左值右值？\n问自己三个问题：能不能取地址？ → 能：左值，不能：可能是右值能不能放赋值左边？ → 能：左值，不能：右值是临时的吗？ → 是：右值，不是：左值\n8.2 简单判断口诀\n有名字 → 通常是左值字面量 → 肯定是右值表达式 → 通常是右值函数返回非引用 → 右值std::move()的结果 → 右值引用\n 退化\n 一、什么是类型退化？\n类型退化是C++中某些类型在特定上下文中自动丢失部分类型信息，变为更简单类型的过程。\n​\n 二、退化的三种主要情况\n2.1 数组退化为指针（最常见）\n// 定义一个数组int arr[5] = &#123;1, 2, 3, 4, 5&#125;;// 退化发生：数组 → 指针int* ptr = arr;  // arr从 int[5] 退化为 int*// 发生了什么变化？// 1. 丢失了数组大小信息（5 这个信息没了）// 2. 丢失了&quot;我是数组&quot;这个信息// 3. 变成了普通的指针// 验证：cout &lt;&lt; sizeof(arr) &lt;&lt; endl;    // 输出 20 (5*4)cout &lt;&lt; sizeof(ptr) &lt;&lt; endl;    // 输出 8 (指针大小)// 看！大小信息丢失了\n​\n2.2 函数退化为函数指针\n// 定义一个函数void sayHello() &#123;    cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; endl;&#125;// 退化发生：函数 → 函数指针void (*funcPtr)() = sayHello;  // sayHello 从 void() 退化为 void(*)()// 调用方式看起来一样，但类型变了sayHello();     // 直接调用函数funcPtr();      // 通过指针调用函数// 关键区别：函数类型包含更多信息，函数指针只包含地址\n​\n2.3 顶层const/volatile被丢弃\n// 顶层const：修饰变量本身const int a = 10;        // a本身是const// 在类型推导中，顶层const会被丢弃// 例如模板参数推导时：template&lt;typename T&gt;void func(T param) &#123;    // 如果传入const int，T会被推导为int，不是const int&#125;func(a);  // T被推导为int，const被丢弃了\n​\n 三、数组退化的详细分析\n3.1 什么时候发生数组退化？\nint arr[5];// ✅ 会发生退化的场景：// 1. 赋值给指针int* p1 = arr;              // 退化// 2. 作为函数参数传递void func(int param[]) &#123;    // 这里param已经是int*了    // 无法知道数组大小！&#125;// 3. 参与表达式int* p2 = arr + 1;          // 退化bool same = (arr == p1);    // 退化后比较// ❌ 不会发生退化的场景：// 1. 使用sizeofint size = sizeof(arr);     // 不退化，得到20// 2. 使用取地址&amp;int (*p3)[5] = &amp;arr;        // 不退化，得到int(*)[5]// 3. 用decltypedecltype(arr) arr2;         // 不退化，类型是int[5]\n​\n3.2 退化带来的问题\n#include &lt;iostream&gt;using namespace std;// 问题1：无法知道数组大小void printArray(int arr[]) &#123;  // 实际上是 int* arr    // 错误！这得到的是指针大小，不是数组大小    // int size = sizeof(arr) / sizeof(arr[0]); // 错误！    // 只能额外传递大小参数&#125;// 问题2：二维数组退化更复杂void printMatrix(int matrix[][3], int rows) &#123;    // matrix从int[][3]退化为int(*)[3]    // 至少还保留了列数信息&#125;int main() &#123;    int arr[5] = &#123;1, 2, 3, 4, 5&#125;;    int matrix[2][3] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;;    printArray(arr);      // arr退化为int*    printMatrix(matrix, 2); // matrix退化为int(*)[3]    return 0;&#125;\n​\n 四、如何防止退化？\n4.1 使用引用（最佳方法）\n// 方法1：使用引用传递数组\ntemplate&lt;typename T, size_t N&gt;void printArray(T (&amp;arr)[N]) &#123;  // 引用，不退化！    cout &lt;&lt; &quot;数组大小: &quot; &lt;&lt; N &lt;&lt; endl;    for (size_t i = 0; i &lt; N; i++) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    int arr[] = &#123;1, 2, 3, 4, 5&#125;;    printArray(arr);  // 不退化，N自动推导为5    return 0;&#125;\n​\n4.2 使用std::array（现代C++）\n#include &lt;array&gt;#include &lt;iostream&gt;void processArray(std::array&lt;int, 5&gt;&amp; arr) &#123;    // std::array不会退化！    cout &lt;&lt; &quot;大小: &quot; &lt;&lt; arr.size() &lt;&lt; endl;    // 所有信息都保留&#125;int main() &#123;    std::array&lt;int, 5&gt; arr = &#123;1, 2, 3, 4, 5&#125;;    processArray(arr);    return 0;&#125;\n​\n4.3 使用指针+大小组组\n// 虽然退化，但可以通过传递大小来弥补void process(int* data, size_t size) &#123;    for (size_t i = 0; i &lt; size; i++) &#123;        cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;    &#125;&#125;int main() &#123;    int arr[5] = &#123;1, 2, 3, 4, 5&#125;;    process(arr, sizeof(arr)/sizeof(arr[0]));    return 0;&#125;\n​\n五、函数退化的细节\n5.1 函数什么时候退化？\n#include &lt;iostream&gt;using namespace std;int add(int a, int b) &#123;    return a + b;&#125;int main() &#123;    // 函数名单独使用时会退化    int (*funcPtr)(int, int) = add;  // add退化为函数指针    // 这些情况都会退化：    // 1. 赋值    // 2. 作为参数传递    // 3. 初始化变量    // 这些情况不会退化：    // 1. 取地址&amp;    int (*funcPtr2)(int, int) = &amp;add;  // 明确取地址    // 2. 函数引用    int (&amp;funcRef)(int, int) = add;    // 引用，不退化    // 调用方式都相同    cout &lt;&lt; add(3, 4) &lt;&lt; endl;         // 7    cout &lt;&lt; funcPtr(3, 4) &lt;&lt; endl;     // 7    cout &lt;&lt; funcRef(3, 4) &lt;&lt; endl;     // 7    return 0;&#125;\n 强制类型转换\n 一、为什么需要强制类型转换？\n1.1 问题背景\ndouble pi = 3.14159;int number = pi;  // 隐式转换：3（小数部分丢失）// 但是有些转换编译器不允许void* ptr = &amp;pi;// int* intPtr = ptr;  // ❌ 错误：不能隐式转换\n 二、static_cast：最常用的转换\n2.1 基本用法\n// 1. 数值类型转换（最常用）double pi = 3.14159;int a = static_cast&lt;int&gt;(pi);  // 3（去掉小数）float f = 2.5f;int b = static_cast&lt;int&gt;(f);   // 2// 2. 相关指针类型转换class Base &#123;&#125;;class Derived : public Base &#123;&#125;;Derived d;Base* basePtr = &amp;d;  // 向上转换：安全，可以隐式Base* b2 = new Base();// Derived* d2 = b2;  // ❌ 错误：不能隐式向下转换Derived* d2 = static_cast&lt;Derived*&gt;(b2);  // ✅ 但危险！// 3. void* 转换int x = 100;void* vptr = &amp;x;int* iptr = static_cast&lt;int*&gt;(vptr);  // ✅\n2.2 何时使用static_cast？\n✅ 适合的场景：1. 基本数值类型转换2. 指针的向上转换（子类→父类）3. 从void*转回具体类型4. 枚举和整数互转5. 显式调用单参数构造函数❌ 不适合的场景：1. 不相关类型的指针转换2. 去掉const（用const_cast）3. 运行时类型检查（用dynamic_cast）\n 三、dynamic_cast：安全的类型转换\n3.1 只能用于多态类型\n#include &lt;iostream&gt;using namespace std;class Animal &#123;public:    virtual ~Animal() &#123;&#125;  // 必须有虚函数！&#125;;class Dog : public Animal &#123;public:    void bark() &#123; cout &lt;&lt; &quot;汪汪！&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal &#123;public:    void meow() &#123; cout &lt;&lt; &quot;喵喵！&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123;    Animal* animal = new Dog();    // 尝试转换为Dog    Dog* dog = dynamic_cast&lt;Dog*&gt;(animal);    if (dog != nullptr) &#123;        dog-&gt;bark();  // 转换成功    &#125; else &#123;        cout &lt;&lt; &quot;不是狗&quot; &lt;&lt; endl;    &#125;    // 尝试转换为Cat（会失败）    Cat* cat = dynamic_cast&lt;Cat*&gt;(animal);    if (cat == nullptr) &#123;        cout &lt;&lt; &quot;转换失败：不是猫&quot; &lt;&lt; endl;    &#125;    delete animal;    return 0;&#125;\n3.2 特点总结\n运行时检查：转换失败返回nullptr（指针）或抛异常（引用）需要虚函数：类必须有虚函数表性能开销：比static_cast慢只能用于指针/引用\n 四、const_cast：修改常量性\n4.1 基本用法\n// 1. 去掉constconst int a = 10;const int* ptr1 = &amp;a;int* ptr2 = const_cast&lt;int*&gt;(ptr1);  // 去掉const// *ptr2 = 20;  // ❌ 危险！未定义行为（a是真正的const）// 2. 修改volatilevolatile int b = 30;int* ptr3 = const_cast&lt;int*&gt;(&amp;b);  // 去掉volatile// 3. 实际有用场景：调用老式APIvoid oldAPI(char* str) &#123;    // 这个函数修改字符串，但不该修改&#125;void modernCode() &#123;    const char* msg = &quot;Hello&quot;;    // oldAPI(msg);  // ❌ 错误：参数不匹配    oldAPI(const_cast&lt;char*&gt;(msg));  // ✅ 但危险！&#125;\n4.2 重要警告！\nconst int a = 100;          // 真正的常量（可能在只读内存）const int* p1 = &amp;a;int* p2 = const_cast&lt;int*&gt;(p1);*p2 = 200;                  // ❌ 未定义行为！可能崩溃// 安全的情况：int b = 100;                // 非常量const int* p3 = &amp;b;         // 只是承诺不通过p3修改int* p4 = const_cast&lt;int*&gt;(p3);*p4 = 200;                  // ✅ 安全！b本来就是变量\n 五、reinterpret_cast：最危险的转换\n5.1 重新解释内存\n#include &lt;iostream&gt;using namespace std;int main() &#123;    // 1. 指针↔整数（平台相关）    int x = 0x12345678;    int* ptr = &amp;x;    uintptr_t address = reinterpret_cast&lt;uintptr_t&gt;(ptr);    cout &lt;&lt; hex &lt;&lt; &quot;地址: 0x&quot; &lt;&lt; address &lt;&lt; endl;    // 2. 不同类型指针转换    float f = 3.14f;    int* intPtr = reinterpret_cast&lt;int*&gt;(&amp;f);    cout &lt;&lt; &quot;浮点数内存表示: 0x&quot; &lt;&lt; *intPtr &lt;&lt; endl;    // 3. 函数指针转换    void (*funcPtr)() = reinterpret_cast&lt;void(*)()&gt;(0x400000);    // 极少使用！    return 0;&#125;\n5.2 使用场景（极少！）\nreinterpret_cast 只应在以下情况使用：1. 底层系统编程2. 序列化/反序列化3. 与硬件交互4. 实现内存池等特殊数据结构普通应用开发中几乎永远不要用！\n new、delete\n 一、基本概念：动态内存管理\n为什么需要 new/delete？\n// 问题：编译时不知道需要多少内存int size;cout &lt;&lt; &quot;需要多少学生？&quot;;cin &gt;&gt; size;  // 用户运行时输入// ❌ 这样不行：int students[size];// 因为size在编译时未知// ✅ 这样可以：动态分配int* students = new int[size];\n ​\n与普通变量的区别\n栈内存（自动）             vs   堆内存（手动）\nint x;                          int* p = new int;\n\n自动分配                     - 手动分配\n函数结束自动释放             - 必须手动释放\n大小有限                     - 大小很大（GB级）\n分配速度快                   - 分配速度慢\n\n​\n 二、new 的基本用法\n分配单个变量// 语法：类型* 指针 = new 类型;int* p1 = new int;        // 分配一个int，不初始化（随机值）int* p2 = new int(42);    // 分配并初始化为42double* p3 = new double(3.14);// 使用*p1 = 100;cout &lt;&lt; *p2 &lt;&lt; endl;  // 42cout &lt;&lt; *p3 &lt;&lt; endl;  // 3.14​分配数组// 语法：类型* 指针 = new 类型[大小];int* arr1 = new int[5];      // 5个int，不初始化int* arr2 = new int[5]();    // 5个int，初始化为0int* arr3 = new int[5]&#123;1,2,3&#125;; // 5个int，前3个初始化// 二维数组int rows = 3, cols = 4;int** matrix = new int*[rows];  // 先分配行指针for (int i = 0; i &lt; rows; i++) &#123;    matrix[i] = new int[cols];  // 每行分配列&#125;// 使用arr1[0] = 10;matrix[0][0] = 100;​ 分配对象class Student &#123;public:    string name;    int age;    Student(string n = &quot;&quot;, int a = 0)        : name(n), age(a) &#123;        cout &lt;&lt; &quot;构造函数&quot; &lt;&lt; endl;    &#125;    ~Student() &#123;        cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;    &#125;&#125;;// 分配单个对象Student* s1 = new Student;           // 默认构造函数Student* s2 = new Student(&quot;张三&quot;, 20); // 带参数构造// 分配对象数组Student* class1 = new Student[3];    // 调用3次构造函数Student* class2 = new Student[3]&#123;    Student(&quot;李四&quot;, 21),    Student(&quot;王五&quot;, 22),    Student(&quot;赵六&quot;, 23)&#125;;\n​\n 三、delete 的基本用法\n释放单个变量int* p = new int(100);// 使用 p...delete p;      // 释放内存p = nullptr;   // 好习惯：防止悬空指针// ❌ 常见错误：// delete p; delete p;  // 双重释放：崩溃// int x = 10; delete &amp;x;  // 释放栈内存：崩溃​释放数组int* arr = new int[100];// 使用数组...delete[] arr;    // 注意：必须有 []arr = nullptr;// ❌ 错误写法：// delete arr;   // 只释放第一个元素，内存泄漏！​释放对象Student* s = new Student(&quot;张三&quot;, 20);// 使用对象...delete s;        // 调用析构函数，释放内存s = nullptr;Student* students = new Student[5];// 使用对象数组...delete[] students;  // 调用5次析构函数students = nullptr;​释放二维数组int rows = 3;int** matrix = new int*[rows];for (int i = 0; i &lt; rows; i++) &#123;    matrix[i] = new int[4];&#125;// 使用...// 释放：先释放每行，再释放行指针数组for (int i = 0; i &lt; rows; i++) &#123;    delete[] matrix[i];&#125;delete[] matrix;matrix = nullptr;\n​\n 四、常见错误与陷阱\n内存泄漏（忘记delete）void leakMemory() &#123;    int* p = new int[1000];    // 忘记 delete[] p;    // 每次调用泄漏1000*4字节&#125;void noLeak() &#123;    int* p = new int[1000];    // 使用...    delete[] p;  // ✅ 正确释放&#125;​悬空指针（使用已释放的内存）int* p = new int(100);delete p;        // 内存已释放// p = nullptr;  // 应该加上这句cout &lt;&lt; *p &lt;&lt; endl;  // ❌ 危险！访问已释放内存*p = 200;            // ❌ 可能导致崩溃​ 野指针（未初始化的指针）int* p;  // 野指针，指向随机地址// cout &lt;&lt; *p &lt;&lt; endl;  // ❌ 危险！// *p = 100;            // ❌ 可能破坏其他数据// ✅ 正确做法：int* p = nullptr;  // 初始化为空if (p != nullptr) &#123;    *p = 100;      // 安全访问&#125;​数组越界int* arr = new int[5];for (int i = 0; i &lt;= 5; i++) &#123;  // ❌ 越界！    arr[i] = i * 10;&#125;delete[] arr;// 可能破坏堆内存管理结构，导致崩溃\n​​\n 悬空指针问题\ndelete后的状态：int *ptr = new int(100);delete ptr;  // 释放堆内存// 现在：// ptr值不变（还是那个地址）// 但地址对应的内存已释放// ptr成为&quot;悬空指针&quot;​危险操作：*ptr = 200;    // ❌ Use-After-Free（访问已释放内存）delete ptr;    // ❌ Double Free（二次释放）​解决方案：delete ptr;ptr = nullptr;  // ✅ 立即置空，避免悬空指针\n string字符串\n 一、string 是什么？为什么重要？\n1.1 string vs C风格字符串\n// ❌ C风格字符串（麻烦、危险）char cstr1[100] = &quot;Hello&quot;;      // 固定大小，可能越界char* cstr2 = new char[100];     // 手动管理内存strcpy(cstr2, &quot;World&quot;);          // 可能缓冲区溢出// 需要记得 delete[] cstr2;// ✅ C++ string（安全、方便）#include &lt;string&gt;using std::string;string str1 = &quot;Hello&quot;;           // 自动管理内存string str2(&quot;World&quot;);            // 各种初始化方式// 无需手动管理内存！不会缓冲区溢出！\n​\n 二、string 基本操作\n2.1 创建和初始化\n// 多种初始化方式string s1;                    // 空字符串 &quot;&quot;string s2(&quot;Hello&quot;);          // 从C字符串初始化string s3 = &quot;World&quot;;         // 赋值初始化string s4(5, &#x27;A&#x27;);           // &quot;AAAAA&quot;（5个A）string s5(s2);               // 拷贝构造 &quot;Hello&quot;string s6(s2, 1, 3);         // &quot;ell&quot;（从位置1取3个字符）// C++11统一初始化string s7&#123;&quot;C++11&quot;&#125;;string s8 = &#123;&quot;Modern&quot;&#125;;\n​\n2.2 字符串连接\nstring s1 = &quot;Hello&quot;;string s2 = &quot;World&quot;;// 方法1：+ 运算符string s3 = s1 + &quot; &quot; + s2;      // &quot;Hello World&quot;string s4 = s1 + &quot;, &quot; + s2 + &quot;!&quot;; // &quot;Hello, World!&quot;// 方法2：+= 运算符s1 += &quot; &quot;;     // s1变成 &quot;Hello &quot;s1 += s2;      // s1变成 &quot;Hello World&quot;// 方法3：append()方法string s5 = &quot;Hello&quot;;s5.append(&quot; &quot;).append(&quot;World&quot;);  // &quot;Hello World&quot;s5.append(3, &#x27;!&#x27;);               // &quot;Hello World!!!&quot;\n​\n 三、字符串访问和修改\n3.1 访问字符\nstring str = &quot;Hello World&quot;;// 方法1：[] 运算符（不检查边界）char c1 = str[0];      // &#x27;H&#x27;str[6] = &#x27;w&#x27;;          // 修改为 &quot;Hello world&quot;// 方法2：at() 方法（检查边界，越界抛异常）char c2 = str.at(1);   // &#x27;e&#x27;// char c3 = str.at(100);  // 抛出 std::out_of_range// 方法3：front() 和 back()char first = str.front();  // &#x27;H&#x27;char last = str.back();    // &#x27;d&#x27;// 遍历字符串for (size_t i = 0; i &lt; str.size(); i++) &#123;    cout &lt;&lt; str[i];&#125;for (char ch : str) &#123;      // C++11范围for循环    cout &lt;&lt; ch;&#125;\n​\n3.2 修改字符串\nstring str = &quot;Hello&quot;;// 1. assign() - 替换整个字符串str.assign(&quot;World&quot;);       // &quot;World&quot;str.assign(3, &#x27;X&#x27;);        // &quot;XXX&quot;// 2. insert() - 插入str = &quot;Hello&quot;;str.insert(5, &quot; World&quot;);   // &quot;Hello World&quot;str.insert(0, 1, &#x27;!&#x27;);     // &quot;!Hello World&quot;// 3. erase() - 删除str.erase(0, 1);           // &quot;Hello World&quot;（删掉!）str.erase(5);              // &quot;Hello&quot;（从位置5删到结尾）str.erase();               // 清空字符串// 4. replace() - 替换部分str = &quot;Hello World&quot;;str.replace(6, 5, &quot;C++&quot;);  // &quot;Hello C++&quot;\n​\n 四、字符串查询操作\n4.1 查找子串\nstring text = &quot;Hello World, Hello C++&quot;;// 1. find() - 从左往右找size_t pos1 = text.find(&quot;Hello&quot;);     // 0size_t pos2 = text.find(&quot;Hello&quot;, 1);  // 13（从位置1开始找）// 2. rfind() - 从右往左找size_t pos3 = text.rfind(&quot;Hello&quot;);    // 13（最后一个）// 3. find_first_of() - 找任意匹配字符size_t pos4 = text.find_first_of(&quot; ,&quot;);  // 5（找到空格）// 4. find_first_not_of() - 找不匹配的size_t pos5 = text.find_first_not_of(&quot;Helo &quot;);  // 6（找到W）// 找不到返回 string::nposif (text.find(&quot;Java&quot;) == string::npos) &#123;    cout &lt;&lt; &quot;没有找到Java&quot; &lt;&lt; endl;&#125;\n​\n4.2 字符串比较\nstring s1 = &quot;apple&quot;;string s2 = &quot;banana&quot;;string s3 = &quot;Apple&quot;;  // 注意大小写// 1. compare() 方法if (s1.compare(s2) &lt; 0) &#123;    cout &lt;&lt; s1 &lt;&lt; &quot; &lt; &quot; &lt;&lt; s2 &lt;&lt; endl;  // apple &lt; banana&#125;if (s1.compare(0, 2, &quot;ap&quot;) == 0) &#123;    cout &lt;&lt; &quot;前两个字符是 ap&quot; &lt;&lt; endl;&#125;// 2. 关系运算符（更直观）if (s1 &lt; s2) &#123;        // true    cout &lt;&lt; &quot;apple 在 banana 前面&quot; &lt;&lt; endl;&#125;if (s1 == &quot;apple&quot;) &#123;  // true    cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;&#125;// 注意：区分大小写if (s1 == s3) &#123;       // false    cout &lt;&lt; &quot;不会执行&quot; &lt;&lt; endl;&#125;\n​\n 五、字符串容量和内存\n5.1 容量管理\nstring str;// 1. size() / length() - 当前字符数str = &quot;Hello&quot;;cout &lt;&lt; str.size() &lt;&lt; endl;     // 5cout &lt;&lt; str.length() &lt;&lt; endl;   // 5// 2. capacity() - 分配的内存容量cout &lt;&lt; str.capacity() &lt;&lt; endl; // 可能是15（不同编译器不同）// 3. reserve() - 预分配内存str.reserve(100);               // 提前分配100字符空间// 避免多次重新分配，提高性能// 4. shrink_to_fit() - 释放多余内存str.shrink_to_fit();            // C++11，减少内存使用// 5. empty() - 是否为空if (str.empty()) &#123;    cout &lt;&lt; &quot;字符串为空&quot; &lt;&lt; endl;&#125;\n​\n 六、string 与数值转换\n6.1 C++11 数值转换\n// 1. string → 数值string s1 = &quot;123&quot;;string s2 = &quot;3.14&quot;;string s3 = &quot;100&quot;;int i = std::stoi(s1);          // 123double d = std::stod(s2);       // 3.14long l = std::stol(s3);         // 100size_t pos;int i2 = std::stoi(&quot;42abc&quot;, &amp;pos);  // i2=42, pos=2// 2. 数值 → stringstring s4 = std::to_string(123);        // &quot;123&quot;string s5 = std::to_string(3.14159);    // &quot;3.141590&quot;string s6 = std::to_string(true);       // &quot;1&quot;// 3. 格式化（C++20有format，之前用stringstream）#include &lt;sstream&gt;std::stringstream ss;ss &lt;&lt; &quot;数值: &quot; &lt;&lt; 42 &lt;&lt; &quot;, 浮点数: &quot; &lt;&lt; 3.14;string result = ss.str();\n​\n 七、实用函数和算法\n7.1 大小写转换\nstring str = &quot;Hello World&quot;;// 1. 转小写std::transform(str.begin(), str.end(), str.begin(),              [](unsigned char c)&#123; return std::tolower(c); &#125;);// &quot;hello world&quot;// 2. 转大写std::transform(str.begin(), str.end(), str.begin(),              [](unsigned char c)&#123; return std::toupper(c); &#125;);// &quot;HELLO WORLD&quot;// 3. C++23 有专门的函数// std::string s = std::to_upper(&quot;hello&quot;);\n​\n7.2 字符串分割\n// C++没有内置split，需要自己实现vector&lt;string&gt; split(const string&amp; str, char delimiter) &#123;    vector&lt;string&gt; tokens;    size_t start = 0, end = 0;    while ((end = str.find(delimiter, start)) != string::npos) &#123;        tokens.push_back(str.substr(start, end - start));        start = end + 1;    &#125;    tokens.push_back(str.substr(start));    return tokens;&#125;// 使用string text = &quot;apple,banana,orange&quot;;vector&lt;string&gt; fruits = split(text, &#x27;,&#x27;);// fruits = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;&#125;\n​\n7.3 去除空白字符\nstring trim(const string&amp; str) &#123;    // 去除左边空白    size_t start = str.find_first_not_of(&quot; \\\\t\\\\n\\\\r&quot;);    if (start == string::npos) return &quot;&quot;;    // 去除右边空白    size_t end = str.find_last_not_of(&quot; \\\\t\\\\n\\\\r&quot;);    return str.substr(start, end - start + 1);&#125;string text = &quot;   Hello World   &quot;;string trimmed = trim(text);  // &quot;Hello World&quot;\n​\n 八、string 与流\n8.1 stringstream\n#include &lt;sstream&gt;#include &lt;string&gt;// 1. 字符串拼接（替代 sprintf）std::stringstream ss;ss &lt;&lt; &quot;姓名: &quot; &lt;&lt; &quot;张三&quot; &lt;&lt; &quot;, 年龄: &quot; &lt;&lt; 25;string info = ss.str();  // &quot;姓名: 张三, 年龄: 25&quot;// 2. 解析字符串string data = &quot;100 3.14 hello&quot;;std::stringstream parser(data);int n;double d;string s;parser &gt;&gt; n &gt;&gt; d &gt;&gt; s;  // n=100, d=3.14, s=&quot;hello&quot;// 3. 类型转换string strNum = &quot;123&quot;;int num;std::stringstream converter(strNum);converter &gt;&gt; num;  // num = 123\n​\n 九、性能优化技巧\n9.1 避免不必要的复制\n// ❌ 不好：多次复制string process(string str) &#123;  // 值传递，复制一次    str += &quot; processed&quot;;       // 修改副本    return str;                // 返回时可能再复制&#125;// ✅ 好：使用引用string process(const string&amp; str) &#123;  // 引用，不复制    string result = str;             // 只在必要时复制    result += &quot; processed&quot;;    return result;&#125;// ✅ 更好：移动语义（C++11）string process(string&amp;&amp; str) &#123;       // 右值引用    str += &quot; processed&quot;;    return std::move(str);           // 移动，不复制&#125;​9.2 预分配内存// 情景：拼接多个字符串string result;result.reserve(1000);  // 预分配足够空间for (int i = 0; i &lt; 100; i++) &#123;    result += &quot;string&quot; + std::to_string(i) + &quot;, &quot;;&#125;// 避免了多次重新分配内存！\n​\n 十、常见陷阱\n10.1 string 的生命周期\n// 危险：返回局部string的c_str()const char* badFunction() &#123;    string local = &quot;Hello&quot;;    return local.c_str();  // ❌ local销毁后指针无效！&#125;// 正确：返回string对象string goodFunction() &#123;    string local = &quot;Hello&quot;;    return local;  // ✅ 返回值优化或移动&#125;\n​\n10.2 中文字符处理\nstring chinese = &quot;你好世界&quot;;  // UTF-8编码// ❌ 错误：下标访问得到的是字节，不是字符cout &lt;&lt; chinese[0] &lt;&lt; endl;  // 乱码！// ✅ 正确：需要特殊处理（C++20有更好支持）// 当前需要第三方库如ICU，或自己处理UTF-8// 获取字符数（不是字节数）size_t charCount = 0;for (char c : chinese) &#123;    if ((c &amp; 0xC0) != 0x80) charCount++;&#125;cout &lt;&lt; &quot;字符数: &quot; &lt;&lt; charCount &lt;&lt; endl;  // \n 函数重载\n\n 一、什么是函数重载？\n在同一个作用域内，定义多个同名函数，但参数列表不同。\n// 三个同名函数，构成重载void print(int x);        // 1void print(double x);     // 2void print(string x);     // 3\n\n 二、重载的判定规则\n编译器根据「参数列表」区分，不看返回值！\n✅ 可以重载（参数不同）\n差异类型 示例\n参数个数不同 void f(int) vs void f(int, int)\n参数类型不同 void f(int) vs void f(double)\n参数顺序不同 void f(int, double) vs void f(double, int)\n❌ 不可以重载（编译器无法区分）\n错误示例 原因\nvoid f(int)  vs int f(int)        仅返回值不同\nvoid f(int)  vs void f(const int) 顶层const被忽略\nvoid f(int*) vs void f(int[])     数组退化为指针\n\n 三、重载 vs 默认参数\n特性 函数重载 默认参数\n本质 多个不同函数 同一个函数\n内存 多份代码 一份代码\n调用 编译器静态匹配 编译器补全参数\n灵活性 可做完全不同的事 只能省略尾部参数\n// 重载：两个独立函数void log(string msg);        // 只记消息void log(string msg, int level); // 记消息+级别// 默认参数：一个函数void log(string msg, int level = 0);  // level可省略\n\n 四、重载的匹配过程\n编译器按优先级找最佳匹配：\n\n精确匹配（类型完全相同）\n提升匹配（char→int, float→double）\n转换匹配（int→double, double→int）\n用户定义转换\n\nvoid f(int);    // 1void f(double); // 2f(&#x27;a&#x27;);  // char→int 精确提升，调用1f(3.14f); // float→double 提升，调用2\n\n 五、常见用途\n\n提供不同调用方式\n\n// 快排：排整个数组 vs 排指定范围void quickSort(vector&lt;int&gt;&amp; arr);void quickSort(vector&lt;int&gt;&amp; arr, int low, int high);\n\n处理不同类型\n\nvoid show(int x);void show(double x);void show(string x);\n\n可选参数组合\n\nvoid connect(string host);void connect(string host, int port);void connect(string host, int port, bool ssl);\n\n 六、常见陷阱\n陷阱1：形参名不重要，类型才重要\nvoid f(int a, int b);  // 这两个void f(int x, int y);  // 是同一个函数 ❌ 不是重载\n陷阱2：const位置影响重载\nvoid f(int* p);        // 1void f(const int* p);  // 2 ✅ 指向const，不同void f(int* const p);  // 与1相同 ❌ 指针自身const\n陷阱3：引用与值\nvoid f(int x);    // 1void f(int&amp; x);   // 2 ✅ 重载// 调用时 f(a) 会歧义！需要明确 f(&amp;a) 或 f(a) ？\n\n 七、形象理解\n重载就像「多义词」：\n· “打”字 → 打人、打饭、打电话、打毛衣\n· 同一个词，不同对象，不同动作\n编译器就像聪明的读者，根据上下文（参数）自动理解你要表达哪个意思。\n const\n 一、const 基础：创建常量\n1.1 基本用法\n// 1. 创建常量const int MAX_SIZE = 100;    // int常量const double PI = 3.14159;   // double常量const char NEWLINE = &#x27;\\\\n&#x27;;   // char常量// 2. 必须初始化// const int x;  // ❌ 错误！必须初始化const int y = 42;  // ✅ 正确// 3. 不可修改const int age = 25;// age = 30;  // ❌ 错误！不能修改常量\n​\n1.2 const vs #define（重要区别）\n// ❌ C语言的宏（不要用！）#define MAX_USERS 100        // 没有类型，只是文本替换#define PI 3.14159// ✅ C++的const（推荐用！）const int MAX_USERS = 100;   // 有类型，类型安全const double PI = 3.14159;   // 有作用域，可调试// 宏的问题：#define SQUARE(x) x * xint result = SQUARE(2 + 3);  // 变成 2 + 3 * 2 + 3 = 11（错误！）// const函数没有这个问题\n​\n 二、const 与指针（重要！）\n2.1 四种组合（必须掌握）\nint value = 10;int other = 20;// 1. 指向常量的指针（指针指向的内容不能改）const int* ptr1 = &amp;value;  // 读作：ptr1指向const int// *ptr1 = 100;            // ❌ 错误！不能通过ptr1修改valueptr1 = &amp;other;             // ✅ 正确！指针本身可以指向别处// 2. 常量指针（指针本身不能指向别处）int* const ptr2 = &amp;value;  // 读作：const指针指向int*ptr2 = 100;               // ✅ 正确！可以修改指向的值// ptr2 = &amp;other;          // ❌ 错误！指针不能指向别处// 3. 指向常量的常量指针（都不能改）const int* const ptr3 = &amp;value;// *ptr3 = 100;            // ❌ 错误！// ptr3 = &amp;other;          // ❌ 错误！// 4. 非常量指针（都能改）int* ptr4 = &amp;value;*ptr4 = 100;               // ✅ 正确！ptr4 = &amp;other;             // ✅ 正确！\n​\n2.2 记忆技巧：从右向左读\nconst int* p1;       // 读：p1是指针，指向const int（内容不能改）int const* p2;       // 同上！const int* 和 int const* 等价int* const p3;       // 读：p3是const指针，指向int（指针不能改）const int* const p4; // 读：p4是const指针，指向const int（都不能改）\n​\n 三、const 与函数参数\n3.1 保护传入的参数\n// 场景1：值传递 + const（通常不需要）void func1(const int x) &#123;  // const在这里意义不大    // x = 10;  // ❌ 不能修改（但x本来就是副本）&#125;// 场景2：指针参数 + const（重要！）void printData(const int* data, int size) &#123;    for (int i = 0; i &lt; size; i++) &#123;        // data[i] = 0;  // ❌ 不能修改原始数据        cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;    &#125;&#125;// 场景3：引用参数 + const（最重要！最常用！）void processString(const string&amp; str) &#123;    // str.append(&quot;!&quot;);  // ❌ 不能修改    cout &lt;&lt; str.length() &lt;&lt; endl;  // ✅ 可以读取&#125;int main() &#123;    int arr[] = &#123;1, 2, 3, 4, 5&#125;;    string name = &quot;张三&quot;;    printData(arr, 5);       // 保证我不会修改你的数组    processString(name);     // 保证我不会修改你的字符串    return 0;&#125;\n​\n3.2 const引用避免拷贝（性能优化）\n// ❌ 不好：拷贝整个大对象void printObject(MyClass obj) &#123;  // 调用拷贝构造函数    obj.display();&#125;// ✅ 好：const引用，没有拷贝void printObject(const MyClass&amp; obj) &#123;  // 不拷贝，不修改    obj.display();&#125;// 特别重要：string、vector等大对象一定要用const引用！void processBigData(const vector&lt;int&gt;&amp; data) &#123;    // 处理但不修改&#125;\n​\n 四、const 成员函数（类的核心特性）\n4.1 基本概念\nclass BankAccount &#123;private:    double balance;    mutable int accessCount;  // 特殊：可以在const函数中修改public:    BankAccount(double b) : balance(b), accessCount(0) &#123;&#125;    // const成员函数：承诺不修改对象状态    double getBalance() const &#123;        accessCount++;        // ✅ mutable成员可以修改        return balance;       // ✅ 可以读取成员        // balance = 1000;    // ❌ 不能修改非mutable成员    &#125;    // 非const成员函数：可以修改对象    void deposit(double amount) &#123;        balance += amount;    // ✅ 可以修改    &#125;    // const对象只能调用const函数&#125;;int main() &#123;    BankAccount acc1(1000);      // 非const对象    const BankAccount acc2(2000); // const对象    acc1.getBalance();    // ✅ 可以    acc1.deposit(100);    // ✅ 可以    acc2.getBalance();    // ✅ 可以（getBalance是const）    // acc2.deposit(100); // ❌ 错误！const对象不能调用非const函数    return 0;&#125;\n​\n4.2 const重载\nclass Array &#123;private:    int* data;    int size;public:    // 非const版本：可以修改元素    int&amp; operator[](int index) &#123;        return data[index];  // 返回引用，可以修改    &#125;    // const版本：只读访问    const int&amp; operator[](int index) const &#123;        return data[index];  // 返回const引用，不能修改    &#125;&#125;;int main() &#123;    Array arr1;               // 非const对象    const Array arr2;         // const对象    arr1[0] = 100;            // ✅ 调用非const版本，可以修改    int x = arr2[0];          // ✅ 调用const版本，只能读取    // arr2[0] = 200;         // ❌ 错误！    return 0;&#125;\n​\n 五、const 与返回值\n5.1 返回const值\nclass Point &#123;private:    int x, y;public:    Point(int x, int y) : x(x), y(y) &#123;&#125;    // 返回const引用，防止修改成员    const int&amp; getX() const &#123; return x; &#125;    const int&amp; getY() const &#123; return y; &#125;    // 不好的设计：返回非const引用    int&amp; badGetX() &#123; return x; &#125;  // 危险！外部可以修改x&#125;;int main() &#123;    Point p(10, 20);    // 好的设计：不能通过返回值修改    const int&amp; x = p.getX();    // x = 100;  // ❌ 错误！    // 不好的设计：可以修改私有成员！    int&amp; badX = p.badGetX();    badX = 999;  // ✅ 编译通过，但破坏了封装！    return 0;&#125;\n​\n5.2 返回const指针/引用\nclass Database &#123;private:    static Database* instance;public:    // 返回const指针，防止调用者修改单例    static const Database* getInstance() &#123;        return instance;    &#125;&#125;;// 使用：只能读取，不能修改const Database* db = Database::getInstance();// db-&gt;clear();  // ❌ 如果clear()不是const函数，就不能调用\n​\n 六、constexpr（C++11 编译时常量）\n6.1 constexpr vs const\n// const：运行时常量（可能编译时不知道值）const int size1 = getSize();  // 如果getSize()运行时才知道// constexpr：必须是编译时常量constexpr int size2 = 100;    // ✅ 编译时确定constexpr int size3 = size2 * 2;  // ✅ 编译时计算// constexpr函数：在编译时计算constexpr int square(int x) &#123;    return x * x;&#125;constexpr int val = square(10);  // 编译时计算，val=100// 数组大小必须用编译时常量int arr1[100];            // ✅ 字面量int arr2[size2];          // ✅ constexpr// int arr3[size1];       // ❌ 如果size1不是编译时常量\n​\n 七、mutable 关键字\n7.1 特殊场景：const函数中修改\nclass Cache &#123;private:    mutable bool cacheValid;      // 缓存是否有效    mutable string cachedValue;   // 缓存的值    string realValue;             // 真实数据public:    // const函数中需要修改mutable成员    const string&amp; getValue() const &#123;        if (!cacheValid) &#123;            // 虽然是const函数，但可以修改mutable成员            cachedValue = realValue;  // 假设这里计算            cacheValid = true;        &#125;        return cachedValue;    &#125;&#125;;// 使用场景：缓存、访问计数、调试信息等\n​\n 八、实际应用指南\n8.1 什么时候用const？\n✅ 应该用const的场景：1. 函数参数（除非需要修改）   void func(const string&amp; str)  // ✅2. 成员函数（除非需要修改对象）   int getValue() const  // ✅3. 局部常量   const int max = 100;  // ✅4. 类成员（如果不应被修改）   const int id;  // ✅5. 返回值（如果不希望调用者修改）   const vector&lt;int&gt;&amp; getData()  // ✅\n​\n8.2 const的安全优势\n// 示例：const如何防止错误class User &#123;    string name;public:    // 错误设计：返回非const引用    string&amp; getName() &#123; return name; &#125;    // 正确设计：返回const引用    const string&amp; getName() const &#123; return name; &#125;&#125;;void badCode(User&amp; user) &#123;    string&amp; name = user.getName();    name = &quot;黑客修改&quot;;  // ❌ 直接修改了私有成员！&#125;void goodCode(const User&amp; user) &#123;    const string&amp; name = user.getName();    // name = &quot;尝试修改&quot;;  // ❌ 编译错误！const保护&#125;\n\n Static\nstatic 改变变量/函数的存储期和链接属性，不改变类型！\n 三种不同用法\n\n局部变量 + static（函数内使用）\n\nvoid counter() &#123;    static int count = 0;  // 关键！    count++;    printf(&quot;调用次数: %d\\\\n&quot;, count);&#125;\n作用：\n· ✅ 变量只在第一次调用时初始化\n· ✅ 生命周期延长到程序结束\n· ✅ 存储位置：数据段(.data/.bss)，不在栈上！\n· ✅ 保持上次调用结束时的值（有记忆！）\n\n\n全局变量/函数 + static（文件作用域）\n\n// file.cstatic int internal_var = 42;  // 只能在本文件使用static void helper() &#123;         // 只能在本文件调用    // ...&#125;\n作用：\n· ✅ 限制作用域到当前文件\n· ✅ 避免命名冲突（内部链接）\n· ✅ 信息隐藏（封装）\n比喻： 公司内部文件（不外传）\n\n\nC++类成员 + static\n\nclass MyClass &#123;public:    static int shared_count;  // 所有对象共享&#125;;int MyClass::shared_count = 0;\n作用：\n· ✅ 类级别变量，所有实例共享\n· ✅ 无需创建对象即可访问\n· ✅ 常用于计数器、配置等\n\n 生动记忆法\n普通变量 = 临时工\n每天上班（函数调用）→ 分配工位（分配内存）每天下班（函数返回）→ 清空工位（释放内存）第二天是新开始（值不保留）\nstatic变量 = 正式员工\n入职时（第一次调用）→ 分配固定工位（数据段）每天下班（函数返回）→ 工位保留（内存不释放）第二天继续昨天的工作（值保留）\n\n 关键理解点\n\nstatic不改变数据类型！\n\nstatic int x;      // 还是int类型，只是存储方式变了static char c;     // 还是char类型\n\n初始化的特殊性\n\nvoid func() &#123;    static int x = expensive_computation();  // 只计算一次！    // 后续调用直接使用计算好的值&#125;\n\n 宏\n 一、什么是宏？\n宏是预处理器指令，在编译前进行文本替换。\n#define PI 3.14159          // 定义常量#define SQUARE(x) ((x)*(x)) // 定义函数式宏\n 二、基本用法\n\n对象宏（常量替换）\n\n#define MAX_SIZE 100        // 定义常量#define APP_NAME &quot;MyApp&quot;    // 字符串常量#define DEBUG_MODE          // 无值宏（条件编译用）int array[MAX_SIZE];        // 编译前替换为：int array[100];\n\n函数式宏（带参数）\n\n#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))#define ABS(x) ((x) &lt; 0 ? -(x) : (x))int result = MIN(10, 20);   // 替换为：((10) &lt; (20) ? (10) : (20))\n\n多行宏\n\n#define LOG_ERROR(msg) \\\\    std::cerr &lt;&lt; &quot;ERROR: &quot; &lt;&lt; msg &lt;&lt; std::endl; \\\\    std::cerr &lt;&lt; &quot;File: &quot; &lt;&lt; __FILE__ &lt;&lt; std::endl; \\\\    std::cerr &lt;&lt; &quot;Line: &quot; &lt;&lt; __LINE__ &lt;&lt; std::endl;// 使用LOG_ERROR(&quot;File not found&quot;);\n 三、特殊符号\n\n字符串化（#）\n\n#define STRINGIFY(x) #x     // 将参数转为字符串const char* str = STRINGIFY(hello);  // 变为 &quot;hello&quot;const char* str2 = STRINGIFY(3.14);  // 变为 &quot;3.14&quot;\n\n连接符（##）\n\n#define CONCAT(a, b) a##b   // 连接两个标识符int var1, var2, var3;int CONCAT(var, 1) = 10;    // 变为 int var1 = 10;int CONCAT(var, 2) = 20;    // 变为 int var2 = 20;\n\n变长参数宏（C++11）\n\n#define LOG(format, ...) \\\\    printf(&quot;[LOG] &quot; format, ##__VA_ARGS__)LOG(&quot;Value: %d, Name: %s\\\\n&quot;, 42, &quot;John&quot;);// 展开：printf(&quot;[LOG] &quot; &quot;Value: %d, Name: %s\\\\n&quot;, 42, &quot;John&quot;);\n 四、预定义宏\ncout &lt;&lt; &quot;文件: &quot; &lt;&lt; __FILE__ &lt;&lt; endl;     // 当前文件名cout &lt;&lt; &quot;行号: &quot; &lt;&lt; __LINE__ &lt;&lt; endl;     // 当前行号cout &lt;&lt; &quot;日期: &quot; &lt;&lt; __DATE__ &lt;&lt; endl;     // 编译日期cout &lt;&lt; &quot;时间: &quot; &lt;&lt; __TIME__ &lt;&lt; endl;     // 编译时间cout &lt;&lt; &quot;C++标准: &quot; &lt;&lt; __cplusplus &lt;&lt; endl;// 函数名宏（不同编译器）cout &lt;&lt; &quot;函数: &quot; &lt;&lt; __func__ &lt;&lt; endl;     // C++11标准cout &lt;&lt; &quot;函数: &quot; &lt;&lt; __FUNCTION__ &lt;&lt; endl; // GCC/MSVCcout &lt;&lt; &quot;函数: &quot; &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl; // GCC详细名\n​\n 内联函数\n 一、什么是内联函数？\n\n基本概念\n\n内联函数是一种编译器优化技术，将函数调用替换为函数体代码，消除函数调用的开销。\n\n关键特性\n\n· 编译时行为：由编译器决定是否内联\n· 空间换时间：代码膨胀换取执行速度\n· 建议而非命令：inline 关键字只是建议\n 二、三种写法\n\n使用 inline 关键字\n\n// 传统写法，在头文件中inline int max(int a, int b) &#123;    return (a &gt; b) ? a : b;&#125;\n\n类内定义（隐式内联）\n\nclass Vector &#123;public:    double getX() const &#123; return x; &#125;  // 自动成为内联候选private:    double x;&#125;;\n\n类外定义需显式声明\n\nclass Vector &#123;public:    double getX() const;  // 声明&#125;;inline double Vector::getX() const &#123;  // 定义时加 inline    return x;&#125;\n 三、现代 C++ 的扩展\n\nconstexpr 函数（C++11+）\n\nconstexpr int factorial(int n) &#123;  // 编译时计算，隐式内联    return n &lt;= 1 ? 1 : n * factorial(n-1);&#125;constexpr int result = factorial(5);  // 编译时计算：120\n\nconsteval 函数（C++20）\n\nconsteval int square(int n) &#123;  // 必须编译时执行    return n * n;&#125;constexpr int val = square(10);  // OK，编译时计算// int runtime = square(x);      // 错误！x不是常量表达式\n\nLambda 表达式\n\nauto main() -&gt; int &#123;    auto sum = [](int a, int b) -&gt; int &#123;        return a + b;    &#125;;  // Lambda通常被内联优化    int result = sum(5, 3);  // 很可能内联    return 0;&#125;\n 析构函数\n 一、什么是析构函数？\n析构函数是对象被销毁时自动调用的特殊成员函数，用于清理资源。\nclass File &#123;    FILE* handle;public:    // 构造函数：获取资源    File(const char* filename) &#123;        handle = fopen(filename, &quot;r&quot;);        std::cout &lt;&lt; &quot;文件打开\\\\n&quot;;    &#125;    // 析构函数：释放资源    ~File() &#123;  // 注意：以 ~ 开头，与类名相同，无参数无返回值        if (handle) &#123;            fclose(handle);            std::cout &lt;&lt; &quot;文件关闭\\\\n&quot;;        &#125;    &#125;&#125;;\n​\n 二、基本语法和特性\n语法：class MyClass &#123;public:    ~MyClass() &#123;  // 析构函数        // 清理代码    &#125;&#125;;​特性：class Example &#123;public:    // 1. 名称：~类名    ~Example() &#123; std::cout &lt;&lt; &quot;析构\\\\n&quot;; &#125;    // 2. 无参数    // ~Example(int x) &#123; &#125;  // ❌ 错误！不能有参数    // 3. 无返回值（连void都没有）    // ~Example() &#123; return 0; &#125;  // ❌ 错误！    // 4. 每个类只有一个析构函数    // ~Example(int) &#123; &#125;  // ❌ 不能重载！    // 5. 通常是publicprivate:    // ~Example() &#123; &#125;  // 可以private，但很少用&#125;;\n​\n 三、什么时候调用析构函数？\n场景1：局部对象离开作用域void test() &#123;    File file(&quot;data.txt&quot;);  // 构造函数调用    // 使用文件...&#125;  // 离开作用域，自动调用 ~File()​场景2：动态对象被deleteFile* file = new File(&quot;data.txt&quot;);// 使用文件...delete file;  // 调用 ~File()​场景3：容器中的对象被销毁std::vector&lt;File&gt; files;files.push_back(File(&quot;1.txt&quot;));files.push_back(File(&quot;2.txt&quot;));// vector销毁时，所有元素的析构函数被调用​场景4：临时对象使用结束File(&quot;temp.txt&quot;).read();// 临时对象使用后立即销毁，调用 ~File()\n​\n 四、析构函数的实际应用\n应用1：管理动态内存class Buffer &#123;private:    int* data;    size_t size;public:    // 构造函数：分配内存    Buffer(size_t sz) : size(sz) &#123;        data = new int[sz];        std::cout &lt;&lt; &quot;分配 &quot; &lt;&lt; sz &lt;&lt; &quot; 个int\\\\n&quot;;    &#125;    // 析构函数：释放内存    ~Buffer() &#123;        delete[] data;        std::cout &lt;&lt; &quot;释放内存\\\\n&quot;;    &#125;    // 禁止拷贝（避免双重释放）    Buffer(const Buffer&amp;) = delete;    Buffer&amp; operator=(const Buffer&amp;) = delete;&#125;;int main() &#123;    Buffer buf(100);  // 分配内存    // 使用buf...    return 0;  // 自动释放内存，无泄漏！&#125;​应用2：管理文件资源#include &lt;fstream&gt;#include &lt;string&gt;class LogFile &#123;private:    std::ofstream file;public:    LogFile(const std::string&amp; filename)        : file(filename, std::ios::app) &#123;        if (!file.is_open()) &#123;            throw std::runtime_error(&quot;无法打开日志文件&quot;);        &#125;        file &lt;&lt; &quot;=== 日志开始 ===\\\\n&quot;;    &#125;    ~LogFile() &#123;        if (file.is_open()) &#123;            file &lt;&lt; &quot;=== 日志结束 ===\\\\n&quot;;            file.close();        &#125;    &#125;    void write(const std::string&amp; message) &#123;        file &lt;&lt; message &lt;&lt; std::endl;    &#125;&#125;;int main() &#123;    try &#123;        LogFile log(&quot;app.log&quot;);        log.write(&quot;程序启动&quot;);        // ... 其他代码        log.write(&quot;处理数据&quot;);        // 程序结束或异常时，自动关闭文件并写结束标记    &#125; catch (const std::exception&amp; e) &#123;        std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;    return 0;&#125;​应用3：管理网络连接class DatabaseConnection &#123;private:    void* connection;  // 假设的数据库连接public:    DatabaseConnection(const std::string&amp; url) &#123;        // 建立连接        std::cout &lt;&lt; &quot;连接数据库: &quot; &lt;&lt; url &lt;&lt; std::endl;        // connection = db_connect(url);    &#125;    ~DatabaseConnection() &#123;        // 断开连接        std::cout &lt;&lt; &quot;断开数据库连接\\\\n&quot;;        // db_disconnect(connection);    &#125;    void execute(const std::string&amp; query) &#123;        std::cout &lt;&lt; &quot;执行: &quot; &lt;&lt; query &lt;&lt; std::endl;        // db_execute(connection, query);    &#125;&#125;;\n​\n 五、RAII模式（析构函数的哲学）\nRAII = Resource Acquisition Is Initialization（资源获取即初始化）\n核心思想：对象的生命周期 = 资源的生命周期\n// RAII的黄金法则：在构造函数中获取资源，在析构函数中释放资源\nclass RAII_Example &#123;    Resource* res;public:    RAII_Example() : res(new Resource()) &#123;  // 获取        // 如果这里失败，析构函数不会被调用    &#125;    ~RAII_Example() &#123; delete res; &#125;  // 保证释放&#125;;​RAII的威力：异常安全void risky_operation() &#123;    File file(&quot;data.txt&quot;);      // RAII：文件    DatabaseConnection db(&quot;...&quot;); // RAII：数据库连接    NetworkSocket socket(&quot;...&quot;);  // RAII：网络连接    // 如果这里抛出异常...    throw std::runtime_error(&quot;出错了！&quot;);    // 所有资源都会自动释放！    // 析构函数按创建相反的顺序调用：    // 1. ~NetworkSocket()    // 2. ~DatabaseConnection()    // 3. ~File()&#125;\n​\n 六、继承中的析构函数\n规则1：虚析构函数class Base &#123;public:    virtual ~Base() &#123;  // ✅ 虚析构函数        std::cout &lt;&lt; &quot;~Base()\\\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;    int* data;public:    Derived() : data(new int[100]) &#123;&#125;    ~Derived() override &#123;  // ✅ override 正确释放派生类资源        delete[] data;        std::cout &lt;&lt; &quot;~Derived()\\\\n&quot;;    &#125;&#125;;int main() &#123;    Base* ptr = new Derived();    delete ptr;  // ✅ 正确调用 ~Derived()，然后 ~Base()    return 0;&#125;​❌ 错误示例：没有虚析构函数class BadBase &#123;public:    ~BadBase() &#123; std::cout &lt;&lt; &quot;~BadBase()\\\\n&quot;; &#125;&#125;;class BadDerived : public BadBase &#123;    int* data;public:    BadDerived() : data(new int[100]) &#123;&#125;    ~BadDerived() &#123;        delete[] data;  // 可能不会被调用！        std::cout &lt;&lt; &quot;~BadDerived()\\\\n&quot;;    &#125;&#125;;int main() &#123;    BadBase* ptr = new BadDerived();    delete ptr;  // ❌ 只调用 ~BadBase()，内存泄漏！    return 0;&#125;\n​\n 八、析构函数的执行顺序\nclass Member &#123;public:    ~Member() &#123; std::cout &lt;&lt; &quot;~Member()\\\\n&quot;; &#125;&#125;;class Container &#123;    Member m1, m2;    int* data;public:    Container() : data(new int[10]) &#123;        std::cout &lt;&lt; &quot;Container()\\\\n&quot;;    &#125;    ~Container() &#123;        delete[] data;        std::cout &lt;&lt; &quot;~Container()\\\\n&quot;;        // 成员 m2, m1 自动析构    &#125;&#125;;int main() &#123;    Container c;    return 0;&#125;// 输出：// Container()// ~Container()// ~Member()// ~Member()\n​\n 九、常见错误和陷阱\n错误1：忘记释放资源class BadClass &#123;    int* data;public:    BadClass() : data(new int[100]) &#123;&#125;    // ❌ 忘记写析构函数！    // 内存泄漏！&#125;;​错误2：双重释放class DoubleFree &#123;    int* data;public:    DoubleFree() : data(new int[10]) &#123;&#125;    ~DoubleFree() &#123;        delete[] data;    &#125;    // ❌ 拷贝构造函数导致两个对象共享同一内存    DoubleFree(const DoubleFree&amp; other) : data(other.data) &#123;&#125;    // 当两个对象析构时，delete[] 会被调用两次！&#125;;​错误3：部分构造问题class Problematic &#123;    int* ptr1;    int* ptr2;public:    Problematic() &#123;        ptr1 = new int[100];        throw std::runtime_error(&quot;构造失败！&quot;);  // ❌ 异常！        ptr2 = new int[100];  // 不会执行    &#125;    ~Problematic() &#123;        delete[] ptr1;  // 会被调用吗？        delete[] ptr2;    &#125;&#125;;// 如果构造函数抛出异常，析构函数不会被调用！// ptr1 的内存泄漏！\n​\n十、最佳实践\n遵循RAII原则// ✅ 好：构造函数获取，析构函数释放class GoodResource &#123;    std::unique_ptr&lt;Resource&gt; res;public:    GoodResource() : res(acquire_resource()) &#123;&#125;    // 不需要写析构函数，unique_ptr自动处理&#125;;​基类总是用虚析构函数// ✅ 好：多态基类必须有虚析构函数class Base &#123;public:    virtual ~Base() = default;  // C++11 简洁写法&#125;;​使用智能指针避免手动管理// ✅ 好：让智能指针处理释放class Modern &#123;    std::unique_ptr&lt;int[]&gt; data;    std::shared_ptr&lt;Connection&gt; conn;public:    Modern()        : data(std::make_unique&lt;int[]&gt;(100)),          conn(std::make_shared&lt;Connection&gt;()) &#123;&#125;    // 不需要写析构函数！&#125;;​处理异常安全class ExceptionSafe &#123;    Resource* res1;    Resource* res2;public:    ExceptionSafe() : res1(nullptr), res2(nullptr) &#123;        res1 = new Resource();      // 可能失败        try &#123;            res2 = new Resource();  // 可能失败        &#125; catch (...) &#123;            delete res1;            // 清理部分构造的资源            throw;        &#125;    &#125;    ~ExceptionSafe() &#123;        delete res2;        delete res1;    &#125;&#125;;\n Lambda\n 一、什么是Lambda？\nLambda是匿名函数对象，可以在需要函数的地方直接定义，不需要单独的函数声明。\n// 传统函数int add(int a, int b) &#123; return a + b; &#125;// Lambda表达式auto add_lambda = [](int a, int b) &#123; return a + b; &#125;;\n 二、Lambda的基本语法\n[捕获列表](参数列表) -&gt; 返回类型 &#123; 函数体 &#125;​最简形式：[]()&#123;&#125;  // 什么都不做的最简lambda​实际例子：// 1. 无参数，无返回值auto sayHello = []() &#123;    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;&#125;;// 2. 有参数，有返回值auto add = [](int a, int b) -&gt; int &#123;    return a + b;&#125;;// 3. 省略返回类型（编译器自动推导）auto multiply = [](double x, double y) &#123;    return x * y;  // 自动推导为double&#125;;// 4. 立即调用（IIFE）int result = [](int x) &#123; return x * x; &#125;(5);  // 25\n​\n 三、捕获列表详解\n不捕获任何变量 []int x = 10, y = 20;auto func = []() &#123;    // ❌ 不能访问x, y    // return x + y;  // 错误！    return 0;&#125;;​值捕获 [var]int value = 42;auto copy_capture = [value]() &#123;    std::cout &lt;&lt; value &lt;&lt; std::endl;  // 42    // value = 100;  // ❌ 错误！不能修改（默认const）&#125;;value = 50;  // 修改原始变量copy_capture();  // 仍然输出42（捕获的是副本）​引用捕获 [&amp;var]int counter = 0;auto ref_capture = [&amp;counter]() &#123;    counter++;  // ✅ 可以修改原始变量    std::cout &lt;&lt; counter &lt;&lt; std::endl;&#125;;ref_capture();  // 输出1，counter变为1​隐式值捕获 [=]int a = 1, b = 2, c = 3;auto implicit_copy = [=]() &#123;    // 可以访问a, b, c的副本    return a + b + c;&#125;;​隐式引用捕获 [&amp;]int x = 10, y = 20;auto implicit_ref = [&amp;]() &#123;    x = 100;  // 修改原始x    y = 200;  // 修改原始y&#125;;implicit_ref();// 现在 x=100, y=200​混合捕获int a = 1, b = 2, c = 3;auto mixed = [a, &amp;b, c]() &#123;  // a值捕获，b引用捕获，c值捕获    // a是副本，b是引用，c是副本&#125;;auto mixed2 = [=, &amp;b]() &#123;     // 除了b是引用，其他都是值捕获    // a, c是副本，b是引用&#125;;auto mixed3 = [&amp;, a]() &#123;      // 除了a是值捕获，其他都是引用捕获    // a是副本，b, c是引用&#125;;​移动捕获（C++14） [var = std::move(var)]#include &lt;memory&gt;#include &lt;vector&gt;auto big_data = std::make_unique&lt;std::vector&lt;int&gt;&gt;();// 移动捕获：转移所有权，避免拷贝auto lambda = [data = std::move(big_data)]() &#123;    // data现在拥有原来的big_data    // big_data变为nullptr&#125;;\n 五、Lambda的类型和存储\nLambda是唯一的类型auto lambda1 = []() &#123; return 1; &#125;;auto lambda2 = []() &#123; return 1; &#125;;// 每个lambda都有不同的类型static_assert(!std::is_same&lt;decltype(lambda1), decltype(lambda2)&gt;::value,              &quot;两个lambda类型不同！&quot;);​如何存储Lambda// 方法1：auto（最常见）auto lambda = []() &#123; return 42; &#125;;// 方法2：std::function（有类型擦除开销，但更灵活）#include &lt;functional&gt;std::function&lt;void()&gt; func = []() &#123; std::cout &lt;&lt; &quot;Hello&quot;; &#125;;// 方法3：函数指针（仅适用于无捕获的lambda）void (*func_ptr)() = []() &#123; std::cout &lt;&lt; &quot;无捕获lambda可转函数指针&quot;; &#125;;\n 六、Lambda与函数对象的对比\n传统函数对象（仿函数）：class Adder &#123;    int value;public:    Adder(int v) : value(v) &#123;&#125;    int operator()(int x) const &#123; return x + value; &#125;&#125;;Adder add5(5);int result = add5(10);  // 15​Lambda（更简洁）：int value = 5;auto add5 = [value](int x) &#123; return x + value; &#125;;int result = add5(10);  // 15\n 七、Lambda的高级特性\n可变Lambda（C++11） mutableint counter = 0;auto incrementer = [counter]() mutable &#123;    counter++;  // ✅ 现在可以修改捕获的副本    return counter;&#125;;std::cout &lt;&lt; incrementer() &lt;&lt; std::endl;  // 1std::cout &lt;&lt; incrementer() &lt;&lt; std::endl;  // 2std::cout &lt;&lt; &quot;原始counter: &quot; &lt;&lt; counter &lt;&lt; std::endl;  // 0（副本被修改，原值不变）​constexpr Lambda（C++17）// 可以在编译时计算的lambdaconstexpr auto square = [](int n) &#123; return n * n; &#125;;static_assert(square(5) == 25, &quot;编译时计算&quot;);constexpr int result = square(10);  // 编译时计算​模板Lambda（C++20）// 泛型lambda（C++14起）auto generic = [](auto a, auto b) &#123; return a + b; &#125;;// C++20：显式模板参数auto typed = []&lt;typename T&gt;(T a, T b) &#123; return a + b; &#125;;// 使用std::cout &lt;&lt; generic(1, 2) &lt;&lt; std::endl;     // 3std::cout &lt;&lt; generic(1.5, 2.5) &lt;&lt; std::endl; // 4.0std::cout &lt;&lt; typed(3, 4) &lt;&lt; std::endl;       // 7​在成员函数中使用 [this]class MyClass &#123;    int value = 42;public:    void process() &#123;        // 捕获this指针        auto lambda = [this]() &#123;            std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; value &lt;&lt; std::endl;  // 访问成员            value = 100;  // 修改成员        &#125;;        lambda();    &#125;&#125;;\n​\n 八、常见陷阱和最佳实践\n陷阱1：悬挂引用std::function&lt;int()&gt; create_bad_lambda() &#123;    int local = 42;    return [&amp;local]() &#123; return local; &#125;;  // ❌ 危险！返回后local被销毁&#125;// 正确：值捕获std::function&lt;int()&gt; create_good_lambda() &#123;    int local = 42;    return [local]() &#123; return local; &#125;;  // ✅ 安全&#125;​陷阱2：默认捕获的隐患class Resource &#123;    std::vector&lt;int&gt; data;public:    auto get_processor() &#123;        // ❌ 不好：隐式引用捕获[&amp;]可能捕获不想要的变量        return [&amp;]() &#123; return data.size(); &#125;;        // ✅ 更好：显式指定要捕获的        return [this]() &#123; return data.size(); &#125;;    &#125;&#125;;​最佳实践：// 1. 尽量使用值捕获，除非需要修改外部变量auto safe_lambda = [x]() &#123; return x * 2; &#125;;  // 值捕获// 2. 避免[&amp;]和[=]的隐式捕获，显式列出需要捕获的变量auto explicit_lambda = [&amp;counter, data]() &#123; /* ... */ &#125;;  // 明确// 3. 小心生命周期//    返回的lambda不要捕获局部变量的引用// 4. 简单逻辑用lambda，复杂逻辑考虑单独函数\n 智能指针\n 一、为什么需要智能指针？\n传统指针的问题// ❌ 问题1：内存泄漏void bad_function() &#123;    int* ptr = new int(100);  // 分配内存    if (error_occurred) &#123;        return;  // ⚠️ 忘记delete！内存泄漏！    &#125;    delete ptr;  // 可能执行不到这里&#125;// ❌ 问题2：重复释放int* p1 = new int(10);int* p2 = p1;      // 两个指针指向同一内存delete p1;         // 释放一次delete p2;         // ⚠️ 再次释放！程序崩溃！// ❌ 问题3：空悬指针int* ptr = new int(20);delete ptr;        // 释放内存*ptr = 30;         // ⚠️ 访问已释放内存！未定义行为！​智能指针解决方案#include &lt;memory&gt;void safe_function() &#123;    auto ptr = std::make_unique&lt;int&gt;(100);  // 自动管理内存    if (error_occurred) &#123;        return;  // ✅ 自动释放内存，无泄漏！    &#125;    // ✅ 自动在作用域结束时释放&#125;\n 二、三种智能指针对比\n类型 所有权 复制行为 使用场景 性能unique_ptr 独占 禁止复制，可移动 单一所有者资源 ⭐⭐⭐⭐⭐ 最快shared_ptr 共享 引用计数，可复制 共享资源，多所有者 ⭐⭐⭐ 中等weak_ptr 弱引用 不增加引用计数 打破循环引用 ⭐⭐⭐⭐ 快\n 三、unique_ptr（独占指针）\n基本用法#include &lt;memory&gt;#include &lt;iostream&gt;class Resource &#123;public:    Resource() &#123; std::cout &lt;&lt; &quot;Resource acquired\\\\n&quot;; &#125;    ~Resource() &#123; std::cout &lt;&lt; &quot;Resource destroyed\\\\n&quot;; &#125;    void use() &#123; std::cout &lt;&lt; &quot;Using resource\\\\n&quot;; &#125;&#125;;int main() &#123;    // 创建unique_ptr（推荐make_unique）    auto ptr1 = std::make_unique&lt;Resource&gt;();  // C++14    ptr1-&gt;use();  // 像普通指针一样使用    // 传统方式（不推荐）    std::unique_ptr&lt;Resource&gt; ptr2(new Resource());    // unique_ptr不能复制，只能移动    auto ptr3 = std::move(ptr1);  // ptr1变为nullptr    if (!ptr1) &#123;        std::cout &lt;&lt; &quot;ptr1 is now empty\\\\n&quot;;    &#125;    // 自动在作用域结束时释放    return 0;&#125;​管理数组// 管理单个对象（默认）auto single = std::make_unique&lt;int&gt;(42);// 管理数组auto array = std::make_unique&lt;int[]&gt;(10);  // 10个int的数组array[0] = 1;array[1] = 2;// 传统方式（需要指定删除器）std::unique_ptr&lt;int[]&gt; arr(new int[5]&#123;1,2,3,4,5&#125;);​自定义删除器#include &lt;cstdio&gt;// 文件自动关闭auto file_closer = [](FILE* f) &#123;    if (f) &#123;        std::cout &lt;&lt; &quot;Closing file\\\\n&quot;;        fclose(f);    &#125;&#125;;std::unique_ptr&lt;FILE, decltype(file_closer)&gt;    filePtr(fopen(&quot;test.txt&quot;, &quot;r&quot;), file_closer);\n 四、shared_ptr（共享指针）\n基本用法#include &lt;memory&gt;#include &lt;iostream&gt;class SharedResource &#123;public:    SharedResource() &#123; std::cout &lt;&lt; &quot;Resource created\\\\n&quot;; &#125;    ~SharedResource() &#123; std::cout &lt;&lt; &quot;Resource destroyed\\\\n&quot;; &#125;&#125;;int main() &#123;    // 创建shared_ptr（推荐make_shared）    auto ptr1 = std::make_shared&lt;SharedResource&gt;();    &#123;        // 复制shared_ptr，引用计数+1        auto ptr2 = ptr1;  // 现在引用计数=2        std::cout &lt;&lt; &quot;Inside block, use_count: &quot;                  &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;    &#125;  // ptr2销毁，引用计数-1    std::cout &lt;&lt; &quot;Outside block, use_count: &quot;              &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;    return 0;  // 引用计数=0时自动释放&#125;​引用计数机制#include &lt;memory&gt;#include &lt;iostream&gt;int main() &#123;    auto sp1 = std::make_shared&lt;int&gt;(100);    std::cout &lt;&lt; &quot;sp1 use_count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;  // 1    auto sp2 = sp1;  // 复制构造，引用计数+1    std::cout &lt;&lt; &quot;sp1 use_count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;  // 2    std::cout &lt;&lt; &quot;sp2 use_count: &quot; &lt;&lt; sp2.use_count() &lt;&lt; std::endl;  // 2    sp1.reset();  // sp1放弃所有权，引用计数-1    std::cout &lt;&lt; &quot;sp2 use_count: &quot; &lt;&lt; sp2.use_count() &lt;&lt; std::endl;  // 1    // sp2离开作用域，引用计数=0，资源释放    return 0;&#125;​循环引用问题#include &lt;memory&gt;#include &lt;iostream&gt;class Node &#123;public:    std::shared_ptr&lt;Node&gt; next;    std::shared_ptr&lt;Node&gt; prev;    ~Node() &#123; std::cout &lt;&lt; &quot;Node destroyed\\\\n&quot;; &#125;&#125;;int main() &#123;    // 创建循环引用    auto node1 = std::make_shared&lt;Node&gt;();    auto node2 = std::make_shared&lt;Node&gt;();    node1-&gt;next = node2;  // node2引用计数=2    node2-&gt;prev = node1;  // node1引用计数=2    // 程序结束，但内存泄漏！    // node1引用计数=1 (node2的prev持有)    // node2引用计数=1 (node1的next持有)    std::cout &lt;&lt; &quot;End of main - memory leak!\\\\n&quot;;    return 0;&#125;\n 五、weak_ptr（弱指针）\n解决循环引用#include &lt;memory&gt;#include &lt;iostream&gt;class Node &#123;public:    std::shared_ptr&lt;Node&gt; next;    std::weak_ptr&lt;Node&gt; prev;  // 使用weak_ptr打破循环    ~Node() &#123; std::cout &lt;&lt; &quot;Node destroyed\\\\n&quot;; &#125;&#125;;int main() &#123;    auto node1 = std::make_shared&lt;Node&gt;();    auto node2 = std::make_shared&lt;Node&gt;();    node1-&gt;next = node2;      // node2引用计数=2    node2-&gt;prev = node1;      // node1引用计数=1（weak_ptr不增加计数）    // ✅ 没有内存泄漏！    std::cout &lt;&lt; &quot;node1 use_count: &quot; &lt;&lt; node1.use_count() &lt;&lt; std::endl;  // 1    std::cout &lt;&lt; &quot;node2 use_count: &quot; &lt;&lt; node2.use_count() &lt;&lt; std::endl;  // 2    return 0;  // 正确释放内存&#125;​weak_ptr基本操作#include &lt;memory&gt;#include &lt;iostream&gt;int main() &#123;    auto sp = std::make_shared&lt;int&gt;(42);    std::weak_ptr&lt;int&gt; wp = sp;  // 创建weak_ptr    // 检查资源是否还存在    if (!wp.expired()) &#123;        std::cout &lt;&lt; &quot;Resource still exists\\\\n&quot;;    &#125;    // 获取shared_ptr（如果资源还存在）    if (auto locked = wp.lock()) &#123;        std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *locked &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;use_count: &quot; &lt;&lt; locked.use_count() &lt;&lt; std::endl;  // 2    &#125;    sp.reset();  // 释放资源    if (wp.expired()) &#123;        std::cout &lt;&lt; &quot;Resource has been released\\\\n&quot;;    &#125;    return 0;&#125;\n 六、性能考虑\nmake_shared vs new + shared_ptr// ✅ 推荐：make_shared（一次内存分配）auto sp1 = std::make_shared&lt;MyClass&gt;(args);// ❌ 不推荐：new + shared_ptr（两次内存分配）auto sp2 = std::shared_ptr&lt;MyClass&gt;(new MyClass(args));// 原因：// 1. make_shared：对象和控制块一次分配，更快// 2. 异常安全：make_shared保证原子性// 3. 内存局部性更好​何时使用哪种智能指针// 规则1：默认使用unique_ptr// 除非需要共享，否则都用unique_ptrauto config = std::make_unique&lt;Config&gt;();// 规则2：需要共享时用shared_ptrclass Connection &#123;    static std::shared_ptr&lt;Connection&gt; create() &#123;        return std::make_shared&lt;Connection&gt;();    &#125;&#125;;// 规则3：可能循环引用时用weak_ptrclass TreeNode &#123;    std::shared_ptr&lt;TreeNode&gt; child;    std::weak_ptr&lt;TreeNode&gt; parent;  // 父节点用weak_ptr&#125;;// 规则4：简单情况用值语义（不要过度使用智能指针）// 能用栈变量就不用堆分配std::vector&lt;int&gt; data;  // 直接用，不要vector&lt;unique_ptr&lt;int&gt;&gt;\n 八、常见错误和陷阱\n错误1：混用智能指针和裸指针// ❌ 错误：智能指针和裸指针混用int* raw_ptr = new int(100);std::shared_ptr&lt;int&gt; sp1(raw_ptr);std::shared_ptr&lt;int&gt; sp2(raw_ptr);  // ⚠️ 双重释放！// ✅ 正确：始终从make_shared开始auto sp1 = std::make_shared&lt;int&gt;(100);auto sp2 = sp1;  // 共享所有权​错误2：误用get()获取的裸指针auto sp = std::make_shared&lt;int&gt;(42);int* raw = sp.get();  // 获取内部裸指针// ❌ 错误：用raw指针创建新的智能指针std::shared_ptr&lt;int&gt; sp2(raw);  // ⚠️ 双重管理！// ❌ 错误：删除get()返回的指针delete sp.get();  // ⚠️ 智能指针会再次删除！// ✅ 正确：只用get()进行只读操作int value = *sp.get();  // 只读取值some_c_api(sp.get());   // 传给只使用不管理的C函数​错误3：错误的删除器// ❌ 错误：数组用默认删除器std::shared_ptr&lt;int&gt; arr(new int[10]);  // ⚠️ 应该用delete[]// ✅ 正确：数组用正确的删除器std::shared_ptr&lt;int[]&gt; arr(new int[10]);  // C++17// 或std::shared_ptr&lt;int&gt; arr(new int[10], std::default_delete&lt;int[]&gt;());\n 九、最佳实践总结\n黄金法则\n// 1. 优先使用栈对象，其次unique_ptr，最后shared_ptrvoid process() &#123;    int local = 10;                    // 栈对象（最快）    auto unique = std::make_unique&lt;Resource&gt;();  // 独占资源    auto shared = std::make_shared&lt;SharedResource&gt;();  // 共享资源&#125;// 2. 使用make_unique/make_shared，不要用newauto ptr = std::make_unique&lt;MyClass&gt;();  // ✅auto ptr = std::unique_ptr&lt;MyClass&gt;(new MyClass());  // ❌// 3. 传递智能指针时考虑所有权语义void take_ownership(std::unique_ptr&lt;Data&gt; data);  // 接收所有权void share_ownership(std::shared_ptr&lt;Data&gt; data);  // 共享所有权void observe(std::weak_ptr&lt;Data&gt; data);  // 观察，不拥有void use_only(const Data* data);  // 只使用，不管理// 4. 避免循环引用，父节点用weak_ptrclass Node &#123;    std::shared_ptr&lt;Node&gt; child;    std::weak_ptr&lt;Node&gt; parent;  // 打破循环&#125;;\n 链表\n 一、核心概念：什么是链表？\n链表 vs 数组（vector）内存对比\n数组（vector）：连续内存\n[元素1][元素2][元素3][元素4][    ]\n↑ 所有元素挨在一起\n链表：非连续内存（指针连接）\n[数据1|next] → [数据2|next] → [数据3|next] → nullptr\n↑             ↑               ↑\n堆地址A       堆地址B          堆地址C（完全不连续！）\n​\n链表的本质：\n// 每个节点 = 数据 + 指针\nstruct ListNode &#123;    int data;           // 数据部分    ListNode* next;     // 指向下一个节点的指针    ListNode(int val) : data(val), next(nullptr) &#123;&#125;&#125;;// 双向链表节点struct DoublyListNode &#123;    int data;    DoublyListNode* prev;  // 指向前一个节点    DoublyListNode* next;  // 指向后一个节点&#125;;\n 二、STL中的链表（工作中实际用的）\nstd::list（双向链表）#include &lt;list&gt;#include &lt;iostream&gt;int main() &#123;    // 创建和初始化    std::list&lt;int&gt; lst1;                    // 空链表    std::list&lt;int&gt; lst2 = &#123;1, 2, 3, 4, 5&#125;;  // 初始值    std::list&lt;int&gt; lst3(10, 42);            // 10个42    // 🔥 核心操作（都是O(1)复杂度）    // 插入    lst1.push_front(0);       // 头部插入：0    lst1.push_back(1);        // 尾部插入：0→1    auto it = lst1.begin();    ++it;                     // 移动到第二个位置    lst1.insert(it, 99);      // 中间插入：0→99→1    // 删除    lst1.pop_front();         // 删除头部：99→1    lst1.pop_back();          // 删除尾部：99    lst1.erase(lst1.begin()); // 删除指定位置    // 访问（链表不能随机访问！）    std::cout &lt;&lt; &quot;第一个元素: &quot; &lt;&lt; lst2.front() &lt;&lt; std::endl;  // 1    std::cout &lt;&lt; &quot;最后一个元素: &quot; &lt;&lt; lst2.back() &lt;&lt; std::endl; // 5    // 遍历（只能用迭代器）    for (auto it = lst2.begin(); it != lst2.end(); ++it) &#123;        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;  // 1 2 3 4 5    &#125;    // 或范围for    for (int val : lst2) &#123;        std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;    // 其他有用操作    lst2.sort();               // 排序 O(n log n)    lst2.unique();             // 删除连续重复元素    lst2.reverse();            // 反转链表 O(n)    // 合并链表（拼接，不是合并排序）    std::list&lt;int&gt; lstA = &#123;1, 2, 3&#125;;    std::list&lt;int&gt; lstB = &#123;4, 5, 6&#125;;    lstA.splice(lstA.end(), lstB);  // lstA: 1,2,3,4,5,6                                    // lstB变为空！    return 0;&#125;​std::forward_list（单向链表，C++11）#include &lt;forward_list&gt;#include &lt;iostream&gt;int main() &#123;    std::forward_list&lt;int&gt; flist = &#123;1, 2, 3, 4, 5&#125;;    // 单向链表特点：    // 1. 只有push_front，没有push_back！    // 2. 更省内存（每个节点少    // 遍历一样    for (int n : flist) &#123;        std::cout &lt;&lt; n &lt;&lt; &quot; &quot;;  // 0 1 2 3 4 5    &#125;    // 删除下一个元素（因为单向，要知道前一个节点）    auto it = flist.begin();    ++it;  // 指向第二个元素    flist.erase_after(flist.begin());  // 删除第二个元素    return 0;&#125;\n 三、手动实现链表\n单向链表基本实现class SimpleLinkedList &#123;private:    struct Node &#123;        int data;        Node* next;        Node(int val) : data(val), next(nullptr) &#123;&#125;    &#125;;    Node* head;    Node* tail;    int size;public:    SimpleLinkedList() : head(nullptr), tail(nullptr), size(0) &#123;&#125;    ~SimpleLinkedList() &#123;        // 必须手动释放所有节点！        Node* current = head;        while (current) &#123;            Node* next = current-&gt;next;            delete current;            current = next;        &#125;    &#125;    // 在尾部添加    void append(int val) &#123;        Node* newNode = new Node(val);        if (!head) &#123;            head = tail = newNode;        &#125; else &#123;            tail-&gt;next = newNode;            tail = newNode;        &#125;        size++;    &#125;    // 在头部添加    void prepend(int val) &#123;        Node* newNode = new Node(val);        newNode-&gt;next = head;        head = newNode;        if (!tail) tail = head;        size++;    &#125;    // 打印链表    void print() const &#123;        Node* current = head;        while (current) &#123;            std::cout &lt;&lt; current-&gt;data;            if (current-&gt;next) std::cout &lt;&lt; &quot; -&gt; &quot;;            current = current-&gt;next;        &#125;        std::cout &lt;&lt; &quot; -&gt; nullptr&quot; &lt;&lt; std::endl;    &#125;    // 反转链表（面试常考！）    void reverse() &#123;        Node* prev = nullptr;        Node* current = head;        tail = head;  // 头变尾        while (current) &#123;            Node* next = current-&gt;next;            current-&gt;next = prev;            prev = current;            current = next;        &#125;        head = prev;  // 新的头    &#125;    // 查找    bool contains(int val) const &#123;        Node* current = head;        while (current) &#123;            if (current-&gt;data == val) return true;            current = current-&gt;next;        &#125;        return false;    &#125;&#125;;// 使用int main() &#123;    SimpleLinkedList list;    list.append(1);    list.append(2);    list.append(3);    list.prepend(0);    list.print();  // 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; nullptr    list.reverse();    list.print();  // 3 -&gt; 2 -&gt; 1 -&gt; 0 -&gt; nullptr    return 0;&#125;\n 四、链表经典题（必须掌握）\n反转链表ListNode* reverseList(ListNode* head) &#123;    ListNode* prev = nullptr;    ListNode* curr = head;    while (curr) &#123;        ListNode* next = curr-&gt;next;        curr-&gt;next = prev;        prev = curr;        curr = next;    &#125;    return prev;&#125;​检测环（快慢指针）bool hasCycle(ListNode* head) &#123;    if (!head || !head-&gt;next) return false;    ListNode* slow = head;    ListNode* fast = head-&gt;next;    while (slow != fast) &#123;        if (!fast || !fast-&gt;next) return false;        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;    &#125;    return true;&#125;​合并两个有序链表ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;    ListNode dummy(0);    ListNode* tail = &amp;dummy;    while (l1 &amp;&amp; l2) &#123;        if (l1-&gt;val &lt; l2-&gt;val) &#123;            tail-&gt;next = l1;            l1 = l1-&gt;next;        &#125; else &#123;            tail-&gt;next = l2;            l2 = l2-&gt;next;        &#125;        tail = tail-&gt;next;    &#125;    tail-&gt;next = l1 ? l1 : l2;    return dummy.next;&#125;​删除倒数第N个节点ListNode* removeNthFromEnd(ListNode* head, int n) &#123;    ListNode dummy(0);    dummy.next = head;    ListNode* fast = &amp;dummy;    ListNode* slow = &amp;dummy;    // fast先走n步    for (int i = 0; i &lt;= n; ++i) &#123;        fast = fast-&gt;next;    &#125;    // 一起走到fast到末尾    while (fast) &#123;        fast = fast-&gt;next;        slow = slow-&gt;next;    &#125;    // 删除slow的下一个节点    ListNode* to_delete = slow-&gt;next;    slow-&gt;next = slow-&gt;next-&gt;next;    delete to_delete;    return dummy.next;&#125;\n 继承&amp;多态\n 一、继承基础\n三种继承方式\nclass Base &#123;public:    int public_var;protected:    int protected_var;private:    int private_var;&#125;;// 公有继承（最常用）：保持原有访问权限class PublicDerived : public Base &#123;    // public_var 仍是 public    // protected_var 仍是 protected    // private_var 不可访问&#125;;// 保护继承：public降级为protectedclass ProtectedDerived : protected Base &#123;    // public_var 变为 protected    // protected_var 仍是 protected    // private_var 不可访问&#125;;// 私有继承：全部变为privateclass PrivateDerived : private Base &#123;    // public_var 变为 private    // protected_var 变为 private    // private_var 不可访问&#125;;\n构造和析构顺序\nclass Base &#123;public:    Base() &#123; cout &lt;&lt; &quot;Base构造&quot; &lt;&lt; endl; &#125;    ~Base() &#123; cout &lt;&lt; &quot;Base析构&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base &#123;public:    Derived() &#123; cout &lt;&lt; &quot;Derived构造&quot; &lt;&lt; endl; &#125;    ~Derived() &#123; cout &lt;&lt; &quot;Derived析构&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123;    Derived d;    return 0;&#125;// 输出：// Base构造// Derived构造// Derived析构// Base析构// 构造：先父后子，析构：先子后父​初始化列表调用父类构造class Base &#123;    int value;public:    Base(int v) : value(v) &#123;&#125;&#125;;class Derived : public Base &#123;    int extra;public:    // 必须初始化父类    Derived(int v, int e) : Base(v), extra(e) &#123;&#125;    // 错误：没有调用Base构造    // Derived(int v, int e) &#123; extra = e; &#125; ❌&#125;;\n 二、函数重写与隐藏\n函数隐藏（不是多态！）\nclass Base &#123;public:    void func() &#123; cout &lt;&lt; &quot;Base::func&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base &#123;public:    void func(int x) &#123; cout &lt;&lt; &quot;Derived::func&quot; &lt;&lt; endl; &#125; // 隐藏了Base::func&#125;;int main() &#123;    Derived d;    d.func(1);      // ✅ 调用Derived::func    // d.func();    // ❌ 错误！Base::func被隐藏    d.Base::func(); // ✅ 指定调用父类的    return 0;&#125;​使用using恢复隐藏函数class Base &#123;public:    void func() &#123; cout &lt;&lt; &quot;Base::func&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base &#123;public:    using Base::func;  // 恢复Base::func    void func(int x) &#123; cout &lt;&lt; &quot;Derived::func&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123;    Derived d;    d.func();    // ✅ 现在可以调用    d.func(1);   // ✅ 也可以调用    return 0;&#125;\n 三、多态基础\n虚函数与overrideclass Animal &#123;public:    virtual void speak() &#123; cout &lt;&lt; &quot;动物叫&quot; &lt;&lt; endl; &#125;  // 虚函数    virtual void eat() = 0;  // 纯虚函数，抽象类    // 虚析构函数（多态基类必须！）    virtual ~Animal() &#123; cout &lt;&lt; &quot;~Animal&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal &#123;public:    void speak() override &#123;  // C++11: override确保正确重写        cout &lt;&lt; &quot;汪汪&quot; &lt;&lt; endl;    &#125;    void eat() override &#123;    // 必须实现纯虚函数        cout &lt;&lt; &quot;吃狗粮&quot; &lt;&lt; endl;    &#125;    ~Dog() override &#123; cout &lt;&lt; &quot;~Dog&quot; &lt;&lt; endl; &#125;&#125;;​多态使用示例void animalAction(Animal* animal) &#123;    animal-&gt;speak();  // 多态调用    animal-&gt;eat();&#125;int main() &#123;    Animal* zoo[] = &#123;new Dog(), new Cat(), new Bird()&#125;;    for (auto animal : zoo) &#123;        animalAction(animal);    &#125;    // 必须用delete，会调用正确的析构函数    for (auto animal : zoo) &#123;        delete animal;    &#125;    return 0;&#125;\n 四、虚函数表（vtable）机制\nvtable内存布局class Base &#123;public:    virtual void func1() &#123;&#125;    virtual void func2() &#123;&#125;    int data;&#125;;class Derived : public Base &#123;public:    void func1() override &#123;&#125;  // 覆盖    virtual void func3() &#123;&#125;   // 新增    int extra_data;&#125;;// vtable布局：// Base vtable:    [Base::func1][Base::func2]// Derived vtable: [Derived::func1][Base::func2][Derived::func3]//// 对象内存：// Base对象:     [vptr→Base vtable][data]// Derived对象:  [vptr→Derived vtable][data][extra_data]​虚函数调用过程Base* ptr = new Derived();ptr-&gt;func1();  // 运行时：// 1. 通过ptr找到对象// 2. 读取对象头部的vptr// 3. 通过vptr找到vtable// 4. 在vtable中找到func1的地址// 5. 调用Derived::func1()\n 五、多重继承与虚继承\n多重继承\nclass Printer &#123;public:    virtual void print() &#123; cout &lt;&lt; &quot;打印&quot; &lt;&lt; endl; &#125;&#125;;class Scanner &#123;public:    virtual void scan() &#123; cout &lt;&lt; &quot;扫描&quot; &lt;&lt; endl; &#125;&#125;;class MultiFunction : public Printer, public Scanner &#123;public:    void print() override &#123; cout &lt;&lt; &quot;多功能打印&quot; &lt;&lt; endl; &#125;    void scan() override &#123; cout &lt;&lt; &quot;多功能扫描&quot; &lt;&lt; endl; &#125;    void copy() &#123; print(); scan(); &#125;  // 新增功能&#125;;// 内存布局：有两个vptr！// [Printer vptr][Scanner vptr][MultiFunction数据]\n钻石继承问题与虚继承\nclass Base &#123;public:    int data;&#125;;class Middle1 : virtual public Base &#123;&#125;;  // 虚继承class Middle2 : virtual public Base &#123;&#125;;  // 虚继承class Derived : public Middle1, public Middle2 &#123;&#125;;// Derived只有一个Base副本// 避免了菱形继承的数据冗余\n 六、dynamic_cast与RTTI\n类型安全向下转型\nclass Base &#123; virtual ~Base() &#123;&#125; &#125;;class Derived : public Base &#123;&#125;;Base* base_ptr = new Derived();\n安全的向下转型\nDerived* derived_ptr = dynamic_cast&lt;Derived*&gt;(base_ptr);if (derived_ptr) &#123;  // 转换成功    // 使用Derived特有功能&#125;// 失败时返回nullptr（指针）或抛异常（引用）​typeid操作符#include &lt;typeinfo&gt;Base* ptr = new Derived();cout &lt;&lt; typeid(*ptr).name() &lt;&lt; endl;  // 输出：class Derivedcout &lt;&lt; typeid(ptr).name() &lt;&lt; endl;   // 输出：class Base*if (typeid(*ptr) == typeid(Derived)) &#123;    cout &lt;&lt; &quot;确实是Derived对象&quot; &lt;&lt; endl;&#125;\n 七、设计模式中的多态应用\n工厂模式\nclass Product &#123;public:    virtual void use() = 0;    virtual ~Product() &#123;&#125;&#125;;class ConcreteProductA : public Product &#123;    void use() override &#123; cout &lt;&lt; &quot;使用产品A&quot; &lt;&lt; endl; &#125;&#125;;class ConcreteProductB : public Product &#123;    void use() override &#123; cout &lt;&lt; &quot;使用产品B&quot; &lt;&lt; endl; &#125;&#125;;class Factory &#123;public:    static Product* createProduct(const string&amp; type) &#123;        if (type == &quot;A&quot;) return new ConcreteProductA();        if (type == &quot;B&quot;) return new ConcreteProductB();        return nullptr;    &#125;&#125;;\n​\n策略模式\nclass Strategy &#123;public:    virtual void execute() = 0;    virtual ~Strategy() &#123;&#125;&#125;;class StrategyA : public Strategy &#123;    void execute() override &#123; cout &lt;&lt; &quot;策略A&quot; &lt;&lt; endl; &#125;&#125;;class StrategyB : public Strategy &#123;    void execute() override &#123; cout &lt;&lt; &quot;策略B&quot; &lt;&lt; endl; &#125;&#125;;class Context &#123;    Strategy* strategy;public:    void setStrategy(Strategy* s) &#123; strategy = s; &#125;    void executeStrategy() &#123; strategy-&gt;execute(); &#125;&#125;;\n 移动语义\n 完美转发\n 类型推导\n 结构化绑定\n","categories":["C++"],"tags":["C++"]},{"title":"vcpkg&CMake","url":"/2026/02/25/vcpkg-CMake/","content":" vcpkg\n 目录结构\n 📚  核心目录结构\n一、ports/ 目录 - “食谱库”\n#作用：如何获取和构建库ports/├── fmt/          # 每个库一个目录│   ├── vcpkg.json       # 库的元数据：名称、版本、依赖、描述│   ├── portfile.cmake   # 构建脚本：下载的URL、编译选项、安装步骤│   └── (patch文件)      # 补丁├── zlib/├── curl/└── ... (2737个库)\n\n二、downloads/ 目录 - “下载缓存”\n#作用：避免重复下载downloads/├── fmt-8.0.0.tar.gz           # 库源码压缩包├── ninja-win-1.13.1.zip       # 构建工具├── curl-curl-curl-8_17_0.tar.gz└── madler-zlib-v1.3.1.tar.gz\n\n三、installed/ 目录 - “成品仓库”\ninstalled/├── x64-windows/               # triplet：平台架构│   ├── include/               # 头文件目录│   │   └── fmt/│   │       ├── core.h│   │       └── format.h│   ├── lib/                   # 静态库/导入库│   │   ├── fmt.lib│   │   └── debug/fmt.lib│   ├── bin/                   # 动态库（Windows的DLL）│   │   ├── fmt.dll│   │   └── debug/fmt.dll│   └── share/                 # 配置文件│       └── fmt/│           ├── vcpkg.json│           └── copyright├── x64-windows-static/        # 静态链接版本└── x86-windows/               # 32位版本\n\n四、vcpkg.exe - “总厨师”\n作用：命令行管理工具\n# 包管理vcpkg install fmt        # 下载→编译→安装vcpkg remove fmt         # 卸载vcpkg list              # 查看已安装vcpkg search boost      # 搜索库# 项目管理vcpkg integrate install # 集成到Visual Studiovcpkg new              # 创建新项目# 信息查询vcpkg depend-info fmt  # 查看依赖vcpkg triplet list     # 查看支持的平台\n\n五、buildtrees/ - “厨房”\n#作用：编译过程的中间文件buildtrees/└── fmt/    ├── src/                    # 解压后的源码    │   └── fmt-8.0.0/    ├── x64-windows-dbg/        # 调试版编译文件    ├── x64-windows-rel/        # 发布版编译文件    └── install-x64-windows-dbg-out.log  # 安装日志\n\n六、triplets/ - “平台配方”\ntriplets/├── x64-windows.cmake          # 64位Windows动态库├── x64-windows-static.cmake   # 64位Windows静态库├── x86-windows.cmake          # 32位Windows├── x64-linux.cmake           # Linux└── x64-osx.cmake             # macOS\n作用：定义不同平台的构建配置\n# x64-windows.cmake 示例set(VCPKG_TARGET_ARCHITECTURE x64)set(VCPKG_CRT_LINKAGE dynamic)   # 动态链接CRTset(VCPKG_LIBRARY_LINKAGE dynamic) # 动态库\n\n七、scripts/ - “工具脚本”\nscripts/├── buildsystems/              # 构建系统集成│   └── vcpkg.cmake           # CMake工具链文件├── cmake/                     # CMake辅助脚本└── toolchains/               # 交叉编译工具链关键文件：scripts/buildsystems/vcpkg.cmake· CMake通过这个文件集成vcpkg· 设置包含路径、库路径等\n\n八、toolsrc/ - “vcpkg自身源码”\ntoolsrc/├── src/                       # vcpkg C++源码└── include/作用：vcpkg工具自身的源代码 · 编译后生成 vcpkg.exe · 通常不需要关注\n\n九、packages/ 目录 - “打包中转站”\npackages/├── fmt_x64-windows/           # 打包好的fmt库├── zlib_x64-windows/          # 打包好的zlib库├── curl_x64-windows/          ├── detect_compiler_x64-windows/├── vcpkg-cmake_x64-windows/└── vcpkg-cmake-config_x64-windows/\n完整工作流程（结合所有目录）\nvcpkg install fmt:x64-windows         ↓1. ports/fmt/          ← 读取配方         ↓2. downloads/          ← 检查/下载源码         ↓3. buildtrees/fmt/     ← 解压、编译         ↓4. installed/x64-windows/ ← 安装成品         ↓5. 项目通过 scripts/buildsystems/vcpkg.cmake 自动使用\n 操作\n 配方：Ports\n📁 vcpkg ports目录结构详解\nports/库名/├── vcpkg.json          # 🔸 库的元数据和依赖声明（必需）├── portfile.cmake      # 🔸 构建脚本（必需）├── patches/            # 🔸 补丁目录（可选）│   ├── 0001-xxx.patch│   └── 0002-yyy.patch├── CMakeLists.txt      # 🔸 自定义CMake文件（可选）├── usage               # 🔸 库使用说明（可选）└── vcpkg-cmake-wrapper.cmake  # CMake包装器（可选）\n📄 vcpkg.json - 库的&quot;身份证&quot;\n&#123;  &quot;$schema&quot;: &quot;&lt;https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json&gt;&quot;,  &quot;name&quot;: &quot;库名称&quot;,  &quot;version&quot;: &quot;版本号&quot;,  &quot;port-version&quot;: 0,           // vcpkg内部版本（修复bug但不改上游版本时增加）  &quot;description&quot;: &quot;库的描述&quot;,  &quot;homepage&quot;: &quot;官网或仓库URL&quot;,  &quot;license&quot;: &quot;许可证类型&quot;,  &quot;supports&quot;: &quot;支持的条件表达式&quot;,  &quot;dependencies&quot;: [           // 依赖项列表    &#123;      &quot;name&quot;: &quot;依赖库名&quot;,      &quot;host&quot;: false           // true=编译工具依赖，false=运行时库依赖    &#125;  ],  &quot;features&quot;: &#123;               // 可选功能    &quot;feature-name&quot;: &#123;      &quot;description&quot;: &quot;功能描述&quot;,      &quot;dependencies&quot;: []      // 启用此功能时需要额外依赖    &#125;  &#125;,  &quot;default-features&quot;: []      // 默认启用的功能&#125;\n🛠️ portfile.cmake - 构建&quot;配方&quot;\n# 1. 版本处理（如果需要）string(REPLACE ...)  # 转换版本格式# 2. 下载源码vcpkg_from_github(    OUT_SOURCE_PATH SOURCE_PATH    REPO 作者/仓库名    REF 版本标签或commit    SHA512 哈希值    HEAD_REF 主分支名    PATCHES 补丁列表)# 3. 应用额外文件（如果需要）file(COPY &quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/CMakeLists.txt&quot; DESTINATION &quot;$&#123;SOURCE_PATH&#125;&quot;)# 4. 配置vcpkg_cmake_configure(    SOURCE_PATH &quot;$&#123;SOURCE_PATH&#125;&quot;    OPTIONS        -D选项1=值1        -D选项2=值2    OPTIONS_DEBUG   # 调试版特有选项        -D调试选项=值)# 5. 编译和安装vcpkg_cmake_install()# 6. 复制PDB文件（Windows调试符号）vcpkg_copy_pdbs()# 7. 整理配置vcpkg_cmake_config_fixup()# 8. 安装版权文件vcpkg_install_copyright(FILE_LIST &quot;$&#123;SOURCE_PATH&#125;/LICENSE&quot;)\n🩹 patches/ - &quot;创可贴&quot;目录\n补丁文件命名规范：\n0001-简短描述.patch0002-另一修复.patch0003-平台适配.patch\n补丁内容格式（统一差异格式）：\n--- original/文件路径     # 原始文件+++ modified/文件路径     # 修改后文件@@ -行号,行数 +行号,行数 @@ 上下文 保留的行-删除的行+添加的行 更多的上下文\n示例补丁作用：\n# portfile.cmake中引用：PATCHES    0001-fix-windows-build.patch      # 修复Windows编译    0002-cmake-install-prefix.patch   # 修正安装路径    0003-disable-examples.patch       # 禁用示例构建\n 拉取\n📁 操作目录结构\nC:\\\\C++_depend\\\\vcpkg\\\\manual_learning\\\\└── 库名_manual/    ├── src/           # 源码（解压后）    ├── build/         # 构建中间文件    └── installed/     # 最终安装位置\n🔄 完整操作流程\n第1步：选择目标库\n# 查看可用库cd C:\\\\C++_depend\\\\vcpkgdir ports | Select-Object -First 10# 选择简单无依赖的库，如：zlib, fmt, stb\n第2步：分析库配方\n# 查看库的元数据Get-Content ports\\\\zlib\\\\vcpkg.json# 查看构建脚本Get-Content ports\\\\zlib\\\\portfile.cmake# 提取关键信息：# 1. 版本号（version）# 2. 下载方式（vcpkg_from_github/vcpkg_download_distfile）# 3. 仓库/URL信息# 4. 哈希值（SHA512）\n第3步：创建手动构建目录\ncd C:\\\\C++_depend\\\\vcpkg\\\\manual_learning# 创建专属目录$libName = &quot;zlib&quot;mkdir &quot;$&#123;libName&#125;_manual&quot;cd &quot;$&#123;libName&#125;_manual&quot;# 创建标准子目录New-Item -ItemType Directory -Path src, build, installed -Force# 验证结构tree /F\n第4步：提取下载URL并下载\n# 从portfile.cmake提取URL（手动分析）# 常见格式：# GitHub: &lt;https://github.com/作者/仓库/archive/refs/tags/v版本.zip&gt;# 官网: &lt;http://example.com/库名-版本.tar.gz&gt;# 下载示例（zlib 1.3.1）：$url = &quot;&lt;https://github.com/madler/zlib/archive/refs/tags/v1.3.1.zip&gt;&quot;$output = &quot;zlib-1.3.1.zip&quot;# 方法1：Invoke-WebRequestInvoke-WebRequest -Uri $url -OutFile $output# 方法2：如果方法1失败，用System.Net.WebClient$webClient = New-Object System.Net.WebClient$webClient.DownloadFile($url, $output)$webClient.Dispose()# 检查下载文件Get-Item $output | Select-Object Name, Length, LastWriteTime\n第5步：解压源码\n# 方法A：使用7zip（如果有）7z x &quot;zlib-1.3.1.zip&quot; -osrc# 方法B：使用Expand-Archive（适用于.zip）Expand-Archive -Path &quot;zlib-1.3.1.zip&quot; -DestinationPath src# 方法C：手动解压到src目录# 1. 用WinRAR/7-Zip GUI解压# 2. 将解压出的文件夹内容复制到src/# 验证解压结果dir src -Recurse | Select-Object -First 15\n 编译&amp;链接\n🏗️ 库编译流程\n📦 一、编译第三方库步骤\n\n编译源码 → .obj\n\ncd 库源码目录cl /c *.c                # 编译所有.c文件生成.obj\n\n打包.obj → 静态库.lib\n\nlib /OUT:库名.lib *.obj   # 所有.obj打包成一个.lib\n📁 标准目录结构\n创建发布目录：\n库名/├── include/     # 头文件(.h)├── lib/         # 静态库(.lib)├── bin/         # 动态库(.dll)└── share/       # 文档等\n🔧 完整示例（zlib）\n# 1. 进入源码目录cd zlib-1.3.1# 2. 编译所有源文件cl /c *.c# 3. 创建静态库lib /OUT:zlib.lib *.obj# 4. 创建发布目录mkdir ..\\\\zlib_dist\\\\includemkdir ..\\\\zlib_dist\\\\lib# 5. 复制文件copy *.h ..\\\\zlib_dist\\\\include\\\\copy zlib.lib ..\\\\zlib_dist\\\\lib\\\\\n📝 使用已编译库\n🚀 二、编译自己的代码（使用第三方库）\n\n编译你的代码 → .obj\n\n# 指定头文件路径cl /c /I库目录\\\\include 你的代码.cpp\n\n链接库文件 → .exe\n\n# 指定库文件link 你的代码.obj 库目录\\\\lib\\\\库名.lib /OUT:程序.exe\n📦 实际例子（使用zlib）\n# 1. 编译你的程序（需要zlib.h）cl /c /Izlib_dist\\\\include test_zlib.cpp# 2. 链接zlib库link test_zlib.obj zlib_dist\\\\lib\\\\zlib.lib /OUT:test.exe\n🎯 一句话总结\n编译：cl /c /I头文件路径 代码.cpp链接：link 你的代码.obj 库路径\\\\库名.lib /OUT:程序名.exe\n🔄 三、完整工作流总结\n1. 编译第三方库：   源码.c → cl /c → .obj → lib → .lib2. 组织文件：   .h → include目录   .lib → lib目录3. 编译你的代码：   你的代码.cpp + /Iinclude → cl /c → 你的代码.obj4. 链接：   你的代码.obj + lib\\\\库名.lib → link → 程序.exe\n VS链接\n\n打开项目属性\n\n方法1：右键项目 → 属性方法2：菜单栏 → 项目 → TestZlibInVS属性\n\n配置头文件路径\n\n左侧：配置属性 → C/C++ → 常规右侧：附加包含目录 → 编辑添加：C:\\\\C++_depend\\\\vcpkg\\\\manual_learning\\\\zlib_complete\\\\include\n\n配置库文件路径\n\n左侧：配置属性 → 链接器 → 常规右侧：附加库目录 → 编辑添加：C:\\\\C++_depend\\\\vcpkg\\\\manual_learning\\\\zlib_complete\\\\lib\n\n添加要链接的库\n\n左侧：配置属性 → 链接器 → 输入右侧：附加依赖项 → 编辑添加：zlib.lib\n CMake\n CMake介绍\n一、对象（文件夹）\nmy_project/                         # 项目根目录├── CMakeLists.txt                  # 主CMake文件（必须！）├── README.md                       # 项目说明├── LICENSE                         # 许可证├── .gitignore                      # Git忽略文件│├── include/                        # 公共头文件（对外暴露的接口）│   └── my_project/│       ├── core.h│       └── utils.h│├── src/                           # 源代码目录│   ├── main.c                     # 主程序入口│   ├── core.c                     # 核心实现│   ├── utils.c                    # 工具函数│   └── internal/                  # 内部头文件（不对外暴露）│       └── internal_utils.h│├── libs/                          # 第三方库或子模块│   ├── tinyxml2/                  # 第三方库1│   └── my_math/                   # 自己的库模块│       ├── CMakeLists.txt         # 子模块有自己的CMakeLists│       ├── include/│       └── src/│├── tests/                         # 测试代码│   ├── CMakeLists.txt│   ├── test_core.c│   └── test_utils.c│├── examples/                      # 示例代码│   ├── demo1.c│   └── demo2.c│├── docs/                          # 文档│   └── api.md│└── build/                         # 构建目录（通常.gitignore忽略）    ├── bin/                       # 可执行文件输出目录    │   ├── my_project             # Linux可执行文件    │   └── my_project.exe         # Windows可执行文件    ├── lib/                       # 库文件输出目录    │   ├── libmy_math.a           # 静态库    │   └── libmy_math.so          # 动态库    └── ...CMake生成的各种文件\n二、Windows流程\nREM 1. 进入项目目录cd Desktop\\hello_worldREM 2. 使用Visual Studio生成器cmake -B build -S . -G &quot;Visual Studio 17 2022&quot; -A x64REM 3. 编译Release版本cmake --build build --config ReleaseREM 4. 运行build\\Release\\hello.exe\nLinux流程\n# 1. 进入项目目录cd ~/hello_world# 2. 生成构建系统（默认Unix Makefiles）cmake -B build -S .# 3. 编译cmake --build build# 或者传统方式：cd buildmake -j4  # 4线程并行编译# 4. 运行./build/hello# 或如果设置了输出目录：./build/bin/hello\n三、结果：生成文件夹\ncalculator/build/             ├── CMakeCache.txt       #配置缓存    ├── CMakeFiles/              ├── calc.exe       #可执行文件             ├── calc_main.obj            ├── math_ops.obj             └── Makefile 或 .sln       #cmake内部文件  \n CMakeLists.text\n# ==================== 第一部分：基础设置 ====================# 1. CMake版本要求（必须第一行）cmake_minimum_required(VERSION 3.15)# 2. 项目定义project(MyProject    VERSION 1.0.0    DESCRIPTION &quot;My C Project&quot;    LANGUAGES C    HOMEPAGE_URL &quot;https://github.com/me/myproject&quot;)# ==================== 第二部分：目录设置 ====================# 3. 输出目录设置（可选但推荐）set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/bin)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)# 4. 包含目录include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src)# ==================== 第三部分：编译器选项 ====================# 5. 全局编译选项add_compile_options(    -Wall    -Wextra    -Werror    -O2)# 6. 根据平台调整if(MSVC)    add_compile_options(/W4)else()    add_compile_options(-std=c11)endif()# ==================== 第四部分：目标定义 ====================# 7. 添加库add_library(math_utils STATIC src/math_utils.c)# 8. 库的特殊设置target_include_directories(math_utils PUBLIC include)target_compile_options(math_utils PRIVATE -O3)# 9. 添加可执行文件add_executable(my_app src/main.c)# 10. 链接库target_link_libraries(my_app PRIVATE math_utils)# ==================== 第五部分：安装配置 ====================# 11. 安装规则（make install时使用）install(TARGETS my_app    RUNTIME DESTINATION bin    LIBRARY DESTINATION lib    ARCHIVE DESTINATION lib)# 12. 安装头文件install(FILES include/math_utils.h DESTINATION include)# ==================== 第六部分：测试配置 ====================# 13. 启用测试enable_testing()# 14. 添加测试add_test(NAME basic_test COMMAND my_app)# ==================== 第七部分：查找依赖 ====================# 15. 查找系统库find_package(Threads REQUIRED)target_link_libraries(my_app PRIVATE Threads::Threads)# 16. 查找自定义包find_path(MYLIB_INCLUDE_DIR mylib.h)find_library(MYLIB_LIBRARY mylib)\n cmake语法\n🎯 项目定义\ncmake_minimum_required(VERSION 3.10)  # 必须第一行project(项目名 [VERSION 版本号] [LANGUAGES CXX])  # 定义项目\n🔧 变量操作\nset(变量名 &quot;值&quot;)                    # 设置变量$&#123;变量名&#125;                          # 使用变量unset(变量名)                       # 删除变量list(APPEND 列表 元素)              # 列表追加\n📁 文件与目录\nadd_executable(目标名 文件1.cpp 文件2.cpp)  # 创建可执行文件add_library(库名 [STATIC|SHARED] 源文件)    # 创建库target_include_directories(目标名    PUBLIC|PRIVATE|INTERFACE 目录1 目录2)   # 添加包含目录target_link_libraries(目标名 库1 库2)        # 链接库link_directories(目录)                      # 添加库搜索目录\n🔍 查找包\nfind_package(包名 [REQUIRED] [CONFIG])      # 查找包find_library(变量名 库名 [路径])            # 查找库文件find_path(变量名 头文件名 [路径])           # 查找头文件路径find_program(变量名 程序名 [路径])          # 查找可执行程序\n⚙️ 编译选项\nadd_compile_options(-Wall -Wextra)         # 添加编译选项add_definitions(-D宏名)                    # 添加预定义宏target_compile_definitions(目标名 PRIVATE 宏) # 目标特定宏set(CMAKE_CXX_STANDARD 17)                 # C++标准版本\n🔄 流程控制\nif(条件)    # ...elseif(其他条件)    # ...else()    # ...endif()foreach(变量 IN [ITEMS|LISTS|RANGE])    # ...endforeach()while(条件)    # ...endwhile()\n📦 函数与宏\nfunction(函数名 参数1 参数2)    # $&#123;ARGV&#125; 所有参数    # $&#123;ARGN&#125; 额外参数    # $&#123;参数1&#125; 命名参数endfunction()macro(宏名 参数)    # 宏与函数类似，但不同作用域    # ...endmacro()\n🎪 生成器表达式\n$&lt;条件:值&gt;          # 条件表达式$&lt;CONFIG:Debug&gt;    # 当前配置是Debug$&lt;PLATFORM_ID:Windows&gt;  # 平台判断$&lt;TARGET_FILE:目标&gt;    # 目标文件路径$&lt;TARGET_FILE_DIR:目标&gt; # 目标文件目录\n📤 输出与信息\nmessage([STATUS|WARNING|ERROR|FATAL_ERROR] &quot;消息&quot;)\n🔗 常用条件判断\nif(WIN32)          # Windows系统if(APPLE)          # Mac系统if(UNIX)           # Linux/Unix系统if(MSVC)           # Visual Studio编译器if(CMAKE_BUILD_TYPE STREQUAL &quot;Debug&quot;)  # 构建类型if(DEFINED 变量名)  # 变量是否定义if(EXISTS 文件路径) # 文件是否存在\n📊 特殊变量\n$&#123;CMAKE_SOURCE_DIR&#125;      # CMakeLists.txt所在目录$&#123;CMAKE_BINARY_DIR&#125;      # build目录$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;  # 当前处理的CMakeLists.txt目录$&#123;CMAKE_CURRENT_BINARY_DIR&#125;  # 当前输出目录$&#123;PROJECT_SOURCE_DIR&#125;    # 项目根目录$&#123;PROJECT_BINARY_DIR&#125;    # 项目build目录$&#123;CMAKE_BUILD_TYPE&#125;      # 构建类型(Debug/Release)$&#123;CMAKE_CXX_COMPILER&#125;    # C++编译器（CMake自带）$&#123;CMAKE_TOOLCHAIN_FILE&#125;  # 工具链文件（CMake自带）\n🛠️ 文件操作\nfile(GLOB 变量 &quot;模式&quot;)          # 通配符匹配文件file(GLOB_RECURSE 变量 &quot;模式&quot;)   # 递归匹配file(COPY 文件 DESTINATION 目录) # 复制文件configure_file(输入文件 输出文件) # 配置时复制并替换变量\n🎨 目标属性\nget_target_property(变量 目标 属性)    # 获取目标属性set_target_properties(目标 PROPERTIES 属性 值) # 设置目标属性\n📝 一句话总结常用命令\n# 创建程序：add_executable(名字 文件)# 添加头文件：target_include_directories(名字 PRIVATE 目录)# 链接库：target_link_libraries(名字 库名)# 设置选项：set(选项 值)# 条件判断：if() ... endif()# 循环：foreach() ... endforeach()\n 实际使用\n第一步：打开终端\n# 必须用这个！&quot;x64 Native Tools Command Prompt for VS 2022&quot;\n第二步：进入项目目录\ncd C:\\Users\\34035\\Graphics\n第三步：清理和配置（第一次或修改CMake后）\n# 1. 删除旧的构建目录rmdir /s /q build# 2. 创建新的构建目录mkdir buildcd build# 3. 配置CMake（关键！）cmake .. -DCMAKE_TOOLCHAIN_FILE=C:\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake\n第四步：编译项目\n# 4. 编译（在build目录中）cmake --build .# 或者简写cmake --build . --config Debug\n第五步：运行程序\n# 5. 运行可执行文件.\\bin\\ComputerGraphics.exe\n","tags":["CMake"]},{"title":"图像处理&纹理加载","url":"/2026/02/24/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E7%BA%B9%E7%90%86%E5%8A%A0%E8%BD%BD/","content":" 图像文件格式\n 一、图像位数与像素\n\n🎯 核心：位数 = 调色盘大小\n一个像素就是一个格子，只能涂一种颜色。\n位数决定“这种颜色可以从多少种里选”。\n\n📊 位数对比表\n位数 每像素字节 颜色数量       调色盘大小       效果\n8位  1字节     256色          256格      可见色块、渐变色带\n16位 2字节     65536色       6.5万格      老游戏，轻微色带\n24位 3字节   1677万色        1677万格      真彩色，平滑渐变\n32位 4字节  1677万色+透明度  1677万格+Alpha 真彩色+半透明\n\n📏 位数本质：切分亮度\n把0-100%的亮度切成多少份：\n位数 份数    台阶粗细   用途\n1位  2份     纯黑/纯白 黑白图\n8位  256份   肉眼极限  JPG、网页\n10位 1024份  专业显示器  HDR\n12位 4096份  RAW格式  摄影后期\n16位 65536份 无损编辑   PS修图\n24位 = 每个通道8位 = 256级亮度 × 3个通道\n不是1677万种独立的颜色，是256级红 × 256级绿 × 256级蓝的组合。\n\n💎 一句话精髓\n位数不是决定“涂几次颜色”，是决定“调色盘里有多少格颜色可选”。\n24位的1677万色不是物理存在，是256×256×256的数学组合。\n BMP\n 一、BMP是什么？\nBMP = Bitmap = 位图 = Windows的亲儿子\n✅ 不压缩 → 读出来就是RGB数组\n✅ 结构极简 → 54字节头 + 像素数据\n✅ 1990年至今没变过\n❌ 文件巨大 → 一张4K照片几百MB\n❌ 只有Windows原生支持\n​\n 二、文件结构（总共就两部分）\nBMP文件\n├── 文件头 (14字节) — 你是谁？\n├── 信息头 (40字节) — 你多大？\n└── 像素数据 (XXX字节) — 你的肉！\n​\n2.1 文件头（BITMAPFILEHEADER）\ntypedef struct &#123;    char signature[2];      // 固定为 &#x27;B&#x27; &#x27;M&#x27; (0x42 0x4D)    int fileSize;          // 整个文件大小（字节）    int reserved;          // 保留，必须为0    int dataOffset;        // 像素数据的起始位置（通常54）&#125; BMPFileHeader;// 大小：2+4+4+4 = 14字节// 注意：结构体可能有内存对齐，不要直接fread！\n​\n二进制看一眼：\n42 4D                  → “BM”\n36 10 0E 00            → 文件大小 = 0x000E1036 = 921654字节\n00 00 00 00            → 保留\n36 00 00 00            → 数据偏移 = 0x36 = 54字节\n​\n2.2 信息头（BITMAPINFOHEADER）\ntypedef struct &#123;    int headerSize;        // 信息头大小 = 40    int width;            // 图像宽度（像素）    int height;           // 图像高度（像素）    short planes;         // 固定为1    short bitsPerPixel;   // 24(RGB) 或 32(RGBA) 或 8(灰度)    int compression;      // 0=不压缩，1=RLE8，2=RLE4    int imageSize;        // 像素数据大小（字节）    int xPixelsPerMeter;  // 水平分辨率（通常0）    int yPixelsPerMeter;  // 垂直分辨率（通常0）    int colorsUsed;       // 调色板颜色数（24位=0）    int colorsImportant;  // 重要颜色数（0=全都重要）&#125; BMPInfoHeader;// 大小：40字节​关键字段：字段 常见值 含义bitsPerPixel 24 真彩色，BGR格式bitsPerPixel 32 带Alpha，BGRAcompression 0 不压缩，直接读imageSize 宽×高×3 24位图大小\n 三、像素数据布局（坑！）\n3.1 BGR顺序（不是RGB！）\n// 每个像素3字节，顺序是：\n[B] [G] [R]   ← BMP文件里这样存\n[R] [G] [B]   ← OpenGL要这样\n// 必须交换！\nfor (int i = 0; i &lt; dataSize; i += 3) &#123;    std::swap(data[i], data[i + 2]);  // B ↔ R&#125;\n​\n3.2 行对齐（4字节倍数）\n// BMP每行必须是4的倍数，不够就补0宽度 = 3像素 → 3×3=9字节 → 补到12字节// 计算实际每行大小：int bytesPerRow = ((bitsPerPixel * width + 31) / 32) * 4;// 或简单点：int bytesPerRow = (width * 3 + 3) &amp; ~3;  // 向上取整到4的倍数// 读数据时要跳过补的0！\n​\n3.3 原点位置（左下角）\n// height &gt; 0：图像从左下角开始存\n第一行 → 最下面一行\n最后一行 → 最上面一行\n// OpenGL纹理原点在左下角 → 正好匹配！\n// 不用翻转！\n// 但STB默认要翻转，因为它习惯左上角\nstbi_set_flip_vertically_on_load(true);  // BMP不需要！\n​\n 四、完整读取代码\n#include &lt;fstream&gt;#include &lt;vector&gt;unsigned char* loadBMP(const char* path, int&amp; width, int&amp; height) &#123;    std::ifstream file(path, std::ios::binary);    if (!file.is_open()) return nullptr;    // 1. 读文件头    char signature[2];    file.read(signature, 2);    if (signature[0] != &#x27;B&#x27; || signature[1] != &#x27;M&#x27;) return nullptr;    int fileSize, dataOffset;    file.read((char*)&amp;fileSize, 4);    file.read((char*)&amp;fileSize, 4);  // reserved，跳过    file.read((char*)&amp;dataOffset, 4);    // 2. 读信息头    int headerSize;    file.read((char*)&amp;headerSize, 4);    short planes, bitsPerPixel;    int compression, imageSize;    file.read((char*)&amp;width, 4);    file.read((char*)&amp;height, 4);    file.read((char*)&amp;planes, 2);    file.read((char*)&amp;bitsPerPixel, 2);    file.read((char*)&amp;compression, 4);    file.read((char*)&amp;imageSize, 4);    // 3. 只支持24位不压缩BMP    if (bitsPerPixel != 24 || compression != 0) return nullptr;    // 4. 跳转到像素数据    file.seekg(dataOffset, std::ios::beg);    // 5. 计算实际大小（考虑行对齐）    int bytesPerRow = (width * 3 + 3) &amp; ~3;    int dataSize = bytesPerRow * abs(height);    std::vector&lt;unsigned char&gt; bmpData(dataSize);    file.read((char*)bmpData.data(), dataSize);    // 6. 分配OpenGL格式的内存    unsigned char* glData = new unsigned char[width * height * 3];    // 7. 去掉补的0 + BGR转RGB    for (int y = 0; y &lt; abs(height); y++) &#123;        for (int x = 0; x &lt; width; x++) &#123;            int bmpIndex = y * bytesPerRow + x * 3;            int glIndex;            // 处理原点方向            if (height &gt; 0) &#123;  // 左下原点                glIndex = (abs(height) - 1 - y) * width * 3 + x * 3;            &#125; else &#123;           // 左上原点                glIndex = y * width * 3 + x * 3;            &#125;            // BGR → RGB            glData[glIndex + 2] = bmpData[bmpIndex + 0];  // R ← B            glData[glIndex + 1] = bmpData[bmpIndex + 1];  // G ← G            glData[glIndex + 0] = bmpData[bmpIndex + 2];  // B ← R        &#125;    &#125;    width = abs(width);   // 宽总是正    height = abs(height); // 高取绝对值    return glData;&#125;\n 五、OpenGL中使用\n// 1. 加载BMPint w, h;unsigned char* data = loadBMP(&quot;earth.bmp&quot;, w, h);// 2. 创建纹理unsigned int texture;glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);// 3. 上传数据glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, data);// 4. 设置参数glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 5. 释放内存delete[] data;\n 六、常见问题\nQ1：为什么读出来是颠倒的？\nA： BMP原点在左下角，如果你习惯左上角，会感觉反了。\n// 解决方案：读的时候翻转Y\nglIndex = (height - 1 - y) * width * 3 + x * 3;\n​\nQ2：为什么颜色不对？\nA： BMP是BGR，OpenGL要RGB，忘了交换！\n// 必须交换！\nglData[glIndex + 0] = bmpData[bmpIndex + 2];  // RglData[glIndex + 1] = bmpData[bmpIndex + 1];  // GglData[glIndex + 2] = bmpData[bmpIndex + 0];  // B\n​\nQ3：为什么有黑线？\nA： 每行补的0没去掉！\n// BMP每行4字节对齐，直接按width×3读会带上补的0\n// 必须用bytesPerRow一行一行读\n​\nQ4：32位BMP呢？\nA： 原理一样，每像素4字节（BGRA），交换成RGBA。\nglTexImage2D(..., GL_RGBA, ...);\n 七、BMP原点与高度字段\nBMP文件存储本质\nBMP文件里只有二进制，没有“负号”\n文件偏移  存储的4字节    解释为int    含义\n22-25   02 00 00 00   +2      高度2，从下往上存\n22-25   FE FF FF FF   -2      高度2，从上往下存\n负号不存在文件里，是你用有符号int读出来的。\n两个过程，同一字段\n1️⃣ 存文件时（别人写BMP）\n高度值 像素顺序 文件第一行是\n正数 下→上 底部\n负数 上→下 顶部\n2️⃣ 读文件时（你写loadBMP）\n读到的高度 含义 你需要\n正数 文件是下→上 翻转（倒序）\n负数 文件是上→下 不翻转（直接放）\n TGA\n 一、TGA是什么？\nTGA = Truevision Graphics Adapter = 塔加格式\n✅ 可以压缩（RLE游程编码）✅ 支持透明通道（Alpha）✅ OpenGL教材最爱✅ 结构比BMP乱，但依然简单❌ 现代应用少（被PNG取代）❌ 字节序混乱（全是小端）\n\n 二、文件结构（比BMP乱多了）\nTGA文件├── 文件头 (18字节) — 又小又乱├── 图像ID (可选)   — 描述信息├── 调色板 (可选)   — 索引颜色└── 像素数据        — 可能压缩！\n2.1 文件头（18字节，全小端）\n#pragma pack(push, 1)  // 强制1字节对齐！typedef struct &#123;    char idLength;        // 图像ID长度 (0-255)    char colorMapType;    // 调色板类型 (0=无，1=有)    char imageType;       // 图像类型 ⭐ 最重要！    // 调色板信息（如果colorMapType=1）    short colorMapOffset; // 调色板起始索引    short colorMapLength; // 调色板颜色数    char colorMapBits;    // 调色板位深(16/24/32)    // 图像信息    short xOrigin;        // X起点（通常0）    short yOrigin;        // Y起点（通常0）    short width;          // 宽度 ⭐    short height;         // 高度 ⭐    char bitsPerPixel;    // 位深 ⭐ (24/32/8/16)    char descriptor;      // 描述符 ⭐ Alpha位数 + 原点方向&#125; TGAHeader;#pragma pack(pop)// 大小：1+1+1+2+2+1+2+2+2+2+1+1 = 18字节\n2.2 imageType（核心！）\n值 含义         压缩   颜色\n0 无图像数据      -     -\n1 调色板RGB     不压缩 索引色\n2 真彩色RGB     不压缩 最常用\n3 灰度图        不压缩 黑白\n9 调色板RGB    RLE压缩 索引色\n10 真彩色RGB   RLE压缩 也很常用\n11 灰度图      RLE压缩 黑白\n\n 三、不压缩TGA（Type 2，最简单）\n3.1 像素数据布局\n// 24位RGB：BGR顺序（和BMP一样！）[B] [G] [R]  [B] [G] [R] ...// 32位RGBA：BGRA顺序[B] [G] [R] [A]  [B] [G] [R] [A] ...// 16位RGB：RGB 5:6:5（少用）// 8位灰度：单字节\n3.2 原点方向（descriptor位5）\ndescriptor &amp; 0x20  // 第5位（从0开始）// 0 = 左下原点（和BMP一样）// 1 = 左上原点（和PNG一样）// 读取时处理：bool topLeft = (header.descriptor &amp; 0x20) != 0;if (topLeft) &#123;    // 需要翻转Y！&#125;\n3.3 Alpha位数（descriptor低4位）\nint alphaBits = header.descriptor &amp; 0x0F;// 24位图：alphaBits = 0// 32位图：alphaBits = 8\n\n 四、不压缩TGA读取代码（Type 2）\nunsigned char* loadUncompressedTGA(const char* path, int&amp; width, int&amp; height, int&amp; channels) &#123;    FILE* file = fopen(path, &quot;rb&quot;);    if (!file) return nullptr;    // 1. 读头    TGAHeader header;    fread(&amp;header, 18, 1, file);    // 2. 只处理Type 2    if (header.imageType != 2) &#123;        fclose(file);        return nullptr;    &#125;    // 3. 跳过图像ID（如果有）    if (header.idLength &gt; 0) &#123;        fseek(file, header.idLength, SEEK_CUR);    &#125;    // 4. 跳过调色板（如果有）    if (header.colorMapType == 1) &#123;        int paletteSize = header.colorMapLength * (header.colorMapBits / 8);        fseek(file, paletteSize, SEEK_CUR);    &#125;    // 5. 获取图像信息    width = header.width;    height = header.height;    channels = header.bitsPerPixel / 8;  // 3或4    // 6. 读像素数据    int dataSize = width * height * channels;    unsigned char* data = new unsigned char[dataSize];    fread(data, dataSize, 1, file);    fclose(file);    // 7. BGR → RGB（OpenGL需要）    for (int i = 0; i &lt; dataSize; i += channels) &#123;        std::swap(data[i], data[i + 2]);  // B ↔ R    &#125;    // 8. 处理原点（TGA可能是左上角）    bool topLeft = (header.descriptor &amp; 0x20) != 0;    if (topLeft) &#123;        // 翻转Y轴        unsigned char* flipped = new unsigned char[dataSize];        int rowSize = width * channels;        for (int y = 0; y &lt; height; y++) &#123;            memcpy(flipped + (height - 1 - y) * rowSize,                   data + y * rowSize,                   rowSize);        &#125;        delete[] data;        data = flipped;    &#125;    return data;&#125;\n\n 五、RLE压缩TGA（Type 10，重点！）\n5.1 RLE原理（游程编码）\n// 连续相同的颜色 → 打包成 [标记][颜色]// 原始数据：[FF][FF][FF][00][11][22][33][44][55]... 蓝   蓝  蓝   红  绿  蓝   红  绿  蓝 ...// RLE压缩后：[0x83][FF]        // 3个蓝色 (0x83 = 0x80 | 3)[0x01][00]        // 1个红色[0x05][11][22][33][44][55]  // 5个不重复  ↑                 ↑ 0x80+1=0x81?      不对，仔细看！\n5.2 TGA的RLE包格式\n每个包 = 1字节标记 + n字节数据标记字节：bit7 = 1 → 重复包 (Run-length packet)        ↓   [1][计数]  // 计数 = 低7位 + 1bit7 = 0 → 原始包 (Raw packet)        ↓   [0][计数]  // 计数 = 低7位 + 1\n5.3 解压算法\nunsigned char* decodeRLETGA(FILE* file, int width, int height, int channels) &#123;    int pixelCount = width * height;    int dataSize = pixelCount * channels;    unsigned char* data = new unsigned char[dataSize];    int currentPixel = 0;    unsigned char packetHeader;    unsigned char pixel[4];  // 最多BGRA    while (currentPixel &lt; pixelCount) &#123;        // 1. 读包标记        fread(&amp;packetHeader, 1, 1, file);        int count = (packetHeader &amp; 0x7F) + 1;  // 低7位+1        if (packetHeader &amp; 0x80) &#123;  // 重复包            // 读一个像素，重复count次            fread(pixel, channels, 1, file);            for (int i = 0; i &lt; count &amp;&amp; currentPixel &lt; pixelCount; i++) &#123;                memcpy(data + currentPixel * channels, pixel, channels);                currentPixel++;            &#125;        &#125; else &#123;  // 原始包            // 读count个像素，直接复制            fread(data + currentPixel * channels, channels, count, file);            currentPixel += count;        &#125;    &#125;    return data;&#125;\n\n 六、完整TGA加载器（支持Type 2和10）\nunsigned char* loadTGA(const char* path, int&amp; width, int&amp; height, int&amp; channels) &#123;    FILE* file = fopen(path, &quot;rb&quot;);    if (!file) return nullptr;    // 读头    TGAHeader header;    fread(&amp;header, 18, 1, file);    // 只支持真彩色    if (header.imageType != 2 &amp;&amp; header.imageType != 10) &#123;        fclose(file);        return nullptr;    &#125;    // 跳过图像ID    if (header.idLength &gt; 0) &#123;        fseek(file, header.idLength, SEEK_CUR);    &#125;    // 跳过调色板（我们不用）    if (header.colorMapType == 1) &#123;        int paletteSize = header.colorMapLength * (header.colorMapBits / 8);        fseek(file, paletteSize, SEEK_CUR);    &#125;    width = header.width;    height = header.height;    channels = header.bitsPerPixel / 8;    // 解压/读取像素    unsigned char* data;    if (header.imageType == 10) &#123;  // RLE压缩        data = decodeRLETGA(file, width, height, channels);    &#125; else &#123;  // 不压缩        int dataSize = width * height * channels;        data = new unsigned char[dataSize];        fread(data, dataSize, 1, file);    &#125;    fclose(file);    // BGR → RGB    for (int i = 0; i &lt; width * height * channels; i += channels) &#123;        std::swap(data[i], data[i + 2]);    &#125;    // 处理原点    bool topLeft = (header.descriptor &amp; 0x20) != 0;    if (topLeft) &#123;        int rowSize = width * channels;        unsigned char* flipped = new unsigned char[width * height * channels];        for (int y = 0; y &lt; height; y++) &#123;            memcpy(flipped + (height - 1 - y) * rowSize,                   data + y * rowSize,                   rowSize);        &#125;        delete[] data;        data = flipped;    &#125;    return data;&#125;\n\n七、OpenGL中使用\nint w, h, channels;unsigned char* data = loadTGA(&quot;earth.tga&quot;, w, h, channels);GLenum format = (channels == 4) ? GL_RGBA : GL_RGB;glTexImage2D(GL_TEXTURE_2D, 0, format, w, h, 0, format, GL_UNSIGNED_BYTE, data);delete[] data;\n JPG\n 一、JPG是什么？\nJPG = JPEG = Joint Photographic Experts Group = 联合图像专家组\n✅ 压缩率极高（照片10:1 ~ 20:1）✅ 互联网事实标准✅ 24位真彩色❌ **有损压缩**（解压后≠原图）❌ **极其复杂**（千万别自己写！）❌ 不支持透明通道❌ 边缘有鬼影（振铃效应）\n\n 二、JPG的核心哲学\n2.1 人眼特性（JPG的作弊依据）\n人眼对亮度敏感，对颜色不敏感人眼对低频敏感，对高频不敏感人眼对平滑敏感，对噪点不敏感→ 丢掉人眼看不清的数据！→ 丢掉人眼不在意的数据！\n2.2 JPG压缩流程（5步）\nRGB图片    ↓ ① 颜色空间转换YCbCr（亮度+色度）    ↓ ② 下采样（丢掉色度）4:4:4 → 4:2:0（色度减半）    ↓ ③ DCT变换（时空→频率）8x8系数块    ↓ ④ 量化（丢掉高频）除以量化表→取整    ↓ ⑤ 哈夫曼编码（无损压缩）JPEG文件\n\n 三、第1步：颜色空间转换\n3.1 RGB → YCbCr\n// RGB转亮度+色度Y  =  0.299 * R + 0.587 * G + 0.114 * BCb = -0.169 * R - 0.331 * G + 0.500 * B + 128Cr =  0.500 * R - 0.419 * G - 0.081 * B + 128// YCbCr → RGB（解码用）R = Y + 1.402 * (Cr - 128)G = Y - 0.344 * (Cb - 128) - 0.714 * (Cr - 128)B = Y + 1.772 * (Cb - 128)\n为什么？\nY（亮度）→ 人眼敏感 → 保留全部细节Cb/Cr（色度）→ 人眼不敏感 → 可以压缩\n\n 四、第2步：下采样（色度压缩）\n4.1 采样格式\n4:4:4 → 不压缩，每个像素都有Y,Cb,Cr4:2:2 → 水平减半，每2个像素共享Cb,Cr4:2:0 → 水平垂直都减半，每4个像素共享Cb,Cr ⭐最常用4:1:1 → 水平1/4\n4.2 4:2:0 示意图\n像素矩阵：         Y分量：完整       Cb/Cr分量：1/4[Y][Y][Y][Y]      [Y][Y][Y][Y]      [Cb][ ][ ][ ][Y][Y][Y][Y]      [Y][Y][Y][Y]      [ ][ ][ ][ ][Y][Y][Y][Y]  →   [Y][Y][Y][Y]  →   [ ][ ][ ][ ][Y][Y][Y][Y]      [Y][Y][Y][Y]      [ ][ ][ ][ ]每4个Y共享1个Cb和1个Cr → 数据量减半！\n\n 五、第3步：DCT变换（核心难点）\n5.1 什么是DCT？\nDCT = 离散余弦变换 = 把8x8像素块变成8x8频率系数\n空间域（像素值）：         频率域（DCT系数）：[89 78 76 ...]           [2350 123 -45 ...][90 77 75 ...]    →      [67   -12  8  ...][88 79 77 ...]           [-23   5  -2  ...][...]                    [...]低频（左上角）→ 亮度变化平缓的区域高频（右下角）→ 边缘、纹理、噪点\n5.2 DCT公式（看看就好，别背！）\n// 正向DCT（8x8）F(u,v) = 1/4 * C(u) * C(v) *         ΣΣ f(x,y) * cos((2x+1)uπ/16) * cos((2y+1)vπ/16)// 反向DCT（解码用）f(x,y) = 1/4 * ΣΣ C(u) * C(v) *         F(u,v) * cos((2x+1)uπ/16) * cos((2y+1)vπ/16)// C(u) = 1/√2 当u=0，否则 = 1\n5.3 直观理解\n// 8x8的DCT基函数（可视化）u=0,v=0: ████████  → 直流分量（平均亮度）u=1,v=0: ▆▆▇▇████  → 水平渐变u=0,v=1: ▆▇█▇▆▅▄▃  → 垂直渐变u=1,v=1: ▅▆▇█▇▆▅▄  → 对角线渐变... 越往后越高频\n\n 六、第4步：量化（丢掉数据！）\n6.1 量化表\n// 亮度量化表（JPEG标准，50%质量）static int quant_luminance[8][8] = &#123;    &#123;16, 11, 10, 16, 24, 40, 51, 61&#125;,    &#123;12, 12, 14, 19, 26, 58, 60, 55&#125;,    &#123;14, 13, 16, 24, 40, 57, 69, 56&#125;,    &#123;14, 17, 22, 29, 51, 87, 80, 62&#125;,    &#123;18, 22, 37, 56, 68, 109, 103, 77&#125;,    &#123;24, 35, 55, 64, 81, 104, 113, 92&#125;,    &#123;49, 64, 78, 87, 103, 121, 120, 101&#125;,    &#123;72, 92, 95, 98, 112, 100, 103, 99&#125;&#125;;// 色度量化表（系数更大→丢更多）static int quant_chrominance[8][8] = &#123;    &#123;17, 18, 24, 47, 99, 99, 99, 99&#125;,    &#123;18, 21, 26, 66, 99, 99, 99, 99&#125;,    &#123;24, 26, 56, 99, 99, 99, 99, 99&#125;,    &#123;47, 66, 99, 99, 99, 99, 99, 99&#125;,    &#123;99, 99, 99, 99, 99, 99, 99, 99&#125;,    // ... 全是99，高频全丢！&#125;;\n6.2 量化过程\n// DCT系数矩阵float dct[8][8] = &#123;    &#123;2350.5, 123.2, -45.3, ...&#125;,    &#123;67.3, -12.1, 8.7, ...&#125;,    // ...&#125;;// 量化：系数 / 量化表，然后取整int quantized[8][8];for (int i = 0; i &lt; 8; i++) &#123;    for (int j = 0; j &lt; 8; j++) &#123;        quantized[i][j] = round(dct[i][j] / quant_luminance[i][j]);    &#125;&#125;// 结果：很多高频系数变成0！[147][11][-5][0][0][0][0][0][6][-1][0][0][0][0][0][0][-2][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]... 全是0\n6.3 质量参数（0-100）\n// Q = 质量（越小压缩越狠，画质越差）if (Q &lt; 50) &#123;    scale = 5000 / Q;   // Q=10 → scale=500&#125; else &#123;    scale = 200 - 2*Q;  // Q=90 → scale=20&#125;// 量化表 = (标准表 * scale + 50) / 100// Q=90: 量化表几乎都是1 → 近乎无损// Q=10: 量化表×50 → 全变0 → 马赛克\n\n 七、第5步：哈夫曼编码（无损压缩）\n7.1 Zigzag扫描\n// 把8x8矩阵变成1x64序列，低频在前0,0 → 0,1 → 1,0 → 2,0 → 1,1 → 0,2 → ...// 目的：让连续的0都凑到一起[147][11][6][-5][-1][-2][0][0][0][0]...  ↑                              ↑  DC系数                         AC系数全是0\n7.2 DC系数编码（差分编码）\n// 当前块的DC系数 - 上一个块的DC系数 = 差值// 差值更小 → 更短哈夫曼码// 例：块1 DC = 147 → 编码 147块2 DC = 152 → 差值 +5 → 编码 5块3 DC = 149 → 差值 -3 → 编码 -3\n7.3 AC系数编码（游程编码）\n// 格式：(连续0的个数, 下一个非0值)[11,6,-5,-1,-2,0,0,0,0,0,3,...] ↓(0,11) (0,6) (0,-5) (0,-1) (0,-2) (5,3) ...// (0,0) = 块结束（后面全是0）\n7.4 哈夫曼表\n// JPEG标准定义了固定的哈夫曼表（也可自定义）亮度DC表：0x00 → 00        (差值0)0x01 → 010       (差值1)0x02 → 011       (差值2)0x03 → 100       (差值3)// ...亮度AC表：(0,1) → 00       (1个非0值)(0,2) → 01       (2个非0值)(1,1) → 1100     (1个0，然后1个非0)// ...\n\n 八、JPG文件结构\nJPEG文件 = SOI + 无数段 + EOISOI (0xFFD8) - Start of Image[段] = 标记(2字节) + 长度(2字节) + 数据常见标记：0xFFE0 - APP0 (JFIF头)  &quot;JFIF\\\\0&quot;0xFFDB - DQT (量化表)0xFFC0 - SOF0 (帧开始)  → 宽、高、精度0xFFC4 - DHT (哈夫曼表)0xFFDA - SOS (扫描开始) → 真正的图像数据0xFFD9 - EOI (结束)\n\n PNG\n 一、PNG是什么？\nPNG = Portable Network Graphics = 可移植网络图形格式\n✅ 无损压缩（解压后和原来一模一样！）\n✅ 支持透明通道（Alpha）\n✅ 支持真彩色、索引色、灰度\n✅ 比GIF好10倍，还免费！\n❌ 比JPG大（照片不用它）\n❌ 解码比JPG快，比BMP慢\n❌ 不支持CMYK（印刷用不了）\n​\n 二、PNG的核心哲学\n2.1 PNG vs GIF 恩怨情仇\n1995年，Unisys公司宣布：GIF用的LZW压缩我们专利了，要收费！\n互联网炸了 →  PNG诞生：我们要做免费的GIF替代品！\n所以PNG天生：\n✅ 免费！免费！免费！\n✅ 比GIF压缩率更高\n✅ 支持更多颜色（GIF只有256色）\n✅ 支持真Alpha透明（GIF只有1位透明）\n✅ 专利友好\n​\n2.2 PNG vs JPG 定位不同\nPNG: 无损、透明、边缘锐利 → 适合图标、UI、截图、文字\nJPG: 有损、照片级 → 适合风景、人像、渐变\n经典应用：\n\n你的地球仪纹理 → PNG (透明背景)\n游戏UI图标 → PNG\n微信截图 → PNG\n朋友圈自拍 → JPG\n\n​\n 三、PNG文件结构（数据块！）\n3.1 文件结构总览\nPNG文件 = 8字节签名 + 无数个数据块\n签名（8字节）：\n[137 80 78 71 13 10 26 10]  // 这是PNG身份证\n[  P  N  G  \\r \\n \\z \\n]\n​\n3.2 数据块结构（4部分）\n// 每个数据块长这样：\n[长度:4] [类型:4] [数据:长度] [CRC:4]\n// 长度 = 数据区大小（不包括头尾）\n// 类型 = IHDR/IDAT/IEND/…（ASCII）\n// CRC = 循环冗余校验（数据有没有损坏）\n​\n3.3 关键数据块\n类型 全称 必须？ 作用\nIHDR 图像头 ✅ 宽、高、位深、颜色类型\nPLTE 调色板 索引色必须 颜色表\nIDAT 图像数据 ✅ 压缩后的像素数据\nIEND 结束 ✅ 文件结束标记\ntRNS 透明 可选 透明信息\ngAMA Gamma 可选 色彩校正\npHYs 物理像素 可选 每米像素数\ntEXt 文本 可选 作者、描述等\n四、IHDR数据块（最基础）\ntypedef struct &#123;    int width;           // 宽度（像素）    int height;          // 高度（像素）    char bitDepth;       // 位深（8/16/1/2/4）    char colorType;      // 颜色类型 ⭐    char compression;    // 压缩方法（0=DEFLATE）    char filterMethod;   // 滤波器方法（0=自适应）    char interlace;      // 隔行扫描（0=无，1=亚当7）&#125; PNGIHDR;// 大小：13字节​colorType（核心！）值 含义 位深 每像素字节0 灰度 1/2/4/8/16 位深/82 真彩色（RGB） 8/16 33 索引色 1/2/4/8 14 灰度+Alpha 8/16 26 真彩色+Alpha（RGBA） 8/16 4 ⭐最常用你平时用的PNG：colorType=6, bitDepth=8 → RGBA！五、PNG的两步压缩法原始像素数据    ↓ ① 滤波器（预测编码）预测残差（更小的数字）    ↓ ② DEFLATE压缩（LZ77 + 哈夫曼）压缩后的二进制流    ↓ 放进IDAT块PNG文件\n​\n 六、第1步：滤波器（核心中的核心）\n6.1 为什么需要滤波器？\n// 原始像素（RGBA）：\n[255,0,0,255] [255,1,0,255] [254,2,0,255] [255,3,0,255]\n红           微红         微暗红       更暗红\n// 直接压缩：数据差异大，不好压\n// 但相邻像素很接近啊！\n// 滤波器 = 存&quot;差值&quot;而不是&quot;原值&quot;\n[255,0,0,255] [+1,0,0,0] [-1,0,0,0] [+1,0,0,0]\n基准值        差值        差值        差值\n// 数字变小了 → 哈夫曼编码更短！\n​\n6.2 PNG的5种滤波器（每行选一个）\n// 0. None: 不滤波\nFilt(x) = Orig(x)\n// 1. Sub: 减去左边像素\nFilt(x) = Orig(x) - Orig(x-1)\n// 2. Up: 减上边像素\nFilt(x) = Orig(x) - Orig(x - rowBytes)\n// 3. Average: 减(左+上)/2\nFilt(x) = Orig(x) - (Orig(x-1) + Orig(x - rowBytes)) / 2\n// 4. Paeth: 减Paeth预测值（最聪明）\nFilt(x) = Orig(x) - Paeth(左, 上, 左上)\n​\n6.3 Paeth预测器（PNG的独门绝技）\nint Paeth(int left, int above, int upperLeft) &#123;    // 预测 = 左 + 上 - 左上    int predictor = left + above - upperLeft;    // 选离预测值最近的参考像素    int pLeft = abs(predictor - left);    int pAbove = abs(predictor - above);    int pUpperLeft = abs(predictor - upperLeft);    if (pLeft &lt;= pAbove &amp;&amp; pLeft &lt;= pUpperLeft)        return left;    if (pAbove &lt;= pUpperLeft)        return above;    return upperLeft;&#125;\n​\n6.4 滤波器选择（自适应）\n// PNG编码器会尝试5种滤波器，选压缩率最高的\nint bestFilter = 0;int smallestSize = INF;for (int f = 0; f &lt; 5; f++) &#123;    applyFilter(row, f);    int size = deflateCompress(row);    if (size &lt; smallestSize) &#123;        bestFilter = f;        smallestSize = size;    &#125;&#125;// 每行第一个字节 = 滤波器类型[filterType] [滤波后的像素数据...]\n​\n 七、第2步：DEFLATE压缩\n7.1 DEFLATE = LZ77 + 哈夫曼\nLZ77: 找重复字符串，用(距离,长度)替换\n“ABABAB” → “AB(4,3)”  // 从4个字符前复制3个\n哈夫曼: 高频字符用短编码，低频用长编码\nA出现100次 → 编码&quot;0&quot;\nB出现50次  → 编码&quot;10&quot;\nC出现1次   → 编码&quot;110&quot;\n​\n7.2 zlib库（PNG实际用的）\n// PNG不是直接存DEFLATE数据，外面还包了zlib头\n[zlib头:2] [DEFLATE数据…] [zlib校验:4]\nzlib头 = 压缩方法(8) + 窗口大小 + 校验位\n​\n7.3 为什么PNG比GIF小？\nGIF: LZW压缩（受专利限制，优化一般）\nPNG: DEFLATE（LZ77+哈夫曼，优化到极致）\n相同图片，PNG比GIF小20-30%！\n​\n 八、亚当7隔行扫描（Adam7）\n8.1 渐进式显示\n// 普通PNG：从上到下逐行显示\n// 网速慢时：看了半天才出来上半截\n// 亚当7：分7遍扫描\n第1遍: 每隔8行8列 ⭐ 先看到模糊轮廓\n第2遍: 每隔8行4列\n第3遍: 每隔4行8列\n第4遍: 每隔4行4列\n第5遍: 每隔2行4列\n第6遍: 每隔2行2列\n第7遍: 每隔1行1列 ⭐ 最后补细节\n效果：先模糊后清晰，用户体验好！\n代价：文件大10-20%\n​\n8.2 7遍扫描的像素分布\n1: o…o…o…\n2: .o… .o… .o…\n3: …o… …o… …o…\n4: …o… …o… …o…\n5: …o… …o… …o…\n6: …o… …o… …o.\n7: …o. …o. …o\n​\n 九、透明通道（PNG的杀手锏）\n9.1 两种透明方式\n// 1. 索引色透明（tRNS块）\n调色板索引5 → 半透明 → tRNS[5] = 128\n调色板索引6 → 全透明 → tRNS[6] = 0\n// 2. 真彩色透明（RGBA）\ncolorType=6 → 每像素4字节：R,G,B,A\nA=255: 不透明\nA=0:   全透明\nA=128: 半透明\n​\n9.2 Alpha预乘（Premultiplied Alpha）\n// 普通RGBA: (R,G,B,A)\n红色半透明 = (255,0,0,128)\n// 预乘RGBA: (RA/255, GA/255, B*A/255, A)\n红色半透明 = (128,0,0,128)\n// 预乘好处：缩放滤波不出现黑边\n// OpenGL可以设置：glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)\n​\n 十、PNG解码流程（STB在做什么）\n\n\n读8字节签名 → 确认是PNG\n\n\n循环读数据块：\n\n读长度、类型\n读数据、CRC\n验证CRC（防止文件损坏）\n\n\n\n处理IHDR块 → 宽、高、位深、颜色类型\n\n\n如果有PLTE → 读调色板\n\n\n收集所有IDAT块 → 合并成完整压缩流\n\n\nzlib解压 → 得到滤波后的原始数据\n\n\n逐行逆滤波：\n\n读每行第1字节 → 滤波器类型\n应用反向滤波器 → 恢复真实像素\n\n\n\n如果是亚当7 → 重新排列像素顺序\n\n\n颜色转换：\n\n索引色 → 查调色板\n灰度 → RGB\nYCbCr? 不用，PNG是RGB\n\n\n\n输出RGBA/RGB数组\n\n\n​\n 十一、为什么PNG不适合游戏纹理？\n问题1：解压慢\n// PNG解压：\nzlib_inflate()  // CPU密集，大量内存操作\n逆滤波()        // 逐像素计算\n// DDS纹理：\nmemcpy()        // 直接上传GPU\n​\n问题2：不支持GPU压缩\n// PNG: RGBA8888 → 32位/像素\n1024x1024 PNG = 4MB显存\n// DXT5 (BC3): 压缩纹理 → 1MB显存\n// ASTC/ETC2: 手机压缩纹理 → 0.5MB显存\n​\n问题3：随机访问困难\n// PNG: 要解压整个文件才能拿到某个像素\n// DDS: 直接文件映射，要哪里读哪里\n​\n游戏用啥？\nUI图标 → PNG（加载时解压，一直放显存）\n3D纹理 → DDS/KTX（GPU原生压缩）\n截图 → PNG（无损，通用）\n 内存布局\n 一、什么是内存布局？\n内存布局 = 像素数据在内存里的排列方式\n解码后得到的是字节数组，但OpenGL要知道：❓ RGB还是BGR？❓ 一行多少字节？❓ 原点在左上还是左下？❓ 每个像素占几位？→ 这些就是内存布局！\n\n 二、像素格式（Pixel Format）\n2.1 颜色通道顺序\n// BMP/TGA：BGR顺序[B] [G] [R]  [B] [G] [R] ...// OpenGL要：RGB顺序[R] [G] [B]  [R] [G] [B] ...// PNG：RGBA顺序[R] [G] [B] [A] [R] [G] [B] [A] ...\nOpenGL枚举值：\nGL_RGB   = 0x1907  // 红绿蓝顺序GL_BGR   = 0x80E0  // 蓝绿红顺序（扩展）GL_RGBA  = 0x1908  // 红绿蓝透明GL_BGRA  = 0x80E1  // 蓝绿红透明（扩展）\n关键： OpenGL默认是RGB，但BMP是BGR → 必须交换！\n\n2.2 位深（Bits Per Pixel）\n位深    格式    每像素字节 颜色数量     用途\n8位     灰度     1字节   256级灰度    高度图、字体\n24位    RGB     3字节   1677万色     普通图片\n32位    RGBA    4字节   1677万色+透明 UI、纹理\n16位    RGB565  2字节   65536色      手机游戏\n16位浮点 RGBA16F 8字节   HDR         高动态范围\n32位浮点 RGBA32F 16字节  极高精度      科学计算\n// OpenGL枚举GL_RGB8      // 24位，每通道8位GL_RGBA8     // 32位，每通道8位GL_RGB5_A1   // 16位，RGB 5:6:5? 不对，是RGB5+A1GL_RGB565    // 16位，R5 G6 B5GL_RGBA16F   // 64位，每通道16位浮点GL_RGBA32F   // 128位，每通道32位浮点\n\n2.3 通道顺序 + 位深 = 内部格式\n// glTexImage2D 的 internalFormat 参数glTexImage2D(    GL_TEXTURE_2D,    0,    GL_RGBA8,        // 内部格式：GPU里怎么存    1024, 1024,    0,    GL_RGBA,         // 外部格式：内存里怎么排    GL_UNSIGNED_BYTE, // 数据类型：每个通道占几字节    data);\n内外格式可以不一样！\n// 内存是BGR，但GPU存成RGBglTexImage2D(..., GL_RGB8, ..., GL_BGR, GL_UNSIGNED_BYTE, data);// OpenGL会帮你转换！\n\n 三、行对齐（Row Alignment）\n3.1 问题来源\n// 一张 3x3 的24位BMP每行 = 3像素 × 3字节 = 9字节// BMP要求每行是4字节倍数9字节 → 补到12字节[RGB][RGB][RGB][00]  // 每行多3个废字节\n3.2 OpenGL的对齐设置\n// 默认是4字节对齐glPixelStorei(GL_UNPACK_ALIGNMENT, 4);// 如果图片每行正好3字节（无填充）glPixelStorei(GL_UNPACK_ALIGNMENT, 1);  // 改成1字节对齐！// 其他对齐值2 → 每行16位倍数8 → 每行64位倍数\n3.3 什么时候用哪个？\n// BMP（有填充）→ 对齐=4glPixelStorei(GL_UNPACK_ALIGNMENT, 4);glTexImage2D(..., format, GL_UNSIGNED_BYTE, bmpData);// PNG（无填充）→ 对齐=1glPixelStorei(GL_UNPACK_ALIGNMENT, 1);glTexImage2D(..., format, GL_UNSIGNED_BYTE, pngData);// TGA（可能有填充）→ 要自己算int bytesPerRow = (width * channels + 3) &amp; ~3;\n对齐错了会怎样？\n✅ 对齐=4，实际=4 → 正常❌ 对齐=4，实际=3 → 纹理斜了、有条纹✅ 对齐=1，实际=3 → 正常（但慢一点）✅ 对齐=1，实际=4 → 正常\n安全做法： 不确定时用对齐=1！\n\n 四、原点方向（Origin）\n4.1 三个原点，三个世界\n// BMP/TGA: 左下角(0,0)第一行 → 图像最下面最后一行 → 图像最上面// PNG/JPG: 左上角(0,0)第一行 → 图像最上面最后一行 → 图像最下面// OpenGL纹理: 左下角(0,0)和BMP一样！\n4.2 怎么处理？\n// 方案1：CPU翻转for (int y = 0; y &lt; height; y++) &#123;    memcpy(flipped + (height - 1 - y) * rowSize,           data + y * rowSize,           rowSize);&#125;// 方案2：STB自动翻转（推荐）stbi_set_flip_vertically_on_load(true);  // PNG变BMP原点unsigned char* data = stbi_load(&quot;png.png&quot;, &amp;w, &amp;h, &amp;n, 0);// 现在原点在左下角，和OpenGL一致！// 方案3：着色器翻转（不推荐）TexCoord = vec2(u, 1.0 - v);  // 在着色器里翻转V坐标\n\n 五、压缩纹理格式（GPU原生）\n5.1 为什么需要压缩纹理？\n// 普通RGBA88881024x1024 纹理 = 1024×1024×4 = 4MB// DXT5 (BC3) 压缩1024x1024 纹理 = 1024×1024×1 = 1MB  // 1:4压缩// ASTC 4x41024x1024 纹理 = 1024×1024×0.5 = 512KB  // 1:8压缩\n压缩纹理 = 直接在GPU里存压缩格式，渲染时硬件解压\n\n5.2 主流压缩格式\n格式 平台 压缩比 质量 块大小\nDXT1/BC1 Windows 6:1 差（无透明） 4x4\nDXT5/BC3 Windows 4:1 好（有透明） 4x4\nETC2 Android 6:1 好 4x4\nASTC 新手机 8:1 极好 可变\nPVRTC 老iPhone 6:1 中等 4x4\n5.3 压缩纹理的内存布局\n// DXT5压缩一个4x4块[16位颜色0][16位颜色1][48位索引][64位Alpha]    2字节      2字节      6字节     8字节// 总共 16字节 存 16像素 → 1字节/像素！// 内存布局不再是线性RGB，而是固定大小的块\n重点： 压缩纹理不能逐像素访问，必须整块解压！\n\n 六、sRGB与线性空间\n6.1 问题：显示器是弯的！\n// 你给显示器 RGB(128,128,128)// 显示器实际亮度 = 0.5^2.2 ≈ 0.22  // 不是一半亮度！// 因为CRT时代，电压和亮度是幂率关系// 这叫Gamma校正\n6.2 sRGB纹理\n// PNG/JPG是sRGB编码（已经Gamma压缩）像素值 = 亮度^(1/2.2)  // 故意调亮，补偿显示器// OpenGL渲染是线性空间shader计算 → 线性RGB → Gamma校正 → 显示器// 如果用sRGB纹理glTexImage2D(..., GL_SRGB8, ...);  // OpenGL自动转线性\n错误用法：\n// sRGB图片 + GL_RGB8 = 颜色发暗！(因为算了两次Gamma)\n正确用法：\n// UI图标（sRGB）→ GL_SRGB8_ALPHA8// 法线贴图（线性）→ GL_RGB8// 光照计算（线性）→ GL_RGBA16F\n\n GPU上传\n 一、什么是GPU上传？\nGPU上传 = 把像素数据从内存（RAM）搬到显存（VRAM）\n你的代码                 RAM              VRAM\ndata = loadTexture() → [RGBRGB…]  →  [GPU纹理]\nCPU管辖          GPU管辖\nmalloc/free      glTexImage2D\n​\n核心问题：怎么搬得最快、最省内存？\n 二、最基础的上传：glTexImage2D\n2.1 函数签名\nvoid glTexImage2D(    GLenum target,     // GL_TEXTURE_2D    GLint level,       // mipmap层级（0=原图）    GLint internalFormat, // GPU里怎么存（GL_RGBA8）    GLsizei width,    GLsizei height,    GLint border,      // 必须是0    GLenum format,     // 内存里怎么排（GL_RGBA）    GLenum type,       // 数据类型（GL_UNSIGNED_BYTE）    const void* data   // 你的像素数据);\n​\n2.2 两种工作模式\n// 模式1：data != NULL → 分配显存 + 拷贝数据glTexImage2D(..., width, height, ..., data);// 此时data可以free了// 模式2：data == NULL → 只分配显存，不传数据glTexImage2D(..., width, height, ..., NULL);// 后面用glTexSubImage2D慢慢传\n​\n2.3 缺点\n❌ 每次调用都重新分配显存（慢）\n❌ 不能局部更新（要传就传整张）\n❌ CPU-&gt;GPU是同步的（CPU等GPU收完才返回）\n❌ 内存里data要完整存在（大图爆RAM）\n​\n三、局部更新：glTexSubImage2D\n3.1 函数签名\nvoid glTexSubImage2D(    GLenum target,    GLint level,    GLint xoffset,     // 从哪里开始贴    GLint yoffset,    GLsizei width,     // 贴多大区域    GLsizei height,    GLenum format,     // 格式和glTexImage2D一致    GLenum type,    const void* data);\n​\n3.2 典型用法：动态纹理\n// 1. 先分配显存（不传数据）glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);// 2. 每帧只更新变化区域while (render) &#123;    // 摄像头画面只有中间一块变了    glTexSubImage2D(GL_TEXTURE_2D, 0, 100, 100, 200, 200, GL_RGBA, GL_UNSIGNED_BYTE, cameraData);    // 其他区域保持原样！    draw();&#125;\n​\n3.3 性能对比\n// ❌ 慢：每帧重新分配glTexImage2D(..., newData);  // 10ms// ✅ 快：只更新局部glTexSubImage2D(..., changedData);  // 0.5ms​区别：· glTexImage2D = 拆了房子重新盖· glTexSubImage2D = 哪里坏了补哪里四、内存映射：glMapBuffer（PBO）4.1 问题：数据要从文件读// 传统方式：三步拷贝！FILE* f = fopen(&quot;texture.bin&quot;, &quot;rb&quot;);fread(tempBuffer, size, 1, f);  // 1. 磁盘 → RAM临时glTexSubImage2D(..., tempBuffer); // 2. RAM临时 → 驱动delete[] tempBuffer;            // 3. 释放临时// 总共：2次CPU拷贝 + 1次GPU传输\n​\n4.2 PBO = Pixel Buffer Object\n// 1. 创建PBO（显存里的缓冲区）GLuint pbo;glGenBuffers(1, &amp;pbo);glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo);glBufferData(GL_PIXEL_UNPACK_BUFFER, size, NULL, GL_STREAM_DRAW);// 2. 映射到CPU地址空间void* ptr = glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);fread(ptr, size, 1, f);  // 直接读进显存！跳过RAM拷贝glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);// 3. 告诉OpenGL从PBO取数据glTexSubImage2D(..., 0);  // data参数是偏移量，不是指针！​优势：✅ 0次CPU拷贝（文件→显存直通）✅ 异步传输（CPU不等待GPU）✅ 内存复用（不用反复malloc/free）\n​\n4.3 PBO双缓冲（终极形态）\n// 2个PBO轮流用GLuint pbo[2];int currentPBO = 0;while (render) &#123;    currentPBO = (currentPBO + 1) % 2;    // 1. 映射当前PBO，写入下一帧数据    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[currentPBO]);    void* ptr = glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);    // 生成/读取下一帧数据...    glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);    // 2. 上传上一帧的数据（从另一个PBO）    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[1 - currentPBO]);    glTexSubImage2D(..., 0);  // GPU处理上传，CPU同时生成下一帧    draw();&#125;\n​\n视频播放器、摄像头预览都是这个原理！\n五、持久映射（Persistent Mapping）\n5.1 问题：glMap/glUnmap还是有开销\n// 每帧都要：glMapBuffer()   // 告诉驱动我要写了// 写数据...glUnmapBuffer() // 告诉驱动写完了// 驱动要做内存同步、权限检查\n​\n5.2 ARB_buffer_storage 扩展\n// 1. 创建持久映射的缓冲区glBufferStorage(GL_PIXEL_UNPACK_BUFFER, size, NULL,                GL_MAP_WRITE_BIT | GL_MAP_PERSISTENT_BIT | GL_MAP_COHERENT_BIT);// 2. 映射一次，永远有效void* ptr = glMapBufferRange(GL_PIXEL_UNPACK_BUFFER, 0, size,                             GL_MAP_WRITE_BIT | GL_MAP_PERSISTENT_BIT | GL_MAP_COHERENT_BIT);// 3. 直接写指针，不用map/unmapwhile (render) &#123;    memcpy(ptr, newData, size);  // 直接写！    glTexSubImage2D(..., 0);     // GPU直接读    // 没有map/unmap开销！&#125;​现代OpenGL/Vulkan都用这个模式\n六、异步上传（真正的并行）\n6.1 问题：glTexSubImage2D 是同步的glTexSubImage2D(...);  // 这个函数不返回，直到GPU收完数据！// CPU等在这里！不能做其他事！\n​\n6.2 用Fence同步\n// 1. 发起上传glTexSubImage2D(...);// 2. 插入一个同步标记GLsync sync = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);// 3. 马上回来做其他CPU工作generateNextFrameData();  // 和GPU上传并行！// 4. 需要时再等GPUglClientWaitSync(sync, 0, GL_TIMEOUT_IGNORED);glDeleteSync(sync);​理想流水线：帧1: CPU[生成数据] → GPU[上传纹理] → GPU[渲染]帧2:              CPU[生成数据] → GPU[上传纹理] → GPU[渲染]帧3:                           CPU[生成数据] → GPU[上传纹理] → GPU[渲染]\n​\n七、压缩纹理上传\n7.1 直接上传压缩格式\n// DDS文件里直接是DXT压缩数据glCompressedTexImage2D(    GL_TEXTURE_2D, 0,    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,  // 压缩格式    width, height, 0,    dataSize,      // 压缩后大小    data);// 不能用glTexImage2D！// 不能用glTexSubImage2D（压缩块必须整块更新）\n​\n7.2 压缩纹理的块对齐\n// DXT/BC 压缩块是 4x4 像素// 更新最小单位是块，不是像素！// ❌ 错误：更新单个像素glCompressedTexSubImage2D(..., x=1, y=1, width=1, height=1, ...);// 不合法！必须4x4对齐// ✅ 正确：更新整个块glCompressedTexSubImage2D(..., x=0, y=0, width=4, height=4, ...);\n​\n 深度缓冲\n 一、什么是深度缓冲？\n深度缓冲 = Z-Buffer = 记录每个像素离摄像机有多远\n你画了一个球，又画了一个立方体但立方体在球后面，却被画在了球前面！                                    ↓GPU怎么知道谁前谁后？ → 深度缓冲！\n1.1 可视化理解\n屏幕上的每个像素：_________________| 像素  | 深度值  ||------|--------|| (0,0)| 0.3    |  ← 近处| (1,0)| 0.7    |  ← 远处| (2,0)| 0.5    |  ← 中间| ...  | ...    |深度值范围：近裁剪面 = 0.0，远裁剪面 = 1.0\n1.2 深度测试原理\n// 伪代码for (每个三角形) &#123;    for (每个像素) &#123;        float z = 计算深度();        if (z &lt; depthBuffer[x][y]) &#123;  // 更近？            framebuffer[x][y] = color;  // 画！            depthBuffer[x][y] = z;      // 更新深度        &#125;    &#125;&#125;\n\n 二、深度缓冲的核心三要素\n2.1 启用深度测试\n// 1. 打开深度测试glEnable(GL_DEPTH_TEST);// 2. 每帧清除深度缓冲glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//                    ↑ 忘了这个就乱套！\n忘了清除深度缓冲会怎样？\n第1帧：深度=0.5第2帧：深度=0.7 → 0.5 &lt; 0.7？不画！第3帧：越来越远... 最后啥也画不出来！\n2.2 深度比较函数\n// 默认：GL_LESS（近的覆盖远的）glDepthFunc(GL_LESS);    // z &lt; depthBuffer → 通过// 其他选项：GL_ALWAYS   // 总是画（不用深度测试）GL_NEVER    // 总是不画GL_EQUAL    // 相等才画GL_LEQUAL   // &lt;= 通过（常用于天空盒）GL_GREATER  // &gt; 通过（反转世界）\n2.3 深度写入\n// 默认开启：画过的像素会更新深度缓冲glDepthMask(GL_TRUE);// 关闭：只读不写（透明物体需要）glDepthMask(GL_FALSE);\n\n 三、深度缓冲的精度问题（Z-Fighting）\n3.1 为什么会有精度问题？\n// 投影矩阵把视锥体压缩到 [0, 1]// 但！不是线性压缩，是倒数压缩！近平面1.0 → 深度0.0远平面100.0 → 深度1.0// 实际分布：1.0 - 1.1: 深度0.000 - 0.095  ← 10cm占10%精度1.1 - 2.0: 深度0.095 - 0.500  ← 90cm占40%精度2.0 - 100: 深度0.500 - 1.000  ← 98m占50%精度结论：近处精度极高，远处精度极差！\n3.2 Z-Fighting现象\n两个平面距离0.01米，在远处：平面A深度 = 0.999500平面B深度 = 0.999501深度缓冲只有24位 ≈ 1677万级0.999500 和 0.999501 是同一个整数！→ 两个平面疯狂闪烁！\n经典场景：\n· 地面和草皮\n· 重叠的 Decal\n· 大场景远景\n3.3 解决方案\n方案1：反转Z（Reverse Z）\n// 把近远平面反过来！near = 100.0, far = 1.0  // 近大远小// 深度分布反过来：远处 → 0.0（高精度）近处 → 1.0（低精度）// 浮点数在0.0附近精度最高！glDepthFunc(GL_GREATER);  // 改成大于通过\n方案2：提高深度精度\n// 默认24位glTexImage2D(GL_DEPTH_COMPONENT, 0, GL_DEPTH_COMPONENT24, ...);// 32位浮点（慢，但准）glTexImage2D(GL_DEPTH_COMPONENT, 0, GL_DEPTH_COMPONENT32F, ...);\n方案3：拉近远平面\n// ❌ far = 10000.0glm::perspective(45.0f, 1.0f, 0.1f, 10000.0f);// ✅ far = 1000.0glm::perspective(45.0f, 1.0f, 0.1f, 1000.0f);\n方案4：小偏移（Polygon Offset）\n// 让草皮比地面&quot;更近&quot;一点点glEnable(GL_POLYGON_OFFSET_FILL);glPolygonOffset(1.0f, 1.0f);  // 偏移量drawGround();   // 正常深度drawGrass();    // 深度+偏移 → 永远在上面\n\n 四、深度缓冲的可视化\n4.1 把深度值当成颜色看\n// 片元着色器void main() &#123;    float depth = gl_FragCoord.z;  // 0.0 - 1.0    FragColor = vec4(vec3(depth), 1.0);    // 近处黑，远处白&#125;\n调试技巧：\n纯黑 → 深度=0.0（在近平面）纯白 → 深度=1.0（在远平面）闪烁 → Z-Fighting！\n4.2 线性化深度\n// 把非线性的深度转成线性float linearizeDepth(float depth) &#123;    float z = depth * 2.0 - 1.0;  // 转到NDC    return (2.0 * near * far) / (far + near - z * (far - near));    // 返回0-near到far的距离&#125;\n\n 五、深度纹理（阴影映射前置）\n5.1 把深度渲染到纹理\n// 1. 创建深度纹理GLuint depthTexture;glGenTextures(1, &amp;depthTexture);glBindTexture(GL_TEXTURE_2D, depthTexture);glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24, 1024, 1024, 0,             GL_DEPTH_COMPONENT, GL_FLOAT, NULL);// 2. 绑定到帧缓冲GLuint depthFBO;glGenFramebuffers(1, &amp;depthFBO);glBindFramebuffer(GL_FRAMEBUFFER, depthFBO);glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,                       GL_TEXTURE_2D, depthTexture, 0);// 3. 告诉OpenGL：我不画颜色glDrawBuffer(GL_NONE);glReadBuffer(GL_NONE);// 4. 渲染场景到深度纹理glBindFramebuffer(GL_FRAMEBUFFER, depthFBO);glClear(GL_DEPTH_BUFFER_BIT);// 画场景...\n5.2 在着色器里读深度纹理\n// 这不是颜色纹理！是深度纹理uniform sampler2DShadow depthMap;  // 用Shadow采样器float shadow = textureProj(depthMap, shadowCoord);  // 返回0或1\n这是阴影映射（Shadow Mapping）的基础！\n\n 六、深度测试的常见问题\nQ1: 透明物体怎么处理？\n// ❌ 错误：直接画透明物体glEnable(GL_BLEND);drawTransparent();  // 深度测试开着，后面的透明物体被挡住了！// ✅ 正确：// 1. 画所有不透明物体// 2. 从后往前画透明物体glDepthMask(GL_FALSE);  // 关深度写入drawTransparentOrderedByDistance();  // 远→近glDepthMask(GL_TRUE);\nQ2: 天空盒怎么画？\n// 天空盒永远在最远处glDepthFunc(GL_LEQUAL);  // 深度相等也画drawSkybox();glDepthFunc(GL_LESS);    // 恢复\nQ3: 深度冲突（Z-Fighting）怎么查？\n// 1. 启用深度偏移看谁在上面glPolygonOffset(1.0, 1.0);glEnable(GL_POLYGON_OFFSET_FILL);// 2. 可视化深度FragColor = vec4(vec3(gl_FragCoord.z), 1.0);// 3. 拉近远平面测试\n\n 七、性能优化\n7.1 Early-Z 技术\n// 现代GPU在片元着色器**之前**就做深度测试// 深度没通过 → 直接丢弃，不跑片元着色器！// ❌ 破坏Early-Z的操作：glDisable(GL_DEPTH_TEST);glDepthMask(GL_FALSE);  // 关深度写入glDepthFunc(GL_ALWAYS); // 总是通过// ✅ 保持Early-Z：先画所有不透明物体（深度测试开）后画透明物体\n7.2 深度预渲染\n// 第1遍：只写深度，不画颜色glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);drawScene();glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);// 第2遍：正式渲染（深度测试开，深度写入关）glDepthMask(GL_FALSE);drawScene();  // 只有前面通过的像素才跑片元着色器// 好处：减少overdraw，片元着色器只跑一次！\n\n 八、深度缓冲速查表\n问题        症状                   解决方案\n忘清深度     第一帧正常，后面越来越少   glClear(GL_DEPTH_BUFFER_BIT)\nZ-Fighting 闪烁、条纹              拉近远平面、反转Z、深度偏移\n透明物体     透过透明看到后面的东西没了 从后往前画，关深度写入\n天空盒      被场景挡住               glDepthFunc(GL_LEQUAL)\n阴影        阴影不正确              用深度纹理做Sha\n轮廓描边     深度测试影响描边         关深度写入再画dow Map\n\n","tags":["-图形"]},{"title":"数学分析","url":"/2026/02/27/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/","content":" 一、实数集与函数\n 1. 实数及其性质\n性质 1（封闭性）\n实数集对加、减、乘、除（除数非零）运算封闭。\n性质 2（有序性）\n∀a,b∈R\\forall a, b \\in R∀a,b∈R，必满足 a&lt;ba &lt; ba&lt;b，a=ba = ba=b，a&gt;ba &gt; ba&gt;b 三者之一。\n性质 3（传递性）\n若 a&gt;ba &gt; ba&gt;b 且 b&gt;cb &gt; cb&gt;c，则 a&gt;ca &gt; ca&gt;c。\n性质 4（阿基米德性）\n∀a,b∈R\\forall a, b \\in R∀a,b∈R，若 b&gt;a&gt;0b &gt; a &gt; 0b&gt;a&gt;0，则 ∃n∈N+\\exists n \\in N^+∃n∈N+ 使 na&gt;bna &gt; bna&gt;b。\n性质 5（稠密性）\n任意两个不等实数之间必存在另一个实数（既有有理数也有无理数）。\n 2. 绝对值不等式\n∣∣a∣−∣b∣∣≤∣a±b∣≤∣a∣+∣b∣||a| - |b|| \\leq |a \\pm b| \\leq |a| + |b|\n∣∣a∣−∣b∣∣≤∣a±b∣≤∣a∣+∣b∣\n 3. 有界集与确界\n定义 1（有上界）\n∃M∈R\\exists M \\in R∃M∈R，使得 ∀x∈S\\forall x \\in S∀x∈S，有 x≤Mx \\leq Mx≤M。\n定义 2（有下界）\n∃m∈R\\exists m \\in R∃m∈R，使得 ∀x∈S\\forall x \\in S∀x∈S，有 x≥mx \\geq mx≥m。\n定义 3（有界）\n∃K&gt;0\\exists K &gt; 0∃K&gt;0，使得 ∀x∈S\\forall x \\in S∀x∈S，有 ∣x∣≤K|x| \\leq K∣x∣≤K。\n等价于既有上界又有下界。\n定义 4（上确界）\n设 S⊆RS \\subseteq RS⊆R，η=sup⁡S\\eta = \\sup Sη=supS 若：\n\n∀x∈S\\forall x \\in S∀x∈S，x≤ηx \\leq \\etax≤η（上界性）\n∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃x0∈S\\exists x_0 \\in S∃x0​∈S，使得 x0&gt;η−εx_0 &gt; \\eta - \\varepsilonx0​&gt;η−ε（最小性）\n\n定义 5（下确界）\n设 S⊆RS \\subseteq RS⊆R，ξ=inf⁡S\\xi = \\inf Sξ=infS 若：\n\n∀x∈S\\forall x \\in S∀x∈S，x≥ξx \\geq \\xix≥ξ（下界性）\n∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃x0∈S\\exists x_0 \\in S∃x0​∈S，使得 x0&lt;ξ+εx_0 &lt; \\xi + \\varepsilonx0​&lt;ξ+ε（最大性）\n\n定理 1（确界原理）\n非空有上界的实数集必有上确界；非空有下界的实数集必有下确界。\n 4. 确界的运算性质\ninf⁡S≤sup⁡S\\inf S \\leq \\sup S\ninfS≤supS\n等号成立当且仅当 SSS 为单点集。\n设 A,BA, BA,B 为非空有界集，则：\nsup⁡(A∪B)=max⁡{sup⁡A,sup⁡B},inf⁡(A∪B)=min⁡{inf⁡A,inf⁡B}\\sup(A \\cup B) = \\max\\{\\sup A, \\sup B\\},\\quad \\inf(A \\cup B) = \\min\\{\\inf A, \\inf B\\}\nsup(A∪B)=max{supA,supB},inf(A∪B)=min{infA,infB}\nsup⁡(kA)=ksup⁡A (k&gt;0),inf⁡(kA)=kinf⁡A (k&gt;0)\\sup(kA) = k \\sup A\\ (k &gt; 0),\\quad \\inf(kA) = k \\inf A\\ (k &gt; 0)\nsup(kA)=ksupA (k&gt;0),inf(kA)=kinfA (k&gt;0)\nk&lt;0k &lt; 0k&lt;0 时，sup⁡\\supsup 与 inf⁡\\infinf 互换。\nsup⁡(A+c)=sup⁡A+c,inf⁡(A+c)=inf⁡A+c\\sup(A + c) = \\sup A + c,\\quad \\inf(A + c) = \\inf A + c\nsup(A+c)=supA+c,inf(A+c)=infA+c\n\n 二、数列极限\n 1. 数列极限的定义\n定义 6\n设 {an}\\{a_n\\}{an​} 为数列，aaa 为常数。若 ∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃N∈N+\\exists N \\in N^+∃N∈N+，使得当 n&gt;Nn &gt; Nn&gt;N 时，有\n∣an−a∣&lt;ε|a_n - a| &lt; \\varepsilon\n∣an​−a∣&lt;ε\n则称 aaa 为数列 {an}\\{a_n\\}{an​} 的极限，记作 lim⁡n→∞an=a\\lim_{n \\to \\infty} a_n = alimn→∞​an​=a。\n 2. 极限性质\n定理 2（唯一性）\n收敛数列的极限唯一。\n定理 3（有界性）\n收敛数列必有界。\n定理 4（保号性）\n若 lim⁡an=a&gt;0\\lim a_n = a &gt; 0liman​=a&gt;0，则 ∃N\\exists N∃N，当 n&gt;Nn &gt; Nn&gt;N 时，an&gt;0a_n &gt; 0an​&gt;0。\n定理 5（迫敛性）\n若 an≤bn≤cna_n \\leq b_n \\leq c_nan​≤bn​≤cn​ 且 lim⁡an=lim⁡cn=a\\lim a_n = \\lim c_n = aliman​=limcn​=a，则 lim⁡bn=a\\lim b_n = alimbn​=a。\n 3. 极限运算法则\n若 lim⁡an=a\\lim a_n = aliman​=a，lim⁡bn=b\\lim b_n = blimbn​=b，则：\nlim⁡(an±bn)=a±b\\lim (a_n \\pm b_n) = a \\pm b\nlim(an​±bn​)=a±b\nlim⁡(anbn)=ab\\lim (a_n b_n) = ab\nlim(an​bn​)=ab\nlim⁡anbn=ab (b≠0)\\lim \\frac{a_n}{b_n} = \\frac{a}{b}\\ (b \\neq 0)\nlimbn​an​​=ba​ (b=0)\n 4. 单调有界定理\n定理 6\n单调有界数列必有极限。\n 5. 柯西收敛准则\n定理 7\n数列 {an}\\{a_n\\}{an​} 收敛 ⇔\\Leftrightarrow⇔ ∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃N\\exists N∃N，使得当 m,n&gt;Nm, n &gt; Nm,n&gt;N 时，有\n∣am−an∣&lt;ε|a_m - a_n| &lt; \\varepsilon\n∣am​−an​∣&lt;ε\n\n 三、函数极限\n 1. 函数极限的定义\n定义 7\n设 f(x)f(x)f(x) 在 x0x_0x0​ 的某去心邻域有定义，AAA 为常数。若 ∀ε&gt;0\\forall \\varepsilon &gt; 0∀ε&gt;0，∃δ&gt;0\\exists \\delta &gt; 0∃δ&gt;0，使得当 0&lt;∣x−x0∣&lt;δ0 &lt; |x - x_0| &lt; \\delta0&lt;∣x−x0​∣&lt;δ 时，有\n∣f(x)−A∣&lt;ε|f(x) - A| &lt; \\varepsilon\n∣f(x)−A∣&lt;ε\n则称 AAA 为 f(x)f(x)f(x) 当 x→x0x \\to x_0x→x0​ 时的极限，记作 lim⁡x→x0f(x)=A\\lim_{x \\to x_0} f(x) = Alimx→x0​​f(x)=A。\n 2. 单侧极限\nlim⁡x→x0+f(x)=A,lim⁡x→x0−f(x)=A\\lim_{x \\to x_0^+} f(x) = A,\\quad \\lim_{x \\to x_0^-} f(x) = A\nx→x0+​lim​f(x)=A,x→x0−​lim​f(x)=A\n极限存在当且仅当左右极限存在且相等。\n 3. 极限性质\n定理 8（唯一性、局部有界性、局部保号性、迫敛性）\n与数列极限类似。\n 4. 极限运算法则\n与数列极限类似。\n 5. 两个重要极限\nlim⁡x→0sin⁡xx=1\\lim_{x \\to 0} \\frac{\\sin x}{x} = 1\nx→0lim​xsinx​=1\nlim⁡x→∞(1+1x)x=e\\lim_{x \\to \\infty} \\left(1 + \\frac{1}{x}\\right)^x = e\nx→∞lim​(1+x1​)x=e\n 6. 无穷小与无穷大\n3403583728: 02-27 11:30:19\n定义 8\n若 lim⁡f(x)=0\\lim f(x) = 0limf(x)=0，则称 f(x)f(x)f(x) 为无穷小。\n定义 9\n若 lim⁡f(x)=∞\\lim f(x) = \\inftylimf(x)=∞，则称 f(x)f(x)f(x) 为无穷大。\n\n 四、函数的连续性\n 1. 连续的定义\n定义 10\nf(x)f(x)f(x) 在 x0x_0x0​ 连续 ⇔\\Leftrightarrow⇔ lim⁡x→x0f(x)=f(x0)\\lim_{x \\to x_0} f(x) = f(x_0)limx→x0​​f(x)=f(x0​)。\n 2. 间断点分类\n\n可去间断点：极限存在但不等于函数值或函数无定义\n跳跃间断点：左右极限存在但不相等\n无穷间断点：极限为无穷大\n振荡间断点：极限不存在且不为无穷大\n\n 3. 连续函数的性质\n定理 9（介值定理）\n若 fff 在 [a,b][a, b][a,b] 连续，且 f(a)≠f(b)f(a) \\neq f(b)f(a)=f(b)，则对介于 f(a)f(a)f(a) 与 f(b)f(b)f(b) 之间的任意数 CCC，存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f(ξ)=Cf(\\xi) = Cf(ξ)=C。\n定理 10（最值定理）\n闭区间上的连续函数必有最大值和最小值。\n定理 11（零点定理）\n若 f(a)f(b)&lt;0f(a)f(b) &lt; 0f(a)f(b)&lt;0，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f(ξ)=0f(\\xi) = 0f(ξ)=0。\n\n 五、导数与微分\n 1. 导数的定义\n定义 11\nf′(x0)=lim⁡h→0f(x0+h)−f(x0)hf&#x27;(x_0) = \\lim_{h \\to 0} \\frac{f(x_0 + h) - f(x_0)}{h}\nf′(x0​)=h→0lim​hf(x0​+h)−f(x0​)​\n 2. 基本求导公式\n(c)′=0,(xμ)′=μxμ−1(c)&#x27; = 0,\\quad (x^\\mu)&#x27; = \\mu x^{\\mu-1}\n(c)′=0,(xμ)′=μxμ−1\n(sin⁡x)′=cos⁡x,(cos⁡x)′=−sin⁡x(\\sin x)&#x27; = \\cos x,\\quad (\\cos x)&#x27; = -\\sin x\n(sinx)′=cosx,(cosx)′=−sinx\n(ln⁡x)′=1x,(ex)′=ex(\\ln x)&#x27; = \\frac{1}{x},\\quad (e^x)&#x27; = e^x\n(lnx)′=x1​,(ex)′=ex\n 3. 求导法则\n(u±v)′=u′±v′(u \\pm v)&#x27; = u&#x27; \\pm v&#x27;\n(u±v)′=u′±v′\n(uv)′=u′v+uv′(uv)&#x27; = u&#x27;v + uv&#x27;\n(uv)′=u′v+uv′\n(uv)′=u′v−uv′v2\\left(\\frac{u}{v}\\right)&#x27; = \\frac{u&#x27;v - uv&#x27;}{v^2}\n(vu​)′=v2u′v−uv′​\ndydx=dydu⋅dudx\\frac{dy}{dx} = \\frac{dy}{du} \\cdot \\frac{du}{dx}\ndxdy​=dudy​⋅dxdu​\n 4. 微分的定义\n定义 12\n若 Δy=AΔx+o(Δx)\\Delta y = A\\Delta x + o(\\Delta x)Δy=AΔx+o(Δx)，则称 fff 在 x0x_0x0​ 可微，记 dy=Adxdy = A dxdy=Adx，且 A=f′(x0)A = f&#x27;(x_0)A=f′(x0​)。\n\n 六、微分中值定理\n 1. 罗尔定理\n定理 12\n若 fff 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，且 f(a)=f(b)f(a) = f(b)f(a)=f(b)，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f′(ξ)=0f&#x27;(\\xi) = 0f′(ξ)=0。\n 2. 拉格朗日中值定理\n定理 13\n若 fff 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使\nf(b)−f(a)=f′(ξ)(b−a)f(b) - f(a) = f&#x27;(\\xi)(b - a)\nf(b)−f(a)=f′(ξ)(b−a)\n 3. 柯西中值定理\n定理 14\n若 f,gf, gf,g 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，且 g′(x)≠0g&#x27;(x) \\neq 0g′(x)=0，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使\nf(b)−f(a)g(b)−g(a)=f′(ξ)g′(ξ)\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f&#x27;(\\xi)}{g&#x27;(\\xi)}\ng(b)−g(a)f(b)−f(a)​=g′(ξ)f′(ξ)​\n 4. 洛必达法则\n若 lim⁡f(x)g(x)\\lim \\frac{f(x)}{g(x)}limg(x)f(x)​ 为 00\\frac{0}{0}00​ 或 ∞∞\\frac{\\infty}{\\infty}∞∞​ 型，且 lim⁡f′(x)g′(x)\\lim \\frac{f&#x27;(x)}{g&#x27;(x)}limg′(x)f′(x)​ 存在，则\nlim⁡f(x)g(x)=lim⁡f′(x)g′(x)\\lim \\frac{f(x)}{g(x)} = \\lim \\frac{f&#x27;(x)}{g&#x27;(x)}\nlimg(x)f(x)​=limg′(x)f′(x)​\n 5. 泰勒公式\n定理 15\n若 fff 在 x0x_0x0​ 处 nnn 阶可导，则\nf(x)=f(x0)+f′(x0)(x−x0)+⋯+f(n)(x0)n!(x−x0)n+o((x−x0)n)f(x) = f(x_0) + f&#x27;(x_0)(x - x_0) + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + o((x - x_0)^n)\nf(x)=f(x0​)+f′(x0​)(x−x0​)+⋯+n!f(n)(x0​)​(x−x0​)n+o((x−x0​)n)\n定义 8\n若 lim⁡f(x)=0\\lim f(x) = 0limf(x)=0，则称 f(x)f(x)f(x) 为无穷小。\n定义 9\n若 lim⁡f(x)=∞\\lim f(x) = \\inftylimf(x)=∞，则称 f(x)f(x)f(x) 为无穷大。\n\n 四、函数的连续性\n 1. 连续的定义\n定义 10\nf(x)f(x)f(x) 在 x0x_0x0​ 连续 ⇔\\Leftrightarrow⇔ lim⁡x→x0f(x)=f(x0)\\lim_{x \\to x_0} f(x) = f(x_0)limx→x0​​f(x)=f(x0​)。\n 2. 间断点分类\n\n可去间断点：极限存在但不等于函数值或函数无定义\n跳跃间断点：左右极限存在但不相等\n无穷间断点：极限为无穷大\n振荡间断点：极限不存在且不为无穷大\n\n 3. 连续函数的性质\n定理 9（介值定理）\n若 fff 在 [a,b][a, b][a,b] 连续，且 f(a)≠f(b)f(a) \\neq f(b)f(a)=f(b)，则对介于 f(a)f(a)f(a) 与 f(b)f(b)f(b) 之间的任意数 CCC，存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f(ξ)=Cf(\\xi) = Cf(ξ)=C。\n定理 10（最值定理）\n闭区间上的连续函数必有最大值和最小值。\n定理 11（零点定理）\n若 f(a)f(b)&lt;0f(a)f(b) &lt; 0f(a)f(b)&lt;0，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f(ξ)=0f(\\xi) = 0f(ξ)=0。\n\n 五、导数与微分\n 1. 导数的定义\n定义 11\nf′(x0)=lim⁡h→0f(x0+h)−f(x0)hf&#x27;(x_0) = \\lim_{h \\to 0} \\frac{f(x_0 + h) - f(x_0)}{h}\nf′(x0​)=h→0lim​hf(x0​+h)−f(x0​)​\n 2. 基本求导公式\n(c)′=0,(xμ)′=μxμ−1(c)&#x27; = 0,\\quad (x^\\mu)&#x27; = \\mu x^{\\mu-1}\n(c)′=0,(xμ)′=μxμ−1\n(sin⁡x)′=cos⁡x,(cos⁡x)′=−sin⁡x(\\sin x)&#x27; = \\cos x,\\quad (\\cos x)&#x27; = -\\sin x\n(sinx)′=cosx,(cosx)′=−sinx\n(ln⁡x)′=1x,(ex)′=ex(\\ln x)&#x27; = \\frac{1}{x},\\quad (e^x)&#x27; = e^x\n(lnx)′=x1​,(ex)′=ex\n 3. 求导法则\n(u±v)′=u′±v′(u \\pm v)&#x27; = u&#x27; \\pm v&#x27;\n(u±v)′=u′±v′\n(uv)′=u′v+uv′(uv)&#x27; = u&#x27;v + uv&#x27;\n(uv)′=u′v+uv′\n(uv)′=u′v−uv′v2\\left(\\frac{u}{v}\\right)&#x27; = \\frac{u&#x27;v - uv&#x27;}{v^2}\n(vu​)′=v2u′v−uv′​\ndydx=dydu⋅dudx\\frac{dy}{dx} = \\frac{dy}{du} \\cdot \\frac{du}{dx}\ndxdy​=dudy​⋅dxdu​\n 4. 微分的定义\n定义 12\n若 Δy=AΔx+o(Δx)\\Delta y = A\\Delta x + o(\\Delta x)Δy=AΔx+o(Δx)，则称 fff 在 x0x_0x0​ 可微，记 dy=Adxdy = A dxdy=Adx，且 A=f′(x0)A = f&#x27;(x_0)A=f′(x0​)。\n\n 六、微分中值定理\n 1. 罗尔定理\n定理 12\n若 fff 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，且 f(a)=f(b)f(a) = f(b)f(a)=f(b)，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使 f′(ξ)=0f&#x27;(\\xi) = 0f′(ξ)=0。\n 2. 拉格朗日中值定理\n定理 13\n若 fff 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使\nf(b)−f(a)=f′(ξ)(b−a)f(b) - f(a) = f&#x27;(\\xi)(b - a)\nf(b)−f(a)=f′(ξ)(b−a)\n 3. 柯西中值定理\n定理 14\n若 f,gf, gf,g 在 [a,b][a, b][a,b] 连续，在 (a,b)(a, b)(a,b) 可导，且 g′(x)≠0g&#x27;(x) \\neq 0g′(x)=0，则存在 ξ∈(a,b)\\xi \\in (a, b)ξ∈(a,b) 使\nf(b)−f(a)g(b)−g(a)=f′(ξ)g′(ξ)\\frac{f(b) - f(a)}{g(b) - g(a)} = \\frac{f&#x27;(\\xi)}{g&#x27;(\\xi)}\ng(b)−g(a)f(b)−f(a)​=g′(ξ)f′(ξ)​\n 4. 洛必达法则\n若 lim⁡f(x)g(x)\\lim \\frac{f(x)}{g(x)}limg(x)f(x)​ 为 00\\frac{0}{0}00​ 或 ∞∞\\frac{\\infty}{\\infty}∞∞​ 型，且 lim⁡f′(x)g′(x)\\lim \\frac{f&#x27;(x)}{g&#x27;(x)}limg′(x)f′(x)​ 存在，则\nlim⁡f(x)g(x)=lim⁡f′(x)g′(x)\\lim \\frac{f(x)}{g(x)} = \\lim \\frac{f&#x27;(x)}{g&#x27;(x)}\nlimg(x)f(x)​=limg′(x)f′(x)​\n 5. 泰勒公式\n定理 15\n若 fff 在 x0x_0x0​ 处 nnn 阶可导，则\nf(x)=f(x0)+f′(x0)(x−x0)+⋯+f(n)(x0)n!(x−x0)n+o((x−x0)n)f(x) = f(x_0) + f&#x27;(x_0)(x - x_0) + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + o((x - x_0)^n)\nf(x)=f(x0​)+f′(x0​)(x−x0​)+⋯+n!f(n)(x0​)​(x−x0​)n+o((x−x0​)n)\n","categories":["-数学分析"],"tags":["-数学"]},{"title":"算法","url":"/2026/02/25/%E7%AE%97%E6%B3%95/","content":" 排序\n 冒泡排序\n\n一、基本思想\n冒泡排序就是模拟这个过程：\n\n从数组的第一个元素开始，依次比较相邻的两个元素。\n如果它们的顺序错了（比如前一个比后一个大，而我们想升序排序），就交换它们。\n这样 一轮比较下来，最大的元素就会“冒”到数组的最后一位。\n重复这个过程，每次忽略已经排好序的尾部元素，直到整个数组有序。\n\n\n二、核心操作：比较与交换\n这是冒泡排序的灵魂：\nif (arr[j] &gt; arr[j + 1]) &#123;    // 交换它们    int temp = arr[j];    arr[j] = arr[j + 1];    arr[j + 1] = temp;&#125;\n\n三、C++ 代码实现（基础版）\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void bubbleSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    // 外层循环：控制需要多少轮冒泡    for (int i = 0; i &lt; n - 1; i++) &#123;        // 内层循环：进行相邻元素的比较和交换        // 注意：j &lt; n - 1 - i，因为最后i个元素已经排好了        for (int j = 0; j &lt; n - 1 - i; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                // 交换arr[j]和arr[j+1]                swap(arr[j], arr[j + 1]);            &#125;        &#125;    &#125;&#125;// 测试int main() &#123;    vector&lt;int&gt; arr = &#123;64, 34, 25, 12, 22, 11, 90&#125;;    cout &lt;&lt; &quot;排序前: &quot;;    for (int num : arr) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    bubbleSort(arr);    cout &lt;&lt; &quot;排序后: &quot;;    for (int num : arr) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;\n运行结果：\n排序前: 64 34 25 12 22 11 90排序后: 11 12 22 25 34 64 90\n\n四、优化版本\n基础版本即使数组已经有序，也会完整执行所有轮次。我们可以添加一个标志来优化：\nvoid bubbleSortOptimized(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    bool swapped; // 记录本轮是否发生过交换    for (int i = 0; i &lt; n - 1; i++) &#123;        swapped = false;        for (int j = 0; j &lt; n - 1 - i; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr[j], arr[j + 1]);                swapped = true; // 发生了交换            &#125;        &#125;        // 如果本轮没有发生任何交换，说明数组已经有序        if (!swapped) &#123;            break; // 提前结束        &#125;    &#125;&#125;\n优化效果：\n· 对于已经有序的数组，只需要一轮扫描（O(n)）\n· 基础版则固定需要 O(n²) 次比较\n 选择排序\n\n一、基本思想\n选择排序的核心思想是 “选择最小（或最大）的元素，放到它应该在的位置”。\n想象一下在整理一副扑克牌：\n\n先扫描所有牌，找到最小的一张\n把这张牌放到最左边\n在剩下的牌中继续找最小的\n放到已排序部分的后面\n重复直到所有牌都排好\n\n\n二、算法步骤（升序排序）\n\n将数组分为两部分：\n· 已排序部分（初始为空，在左边）\n· 未排序部分（初始为整个数组，在右边）\n在未排序部分中找到最小元素的索引\n将这个最小元素与未排序部分的第一个元素交换\n这时，未排序部分的第一个元素就加入了已排序部分\n重复步骤2-4，直到未排序部分为空\n\n\n三、C++ 代码实现\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void selectionSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    // 外层循环：控制已排序部分的边界    // i 表示：arr[0...i-1] 是已排序的，arr[i...n-1] 是未排序的    for (int i = 0; i &lt; n - 1; i++) &#123;        // 假设当前位置 i 就是最小元素的位置        int minIndex = i;        // 内层循环：在未排序部分中寻找真正的最小元素        for (int j = i + 1; j &lt; n; j++) &#123;            if (arr[j] &lt; arr[minIndex]) &#123;                minIndex = j;  // 更新最小元素的索引            &#125;        &#125;        // 将找到的最小元素交换到正确位置 i        if (minIndex != i) &#123;            swap(arr[i], arr[minIndex]);        &#125;        // 此时，arr[i] 已排好，加入到已排序部分    &#125;&#125;// 测试int main() &#123;    vector&lt;int&gt; arr = &#123;64, 25, 12, 22, 11&#125;;    cout &lt;&lt; &quot;排序前: &quot;;    for (int num : arr) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    selectionSort(arr);    cout &lt;&lt; &quot;排序后: &quot;;    for (int num : arr) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;\n运行结果：\n排序前: 64 25 12 22 11排序后: 11 12 22 25 64\n\n四、优化版本\n虽然选择排序时间复杂度固定，但我们可以优化交换操作：\nvoid selectionSortOptimized(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    for (int i = 0; i &lt; n - 1; i++) &#123;        int minIndex = i;        // 找到最小元素的索引        for (int j = i + 1; j &lt; n; j++) &#123;            if (arr[j] &lt; arr[minIndex]) &#123;                minIndex = j;            &#125;        &#125;        // 只有当最小元素不在当前位置时才交换        if (minIndex != i) &#123;            // 使用三次异或交换（无临时变量）            arr[i] = arr[i] ^ arr[minIndex];            arr[minIndex] = arr[i] ^ arr[minIndex];            arr[i] = arr[i] ^ arr[minIndex];        &#125;    &#125;&#125;\n注意：异或交换虽然酷，但在实际工程中不推荐使用（可读性差，且对相同元素会出错）。\n\n五、变体：双向选择排序（鸡尾酒选择排序）\n\n优化思路：同时找最小值和最大值，最小值放左边，最大值放右边，从两头向中间推进。\n\n版本1：最直观但错误的版本\n// 版本1：直观但有问题void bidirectional_v1(vector&lt;int&gt;&amp; arr) &#123;    int left = 0, right = arr.size() - 1;    while (left &lt; right) &#123;        int minIndex = left, maxIndex = right;  // ❌ 问题1：maxIndex初始化为right        // 找最小值和最大值        for (int i = left; i &lt;= right; i++) &#123;            if (arr[i] &lt; arr[minIndex]) minIndex = i;            if (arr[i] &gt; arr[maxIndex]) maxIndex = i;  // ❌ 可能找不到真正的最大值        &#125;        // 交换最小值到左边        if (minIndex != left) swap(arr[left], arr[minIndex]);        // 交换最大值到右边        if (maxIndex != right) swap(arr[right], arr[maxIndex]);        left++;        right--;    &#125;&#125;\n问题1：\n//交换最小值时最大值位置变了\n\n版本2 两次交换之间插入说明\n// 版本3：考虑交换最小值对最大值位置的影响void bidirectional_v3(vector&lt;int&gt;&amp; arr) &#123;    int left = 0, right = arr.size() - 1;    while (left &lt; right) &#123;        int minIndex = left, maxIndex = left;        // 找最小值和最大值        for (int i = left; i &lt;= right; i++) &#123;            if (arr[i] &lt; arr[minIndex]) minIndex = i;            if (arr[i] &gt; arr[maxIndex]) maxIndex = i;        &#125;        // 交换最小值到左边        if (minIndex != left) swap(arr[left], arr[minIndex]);        // 关键修复：如果最大值在left，它现在在minIndex        if (maxIndex == left) &#123;            maxIndex = minIndex;        &#125;        // 交换最大值到右边        if (maxIndex != right) swap(arr[right], arr[maxIndex]);        left++;        right--;    &#125;&#125;\n问题2:\n//边界重叠问题：//// 第一步：if (minIndex != left) → 1 != 0 成立swap(arr[0], arr[1]) → [1, 2]// 第二步：if (maxIndex == left) → 0 == 0 成立maxIndex = minIndex = 1// 第三步：if (maxIndex != right) → 1 != 1 ❌ 不成立！// 不执行交换！maxIndex现在是1，right也是1// 但问题是：最大值2已经在正确位置了吗？// 查看数组：[1, 2] ✓ 2确实在最后，但这是巧合！问题：当 maxIndex 被更新为 minIndex，而 minIndex == right 时，版本2的 if (maxIndex != right) 会阻止交换，但有时这是需要的！\n\n版本3：\nvoid bidirectional_v4(vector&lt;int&gt;&amp; arr) &#123;    int left = 0, right = arr.size() - 1;    while (left &lt; right) &#123;        int minIndex = left, maxIndex = left;        for (int i = left; i &lt;= right; i++) &#123;            if (arr[i] &lt; arr[minIndex]) minIndex = i;            if (arr[i] &gt; arr[maxIndex]) maxIndex = i;        &#125;        // 交换最小值        swap(arr[left], arr[minIndex]);  // 移除了if判断        // 更新最大值位置        if (maxIndex == left) &#123;            maxIndex = minIndex;        &#125;        // 交换最大值        swap(arr[right], arr[maxIndex]);  // 移除了if判断        left++;        right--;    &#125;&#125;\n\n版本4：最终修复版（处理所有边界）\n// 版本5：最终正确版本\nvoid bidirectionalSelectionSort(vector&lt;int&gt;&amp; arr) &#123;    if (arr.empty()) return;    int left = 0, right = arr.size() - 1;    while (left &lt; right) &#123;        // 初始化        int minIndex = left, maxIndex = left;        // 查找最小值和最大值的索引        for (int i = left; i &lt;= right; i++) &#123;            if (arr[i] &lt; arr[minIndex]) &#123;                minIndex = i;            &#125;            if (arr[i] &gt; arr[maxIndex]) &#123;                maxIndex = i;            &#125;        &#125;        // 交换最小值到left位置        swap(arr[left], arr[minIndex]);        // 关键：如果最大值在left，它现在在minIndex        // 但如果minIndex == right，会有问题！        if (maxIndex == left) &#123;            maxIndex = minIndex;        &#125;        // 交换最大值到right位置        swap(arr[right], arr[maxIndex]);        // 收缩边界        left++;        right--;    &#125;&#125;\n 插入排序\n\n一、基本思想\n插入排序模拟了整理扑克牌的过程：\n想象手里有一堆乱序的牌：\n\n从第二张牌开始（假设第一张已经在&quot;手&quot;里了）\n拿起一张新牌\n从右向左与手中的牌比较\n找到合适的位置插入\n重复直到所有牌都插入\n\n一句话总结：将每个新元素插入到已排序部分的正确位置。\n\n二、算法步骤\n\n将数组分为两部分：\n· 已排序部分（初始只有第一个元素）\n· 未排序部分（其余元素）\n依次从未排序部分取元素\n在已排序部分中从后往前扫描，找到插入位置\n将大于该元素的都向右移动一位\n插入该元素到正确位置\n\n\n三、C++ 代码实现\n基础版本\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void insertionSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    // 从第二个元素开始（下标1）    for (int i = 1; i &lt; n; i++) &#123;        int key = arr[i];  // 当前要插入的元素        int j = i - 1;     // 从已排序部分的最后一个开始比较        // 将比key大的元素都向右移动一位        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123;            arr[j + 1] = arr[j];            j--;        &#125;        // 插入key到正确位置        arr[j + 1] = key;    &#125;&#125;// 测试int main() &#123;    vector&lt;int&gt; arr = &#123;12, 11, 13, 5, 6&#125;;    cout &lt;&lt; &quot;排序前: &quot;;    for (int num : arr) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    insertionSort(arr);    cout &lt;&lt; &quot;排序后: &quot;;    for (int num : arr) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;\n输出：\n排序前: 12 11 13 5 6排序后: 5 6 11 12 13\n\n 快速排序\n\n一、核心思想：分而治之\n快速排序的核心是 “Divide and Conquer”：\n\n分解：选一个&quot;基准&quot;元素，将数组分成两个子数组\n· 左边：所有比基准小的元素\n· 右边：所有比基准大的元素\n· 基准在中间正确位置\n解决：递归地对左右子数组进行快速排序\n合并：不需要！因为原址排序，排完后自然有序\n\n\n二、基本步骤（Partition操作是关键）\n以最经典的 Lomuto分区方案 为例：\n// Partition的直观理解：像整理书架// [比pivot小的书] pivot [比pivot大的书]\n\n三、C++代码实现（Lomuto分区）\n基础版本（每次取最后一个做基准，小的放左大的放右，基准归位，左右递归！）\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 分区函数：返回pivot的最终位置int partition(vector&lt;int&gt;&amp; arr, int low, int high) &#123;    int pivot = arr[high];  // 选择最后一个元素作为pivot    int i = low - 1;        // i指向小于pivot区域的边界    for (int j = low; j &lt; high; j++) &#123;        // 如果当前元素小于等于pivot        if (arr[j] &lt;= pivot) &#123;            i++;  // 扩大小于pivot的区域            swap(arr[i], arr[j]);        &#125;    &#125;    // 将pivot放到正确位置    swap(arr[i + 1], arr[high]);    return i + 1;  // 返回pivot的位置&#125;// 快速排序主函数void quickSort(vector&lt;int&gt;&amp; arr, int low, int high) &#123;    if (low &lt; high) &#123;        // pi是pivot的正确位置        int pi = partition(arr, low, high);        // 递归排序左半部分和右半部分        quickSort(arr, low, pi - 1);        quickSort(arr, pi + 1, high);    &#125;&#125;// 包装函数void quickSort(vector&lt;int&gt;&amp; arr) &#123;    if (arr.empty()) return;    quickSort(arr, 0, arr.size() - 1);&#125;// 测试int main() &#123;    vector&lt;int&gt; arr = &#123;10, 7, 8, 9, 1, 5&#125;;    cout &lt;&lt; &quot;原始数组: &quot;;    for (int num : arr) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    quickSort(arr);    cout &lt;&lt; &quot;排序后: &quot;;    for (int num : arr) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;\n输出：\n原始数组: 10 7 8 9 1 5排序后: 1 5 7 8 9 10\n\n四、更高效的Hoare分区方案\nLomuto方案简单但交换次数多。Hoare方案更高效：\n// Hoare分区 - 更少的交换，更高效int partitionHoare(vector&lt;int&gt;&amp; arr, int low, int high) &#123;    int pivot = arr[low];  // 选择第一个元素作为pivot    int i = low - 1;    int j = high + 1;    while (true) &#123;        // 从左找第一个大于等于pivot的元素        do &#123;            i++;        &#125;         while (arr[i] &lt; pivot);        // 从右找第一个小于等于pivot的元素        do &#123;            j--;        &#125;         while (arr[j] &gt; pivot);        // 如果指针相遇，返回j        if (i &gt;= j) return j;        // 交换这两个错位的元素        swap(arr[i], arr[j]);    &#125;&#125;void quickSortHoare(vector&lt;int&gt;&amp; arr, int low, int high) &#123;    if (low &lt; high) &#123;        int pi = partitionHoare(arr, low, high);        quickSortHoare(arr, low, pi);      // 注意：包含pi        quickSortHoare(arr, pi + 1, high);    &#125;&#125;\n\n五、📊 快排的pivot极端情况\n🏆 最好的pivot：中位数\n[1, 2, 3, 4, 5, 6, 7, 8]选pivot=4或5结果：左边3个，右边4个 → 完美平衡递归深度：log₂n ≈ 3层时间复杂度：O(n log n) ✅ 最快\n💀 最差的pivot：最大/最小值\n[1, 2, 3, 4, 5, 6, 7, 8]选pivot=1或8结果：左边0个，右边7个（或相反）→ 极度不平衡递归深度：n ≈ 8层时间复杂度：O(n²) ❌ 最慢\n\n🎯 最好vs最差：一图胜千言\n最好情况（中位数）：\n第1层: [1,2,3,4,5,6,7,8] → pivot=4        /           \\\\[1,2,3,4]         [5,6,7,8]  ✓ 两边均匀第2层: 再分 → 4个子数组第3层: 再分 → 8个子数组（完成）\n最差情况（最大/最小值）：\n第1层: [1,2,3,4,5,6,7,8] → pivot=1        /      []    [2,3,4,5,6,7,8]  ❌ 一边倒第2层: [2,3,4,5,6,7,8] → pivot=2        /      []    [3,4,5,6,7,8]    ❌ 继续倒... 一直倒到结束，像冒泡排序一样慢\n\n🔥 为什么中位数最好？\n因为每次都能把数组对半切：\nn = 8第1层: 8个 → 4个 + 4个第2层: 4个 → 2个 + 2个第3层: 2个 → 1个 + 1个总层数: log₂8 = 3\n为什么最差是最大/最小值？\nn = 8第1层: 8个 → 0个 + 7个第2层: 7个 → 0个 + 6个第3层: 6个 → 0个 + 5个...总层数: 8 = n\n\n📈 时间复杂度对比\npivot    递归深度   总时间       举例\n中位数     log₂n   O(n log n)   50ms\n随机 期望  log₂n   O(n log n)   50-60ms\n最大/最小    n        O(n²)     2500ms\n\n🎲 为什么随机pivot能救？\n固定选最后一个：\n· 已排序数组 → 100%是最差pivot ❌\n随机选：\n· 第一次选到最差概率：2/n\n· 连续选到最差概率：(2/n)ⁿ → 几乎为0\n数学保你不死！ ✅\n💎 一句话总结\n最好pivot是正中靶心的中位数，最差pivot是擦边过的大/最小值——前者一剑封喉，后者钝刀割肉。 🎯\n\n六、优化策略\n\n随机化pivot选择（避免最坏情况）\n\nint partitionRandom(vector&lt;int&gt;&amp; arr, int low, int high) &#123;    // 随机选择一个pivot    int randomIndex = low + rand() % (high - low + 1);    swap(arr[randomIndex], arr[high]);  // 放到最后，方便Lomuto分区    return partition(arr, low, high);&#125;\n\n三数取中法\n\nint medianOfThree(vector&lt;int&gt;&amp; arr, int low, int high) &#123;    int mid = low + (high - low) / 2;    // 对arr[low], arr[mid], arr[high]排序    if (arr[low] &gt; arr[mid]) swap(arr[low], arr[mid]);    if (arr[low] &gt; arr[high]) swap(arr[low], arr[high]);    if (arr[mid] &gt; arr[high]) swap(arr[mid], arr[high]);    // 将中位数放到high位置    swap(arr[mid], arr[high]);    return partition(arr, low, high);&#125;\n\n小数组使用插入排序\n\nvoid quickSortOptimized(vector&lt;int&gt;&amp; arr, int low, int high) &#123;    // 小数组用插入排序更快    if (high - low + 1 &lt; 10) &#123;        insertionSort(arr, low, high);        return;    &#125;    if (low &lt; high) &#123;        int pi = partitionRandom(arr, low, high);        quickSortOptimized(arr, low, pi - 1);        quickSortOptimized(arr, pi + 1, high);    &#125;&#125;\n 归并排序\n 堆排序\n 计数排序\n 基数排序\n 搜索\n 线性搜索\n 二分搜索\n 插值搜索\n 跳表\n","tags":["C++"]},{"title":"汇编语言","url":"/2026/02/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","content":" x64\n 寄存器\nRIP - 指令指针（64位扩展）· 指向下一条要执行的指令地址· 控制程序执行流程的关键· 查看：x/i $rip· 重要性：覆盖RIP = 控制程序流\nRSP - 栈指针（64位扩展）· 指向当前栈顶（最低地址）\nRBP - 基指针（64位扩展）           #每个函数调用的栈帧地址· 局部变量：[RBP - offset]        #用来定位buffer· 返回地址：[RBP + 8]· 参数（旧模式）：[RBP + 16]等操作系统 → _start（CRT） → __libc_start_main → main   ↑           ↑                ↑             ↑  初始RBP     借操作系统的      借_start的     借libc的\nRAX - 累加器· 最常用寄存器· 存放函数返回值· 系统调用号（Linux）· 算术运算结果RBX - 基址寄存器· 通常存放数据指针· 被调用者保存（callee-saved）RCX - 计数器· 循环计数器（rep指令）· 第4个函数参数· 字符串操作计数RDX - 数据寄存器· 配合RAX进行乘除法· 第3个函数参数· 系统调用参数3RSI - 源索引· 字符串/数组操作源指针· 第2个函数参数RDI - 目的索引· 字符串/数组操作目的指针· 第1个函数参数\nR8 - 扩展寄存器8  · 第5个函数参数R9 - 扩展寄存器9  · 第6个函数参数R10-R15  10-15  · 通用存储          12-15  · 被调用者保存// 有8个参数的函数void func(int a, int b, int c, int d, int e, int f, int g, int h) &#123;    // 参数分配：    // a → RDI    // b → RSI      // c → RDX    // d → RCX    // e → R8    // f → R9    // g → [RSP]      （栈上第一个）    // h → [RSP + 8]  （栈上第二个）&#125;\n 指令集\n一、数据移动与运算\n这些指令构建了程序的基本操作。\nMOV         MOV RAX, [RBP-0x10]      //数据从哪里来到哪里去（内存&lt;-&gt;寄存器， 立即数&lt;-&gt;内存）            MOV DWORD PTR [RSP], 0x5 //DWORD PTR 等限定符指明了操作数大小（4字节）。            LEA         LEA RAX, [RBP-0x10]      //加载有效地址，非取值。常用于计算数组索引、结构体成员地址，而不是移动数据。看到 LEA 通常是在准备指针。ADD/SUB     ADD RAX, RCX             SUB RSP, 0x20            //算术运算。SUB RSP 常用于分配栈空间，是函数开场的标志之一。栈区每个函数动态分配，编译器静态计算好。            INC/DEC     INC DWORD PTR [RAX]      //增减操作。常见于循环计数器。AND/OR/XOR  AND EAX, 0xFF             XOR RAX, RAX             //逻辑运算。XOR REG, REG 是清零寄存器的常见优化，比 MOV REG, 0 更快。            SHL/SHR     SHL RAX, 2               //移位运算。左移1位常等同于乘2，用于快速计算。\n二、流程控制（核心）\nCMP/TEST    CMP RAX, RBX   //比较测试，为后续跳转设置条件            TEST RAX, RAX  //CMP A,B 计算 A-B；TEST A,B 计算 A&amp;B，常用于测试是否为零或符号位。            Jcc家族      JE/JZ          //if (a == b) 或 if (var == 0)            JNE/JNZ        //if (a != b) 或 if (var != 0)            JG/JNLE        //if (a &gt; b) （a, b 为 int 型）核心记忆点：· E = Equal, Z = Zero -&gt; 判断相等。· NE = Not Equal, NZ = Not Zero -&gt; 判断不相等。· G = Greater (有符号), L = Less (有符号) -&gt; 判断大小（有符号数）。· A = Above (无符号), B = Below (无符号) -&gt; 判断高低（无符号数，常用于地址）。                  JMP         JMP 0x401000   //无条件跳转。对应 goto 或 break、函数尾返回前跳转等。CALL        CALL 0x401500  //函数调用 call funcA = 压入【下一条指令地址】 + 跳转到funcA                                                      （留下返回书签）   （去执行）            CALL RAX       //CALL 地址 是静态调用；CALL 寄存器 可能是动态调用（虚函数、回调函数、函数指针），需要追溯寄存器值的来源。            RET         ret = 从栈顶弹出值 + 跳转到那个值（ret弹出的值就是call预留的那个）\n三、栈操作\nPUSH/POP     PUSH RBP       //压栈、弹栈             POP RAX        //PUSH RBP 是标准函数开场，用于保存调用者的帧指针。POP 用于恢复寄存器。             ENTER/LEAVE  ENTER 0x20, 0  //ENTER 分配栈空间并建立帧（常用push代替）             LEAVE          //LEAVE 恢复栈帧，等同于 MOV RSP, RBP; POP RBP，常见于函数返回前。\n四、特定用途指令\nNOP     NOP                  //空操作        NOP DWORD PTR [RAX]  //用于对齐代码或“滑梯”（在Exploit中填充空间）。长 NOP 变体也常见。        INT     INT 0x80 (32位)      //TNT 0x80 是32位Linux系统调用        SYSCALL (64位)       //SYSCALL 是64位Linux系统调用。SYSENTER 也可用于系统调用。看到它们意味着程序正在请求内核服务。\n x32\n 寄存器\nEIP - 指令指针 (Extended Instruction Pointer)• 指向下一条要执行的指令地址• 不能直接修改，由控制流指令改变• 查看: `x/i $eip`• 重要性: 控制程序执行流程，漏洞利用的关键\nESP - 栈指针 (Extended Stack Pointer)• 指向栈顶（当前最低栈地址）• push时减小，pop时增大• 查看栈: `x/20wx $esp`• 操作:  - push value: ESP = ESP - 4; [ESP] = value  - pop reg: reg = [ESP]; ESP = ESP + 4EBP - 基指针 (Extended Base Pointer)• 当前函数栈帧的基准点• 用于访问局部变量和参数• 局部变量: [EBP - offset]• 函数参数: [EBP + offset]• 函数调用时:  push ebp        # 保存旧EBP  mov ebp, esp    # 设置新栈帧  sub esp, X      # 分配局部空间\nEAX - 累加器• 最常用寄存器• 存放函数返回值• 算术运算结果EBX - 基址寄存器• 通常存放数据指针ECX - 计数器• 循环计数器• 字符串操作计数EDX - 数据寄存器• 配合EAX进行乘除法• 存放数据ESI - 源索引寄存器• 字符串/内存操作的源地址EDI - 目标索引寄存器• 字符串/内存操作的目标地址\n 指令集\n\n基本格式\n\n标签:    操作码  操作数1, 操作数2   ; 注释; 例子：start:   mov     eax, 10          ; eax = 10         add     eax, 5           ; eax = 15         call    print            ; 调用print函数\n\n操作数类型\n\n立即数：   mov eax, 10          ; 直接数值寄存器：   mov eax, ebx         ; 寄存器值内存引用： mov eax, [ebx]       ; 内存地址的值          mov eax, [ebp+8]     ; 基址+偏移          mov eax, [ebx+ecx*4] ; 基址+索引*比例+偏移\n\n常用指令\n\n# 1. mov - 数据移动（最常用！）mov eax, ebx     ; eax = ebxmov eax, 10      ; eax = 10mov eax, [ebx]   ; eax = 内存[ebx]的值# 2. push/pop - 栈操作push eax         ; esp-=4, [esp]=eaxpop ebx          ; ebx=[esp], esp+=4# 3. add/sub - 加减add eax, ebx     ; eax = eax + ebxsub esp, 0x30    ; esp = esp - 0x30# 4. lea - 取地址（不是真加载！）lea eax, [ebp-0x2c]  ; eax = ebp - 0x2c（计算地址）# 5. call/ret - 函数调用返回call 0x1234      ; 调用函数ret              ; 返回# 6. cmp - 比较cmp eax, 10      ; 比较eax和10，设置标志位# 7. jmp/je/jne - 跳转jmp label        ; 无条件跳转je label         ; 如果相等跳转（ZF=1）jne label        ; 如果不相等跳转（ZF=0）# 8. test - 测试（类似cmp但用AND）test eax, eax    ; 测试eax是否为0# 9. xor - 异或清零xor eax, eax     ; eax = 0（快速清零）# 10. nop - 空操作nop              ; 什么也不做（填充或对齐）","categories":["-汇编语言"],"tags":["-汇编语言"]},{"title":"物体","url":"/2026/02/24/%E7%89%A9%E4%BD%93/","content":" 球体\n 一、核心思想：经纬度法\n把球体想象成地球仪：\n  北极 (i=0)    ●   /|\\\\  / | \\\\ /  |  \\\\●———●———● 赤道 (i=stackCount/2) \\\\  |  /  \\\\ | /   \\\\|/    ● 南极 (i=stackCount)\n 二、关键参数\nfloat radius = 1.0f;        // 半径int sectorCount = 36;       // 经度分段数（绕Y轴一圈分多少份）int stackCount = 18;        // 纬度分段数（从北极到南极分多少层）\n 三、顶点生成（双重循环）\n// 外层：纬度（上下）for (int i = 0; i &lt;= stackCount; ++i) &#123;    // 纬度角：从 +90° 到 -90°    stackAngle = M_PI / 2 - i * stackStep;    // 当前纬度圈的半径和高度    xy = radius * cos(stackAngle);  // 水平半径    z = radius * sin(stackAngle);   // 垂直高度    // 内层：经度（绕圈）    for (int j = 0; j &lt;= sectorCount; ++j) &#123;        // 经度角：从 0° 到 360°        sectorAngle = j * sectorStep;        // 球面坐标 → 直角坐标        x = xy * cos(sectorAngle);        y = xy * sin(sectorAngle);        // z 已在外层计算    &#125;&#125;\n坐标转换公式：\nx = r · cos(lat) · cos(lon)y = r · cos(lat) · sin(lon)z = r · sin(lat)\n 四、顶点数据布局（每个顶点8个float）\nvertices.push_back(x);   // 0: 位置Xvertices.push_back(y);   // 1: 位置Yvertices.push_back(z);   // 2: 位置Zvertices.push_back(nx);  // 3: 法线Xvertices.push_back(ny);  // 4: 法线Yvertices.push_back(nz);  // 5: 法线Zvertices.push_back(u);   // 6: 纹理Uvertices.push_back(v);   // 7: 纹理V\nstride = 8 * sizeof(float)\n 五、索引生成（三角形拼凑）\n每个四边形切成2个三角形：\n    当前圈:  A─────B            |     |    下圈:   C──────D三角形1 (上): (A, C, B)三角形2 (下): (B, C, D)\nint k1 = i * (sectorCount + 1);  // 当前圈起点int k2 = k1 + sectorCount + 1;   // 下圈起点// 上三角形indices.push_back(k1);      // Aindices.push_back(k2);      // Cindices.push_back(k1 + 1);  // B// 下三角形indices.push_back(k1 + 1);  // Bindices.push_back(k2);      // Cindices.push_back(k2 + 1);  // D\n 六、法线计算（球体特例）\n法线 = 顶点位置归一化\nlengthInv = 1.0f / radius;nx = x * lengthInv;ny = y * lengthInv;nz = z * lengthInv;\n 七、纹理坐标（UV映射）\nu = (float)j / sectorCount;  // 经度: 0 → 1 (从左到右)v = (float)i / stackCount;   // 纬度: 0 → 1 (从上到下)\n 八、顶点属性设置\n// 位置 (slot 0) - 3个floatglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);// 法线 (slot 1) - 3个floatglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));// 纹理 (slot 2) - 2个floatglVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));\n 九、绘制命令\nglDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);\n 十、精度控制\n参数        低模  中模  高模\nsectorCount 24   36   72\nstackCount  12   18   36\n顶点数       325  703  2701\n三角形数     1056 2304 9216\n💡 核心公式总结\n顶点位置 = 球面坐标 → 直角坐标法线方向 = 顶点位置 / 半径纹理坐标 = 经度/360°, 纬度/180°三角形索引 = 上下两圈交错连接\n","tags":["-图形学"]},{"title":"图形学编程","url":"/2026/02/24/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%BC%96%E7%A8%8B/","content":" openGL\n GLFW窗口管理\n 🏗️ GLFW 窗口管理函数\n\n初始化和终止\n\n// 初始化GLFW库int glfwInit(void);// 返回值：成功返回GLFW_TRUE，失败返回GLFW_FALSE// 终止GLFW，释放资源void glfwTerminate(void);\n\n窗口创建和销毁\n\n// 创建窗口GLFWwindow* glfwCreateWindow(    int width,                   // 窗口宽度（像素）    int height,                  // 窗口高度    const char* title,          // 窗口标题    GLFWmonitor* monitor,       // 全屏模式用，NULL为窗口模式    GLFWwindow* share           // 资源共享，NULL为不共享);// 返回值：成功返回窗口指针，失败返回NULL//写法2  // 创建窗口 GLFWwindow* window = glfwCreateWindow(600, 600, &quot;Chapter2 - program1 (GLAD)&quot;, NULL, NULL);// 销毁窗口void glfwDestroyWindow(GLFWwindow* window);\n\n窗口设置\n\n// 设置当前线程的主上下文void glfwMakeContextCurrent(GLFWwindow* window);// 检查窗口是否应该关闭int glfwWindowShouldClose(GLFWwindow* window);// 返回值：非0表示应该关闭1. glfwWindowShouldClose() - 只读检查int glfwWindowShouldClose(GLFWwindow* window);作用：检查窗口是否应该关闭（只读，不能设置）参数：只有窗口指针返回值：1(true)表示应该关闭，0(false)表示继续2. glfwSetWindowShouldClose() - 只写设置void glfwSetWindowShouldClose(GLFWwindow* window, int value);作用：设置窗口是否应该关闭（只写，设置标志）参数：窗口指针 + 布尔值\n\n缓冲区交换和事件处理\n\n// 交换前后缓冲区（双缓冲）void glfwSwapBuffers(GLFWwindow* window);// 处理等待中的事件void glfwPollEvents(void);\n\n窗口提示设置（在glfwCreateWindow前调用）\n\n// 设置窗口提示void glfwWindowHint(int hint, int value);// 常用提示：glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);  // OpenGL主版本glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);  // OpenGL次版本glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  // 核心模式\n\n输入处理\n\n// 获取按键状态int glfwGetKey(GLFWwindow* window, int key);// 返回值：GLFW_PRESS（按下）、GLFW_RELEASE（释放）// 常用按键常量：GLFW_KEY_ESCAPE     // ESC键GLFW_KEY_W          // W键GLFW_KEY_A          // A键GLFW_KEY_S          // S键GLFW_KEY_D          // D键GLFW_KEY_SPACE      // 空格键\n\n回调函数设置\n\n// 设置窗口大小改变回调（当窗口大小改变，自动渲染）void framebuffer_size_callback(GLFWwindow* window, int width, int height);glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n 🎨 OpenGL 核心函数\n\n视口设置\n\n// 设置OpenGL渲染视口void glViewport(    GLint x,        // 视口左下角x坐标（通常0）    GLint y,        // 视口左下角y坐标（通常0）    GLsizei width,  // 视口宽度    GLsizei height  // 视口高度);\n\n清屏和颜色设置\n\n// 设置清屏颜色（RGBA）void glClearColor(    GLfloat red,    // 红色分量 (0.0 ~ 1.0)    GLfloat green,  // 绿色分量    GLfloat blue,   // 蓝色分量    GLfloat alpha   // 透明度 (1.0为不透明));// 清空指定缓冲区void glClear(GLbitfield mask);// 常用掩码：GL_COLOR_BUFFER_BIT    // 颜色缓冲区GL_DEPTH_BUFFER_BIT    // 深度缓冲区GL_STENCIL_BUFFER_BIT  // 模板缓冲区\n\n获取OpenGL信息\n\n// 获取OpenGL版本信息const GLubyte* glGetString(GLenum name);// 常用参数：GL_VENDOR                  // 显卡厂商GL_RENDERER                // 显卡型号GL_VERSION                 // OpenGL版本GL_SHADING_LANGUAGE_VERSION // GLSL版本\n 🔧 GLAD 初始化函数\n加载OpenGL函数指针\n// 初始化GLAD，加载所有OpenGL函数指针int gladLoadGLLoader(GLADloadproc loader);// 使用方法（配合GLFW）：gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);\n glad着色器\n glad函数\n\nglCreateShader() - 创建着色器对象\n\nGLuint glCreateShader(GLenum shaderType);\n参数：\n· shaderType：着色器类型\n· GL_VERTEX_SHADER：顶点着色器\n· GL_FRAGMENT_SHADER：片段着色器\n· GL_GEOMETRY_SHADER：几何着色器（高级）\n· GL_TESS_CONTROL_SHADER：曲面细分控制着色器\n· GL_TESS_EVALUATION_SHADER：曲面细分评估着色器\n返回值：着色器对象的ID（GLuint），0表示失败\n示例：\nGLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n\n\nglShaderSource() - 设置着色器源代码\n\nvoid glShaderSource(GLuint shader,                    GLsizei count,                    const GLchar** string,                    const GLint* length);\n参数：\n· shader：着色器对象ID（来自glCreateShader）\n· count：字符串数量（通常为1）\n· string：指向源代码字符串的指针\n· length：源代码长度数组，NULL表示字符串以\\0结尾\n示例：\nconst char* shaderCode = &quot;#version 430\\\\nvoid main() &#123;...&#125;&quot;;glShaderSource(shader, 1, &amp;shaderCode, NULL);\n\n\nglCompileShader() - 编译着色器\n\nvoid glCompileShader(GLuint shader);\n参数：\n· shader：要编译的着色器对象ID\n重要：编译后必须检查编译状态！\n示例：\nglCompileShader(vertexShader);// 检查编译错误GLint success;glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);if (!success) &#123;    char infoLog[512];    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;着色器编译失败: &quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#125;\n\n\nglCreateProgram() - 创建着色器程序\n\nGLuint glCreateProgram(void);\n返回值：程序对象ID（GLuint），0表示失败\n示例：\n\n\nglAttachShader() - 附加着色器到程序\n\nvoid glAttachShader(GLuint program, GLuint shader);\n参数：\n· program：程序对象ID\n· shader：着色器对象ID\n注意：一个着色器可以附加到多个程序\nglAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);\n\n\nglLinkProgram() - 链接着色器程序\n\nvoid glLinkProgram(GLuint program);\n参数：\n· program：要链接的程序对象ID\n重要：链接后必须检查链接状态！\n示例：\nglLinkProgram(shaderProgram);// 检查链接错误GLint success;glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if (!success) &#123;    char infoLog[512];    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;程序链接失败: &quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#125;\n\n\nglUseProgram() - 激活着色器程序\n\nvoid glUseProgram(GLuint program);\n参数：\n· program：要使用的程序对象ID，0表示停用所有程序\n示例：\nglUseProgram(shaderProgram);  // 激活程序// ... 绘制操作 ...glUseProgram(0);              // 停用程序（可选）\n\n\nglDeleteShader() - 删除着色器对象\n\nvoid glDeleteShader(GLuint shader);\n参数：\n· shader：要删除的着色器对象ID\n最佳实践：链接程序后可以删除着色器对象\n示例：\nglDeleteShader(vertexShader);glDeleteShader(fragmentShader);\n\n\nglPointSize() - 设置点的大小\n\nvoid glPointSize(GLfloat size);\n参数：\n· size：点的直径（像素）\n注意：只在GL_POINTS绘制模式时有效\n示例：\nglPointSize(30.0f);  // 画30像素大的点\n\n设置视口\n\nint width, height;glfwGetFramebufferSize(window, &amp;width, &amp;height);  // 获取窗口尺寸，隐式定义指针glViewport(0, 0, width, height);glViewport(100, 100, 600, 400);// 这意味着：// 左下角：窗口坐标(100, 100)// 右上角：窗口坐标(100+600, 100+400) = (700, 500)// 视口区域：从(100,100)到(700,500)的矩形OpenGL渲染流程：+----------------+     +----------------+     +----------------+|  后台缓冲区   | →   |  交换操作    | →   |  前台缓冲区     || (Back Buffer)  |     | (glfwSwapBuffers)|   | (Front Buffer) ||  - GPU正在渲染 |     |                |     |  - 正在显示     ||  - 用户看不到  |     |                |     |  - 用户看到     |+----------------+     +----------------+     +----------------+\n\n 🎨 绘制函数\nglDrawArrays() - 绘制图元\nvoid glDrawArrays(GLenum mode, GLint first, GLsizei count);\n参数：\n· mode：绘制模式（要画什么）\n· GL_POINTS：点\n· GL_LINES：线\n· GL_LINE_STRIP：连续折线\n· GL_LINE_LOOP：闭合折线\n· GL_TRIANGLES：三角形（最常用）\n· GL_TRIANGLE_STRIP：三角形带\n· GL_TRIANGLE_FAN：三角形扇\n· first：从第几个顶点开始（通常为0）\n· count：使用多少个顶点\n示例：\n// 画一个点glDrawArrays(GL_POINTS, 0, 1);// 画一个三角形（3个顶点）glDrawArrays(GL_TRIANGLES, 0, 3);// 画一条线（2个顶点）glDrawArrays(GL_LINES, 0, 2);\n\n\n错误检查\n\n1. glGetShaderiv(GLuint shader, GLenum pname, GLint *params)功能：获取着色器对象的信息（iv表示返回的是整数向量）。参数：· shader：要查询的着色器对象ID· pname：要查询的参数类型（枚举常量）  · GL_COMPILE_STATUS：查询编译是否成功（返回GL_TRUE/GL_FALSE）  · GL_SHADER_TYPE：查询着色器类型（顶点/片段/几何等）  · GL_INFO_LOG_LENGTH：获取信息日志的长度（字符数）  · GL_SHADER_SOURCE_LENGTH：获取着色器源代码的长度· params：指向存储结果的整数数组的指针2. glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)功能：获取着色器编译的信息日志，特别是编译错误信息。参数：· shader：要查询的着色器对象ID· maxLength：infoLog缓冲区的最大长度（包括空终止符）· length：指向实际写入日志长度的指针（可为NULL）· infoLog：指向存储日志的字符数组的指针3. glGetProgramiv() - 获取程序状态void glGetProgramiv(GLuint program, GLenum pname, GLint* params);常用参数：· GL_LINK_STATUS：链接是否成功· GL_VALIDATE_STATUS：验证是否成功· GL_ATTACHED_SHADERS：附加的着色器数量4. glGetProgramInfoLog() - 获取程序链接日志void glGetProgramInfoLog(GLuint program, GLsizei maxLength,                        GLsizei* length, GLchar* infoLog);\n 🔄 完整着色器创建流程\n1.  glCreateShader()      // 创建着色器对象2.  glShaderSource()      // 设置源代码3.  glCompileShader()     // 编译4.  检查编译错误          // glGetShaderiv/glGetShaderInfoLog5.  glCreateProgram()     // 创建程序6.  glAttachShader()      // 附加着色器7.  glLinkProgram()       // 链接程序8.  检查链接错误          // glGetProgramiv/glGetProgramInfoLog9.  glDeleteShader()      // 删除着色器（链接后）10. glUseProgram()       // 使用程序\n openGL初始化&amp;render渲染\n 一、初始化函数 init()\n\ncreateShaderProgram()\n\nshaderProgram = createShaderProgram(&quot;shaders/triangle.vert&quot;, &quot;shaders/triangle.frag&quot;);\n作用：创建并编译着色器程序\n· 读取顶点着色器(.vert)和片段着色器(.frag)文件\n· 编译两个着色器并链接成可执行程序\n· 返回着色器程序的ID\n\n定义顶点数据\n\nfloat vertices[] = &#123;...&#125;;\n作用：定义三角形的几何数据\n· 每个顶点包含：3个位置坐标 + 3个颜色值(RGB)\n· 共3个顶点，组成一个三角形\n· 数据格式：交错数组(位置+颜色交错存储)\n\nglGenVertexArrays() 和 glGenBuffers()\n\nglGenVertexArrays(1, &amp;VAO);glGenBuffers(1, &amp;VBO);\n作用：生成OpenGL对象\n· VAO：顶点数组对象，记录顶点属性配置\n· VBO：顶点缓冲区对象，存储顶点数据到GPU内存\n\nglBindVertexArray()\n\nglBindVertexArray(VAO);\n作用：绑定VAO\n· 开始记录顶点属性配置\n· 后续的顶点属性设置都会记录到这个VAO中\n\nglBindBuffer() 和 glBufferData()\n\nglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n作用：绑定VBO并上传数据\n· glBindBuffer()：指定操作哪个缓冲区\n· glBufferData()：将CPU数据复制到GPU的VBO中\n· GL_STATIC_DRAW：提示数据不会频繁修改，GPU可以优化存储\n\nglVertexAttribPointer()（核心函数）\n\n// 位置属性glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);// 颜色属性glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));\n作用：配置如何从VBO读取数据\n参数详解：\n· 参数1：属性索引（对应着色器中的location）\n· 参数2：每个顶点读取的分量数（3表示vec3）\n· 参数3：数据类型（GL_FLOAT表示float）\n· 参数4：是否归一化（GL_FALSE表示不归一化）\n· 参数5：步长（从一个顶点到下一个顶点的字节数） 6 * sizeof(float) = 24字节\n· 参数6：偏移量（该属性在顶点内的起始位置） 位置：从0字节开始\n· 颜色：从12字节（3个float）开始\n\nglEnableVertexAttribArray()\n\nglEnableVertexAttribArray(0);glEnableVertexAttribArray(1);\n作用：启用顶点属性\n· 告诉OpenGL启用对应索引的顶点属性\n· 只有启用后，着色器才能接收到数据\n\n解绑操作\n\nglBindBuffer(GL_ARRAY_BUFFER, 0);glBindVertexArray(0);\n作用：解除绑定，避免意外修改\n· 遵循&quot;使用后解绑&quot;的良好编程习惯\n 二、渲染函数 render()\n\nglClearColor() 和 glClear()\n\nglClearColor(0.2f, 0.3f, 0.3f, 1.0f);glClear(GL_COLOR_BUFFER_BIT);\n作用：清屏\n· glClearColor()：设置清屏颜色（青绿色）\n· glClear()：用设置的颜色清除颜色缓冲区\n\nglUseProgram()\n\nglUseProgram(shaderProgram);\n作用：激活着色器程序\n· 告诉OpenGL使用哪个着色器程序进行渲染\n\nglBindVertexArray()\n\nglBindVertexArray(VAO);\n作用：绑定VAO\n· 恢复之前配置的所有顶点属性状态\n· 自动关联对应的VBO和属性配置\n\nglDrawArrays()（核心渲染函数）\n\nglDrawArrays(GL_TRIANGLES, 0, 3);\n作用：执行绘制命令\n· 参数1：绘制模式（GL_TRIANGLES表示绘制三角形）\n· 参数2：起始顶点索引（从第0个顶点开始）\n· 参数3：绘制的顶点数（绘制3个顶点，组成1个三角形）\n\n解绑VAO\n\nglBindVertexArray(0);\n作用：渲染完成后解绑VAO\n 三、回调函数 framebuffer_size_callback()\nglViewport()\nglViewport(0, 0, width, height);\n作用：设置视口（渲染区域）\n· 当窗口大小改变时被调用\n· 确保渲染内容正确适应新窗口尺寸\n· 参数1,2：视口左下角在窗口中的位置\n· 参数3,4：视口的宽度和高度（实际像素数）\n 四、数据流程图\nCPU内存(vertices数组)    ↓ glBufferData()GPU内存(VBO中)    ↓ VAO配置(glVertexAttribPointer)顶点着色器(location 0,1接收)    ↓ glDrawArrays()光栅化(颜色插值)    ↓片段着色器    ↓帧缓冲区    ↓ glfwSwapBuffers()窗口显示\n 五、关键概念总结\n对象 作用 类比\nVBO 存储顶点数据 仓库（存放货物）\nVAO 记录数据读取方式 仓库管理手册\nShader 处理数据的程序 加工机器\nglDrawArrays 开始渲染 开始生产\nglViewport 设置显示区域 决定在哪个屏幕上显示\n 顶点着色器\n 一、基本概念\n\n定义\n\n顶点着色器是一个运行在GPU上的小程序，对渲染管线的每个顶点执行一次。\n\n主要职责\n\n· 处理顶点数据（位置、颜色、法线、纹理坐标等）\n· 执行坐标变换（模型→世界→视图→投影）\n· 传递数据给后续渲染阶段\n\n执行时机\n\n顶点数据 → 顶点着色器 → 光栅化 → 片段着色器  ↓          ↓        ↓        ↓每个顶点    每个顶点   生成片段   每个像素\n 二、核心代码结构\n基本模板：\n#version 430 core                  // 1. 版本声明layout (location = 0) in vec3 aPos;  // 2. 输入：顶点位置layout (location = 1) in vec3 aColor;//   输入：顶点颜色out vec3 ourColor;                 // 3. 输出：给片段着色器void main() &#123;                      // 4. 主函数    gl_Position = vec4(aPos, 1.0);   // 必须：设置顶点位置    ourColor = aColor;               // 可选：传递颜色&#125;\n 三、关键组件详解\n\n输入（in变量）\n\n// 从VAO/VBO接收数据layout (location = X) in 类型 变量名;\n· location = X：对应C++中glVertexAttribPointer的第一个参数\n· 类型：vec2、vec3、vec4等\n· 数据来源：VAO配置的顶点属性\n\n输出\n\n· 必需输出：gl_Position（内置变量，vec4类型）\n· 表示顶点在裁剪空间中的最终位置\n· 自定义输出：使用out关键字\n· 传递给片段着色器的数据（如颜色、纹理坐标）\n· 会被光栅化插值\n\nUniform变量\n\nuniform 类型 变量名;  // 从C++传入的全局变量\n用途：\n· 变换矩阵（模型、视图、投影）\n· 时间（用于动画）\n· 光照参数\n· 其他全局设置\n 四、向量类型系统\n类型 分量数 常用场景\nvec2  2   纹理坐标(uv)、2D位置\nvec3  3   3D位置(xyz)、颜色(rgb)、法线\nvec4  4   齐次坐标、RGBA颜色\nvec1  1   极少用（直接用float）\n向量操作：\n// 构造vec3 pos = vec3(1.0, 2.0, 3.0);vec4 color = vec4(1.0, 0.0, 0.0, 1.0);  // 红色，不透明// 访问分量float x = pos.x;      // 1.0vec2 xy = pos.xy;     // (1.0, 2.0)// Swizzle（分量重排）vec3 yxz = pos.yxz;   // (2.0, 1.0, 3.0)// 运算vec3 a = vec3(1.0, 2.0, 3.0);vec3 b = vec3(4.0, 5.0, 6.0);vec3 c = a + b;              // 向量加float dot = dot(a, b);       // 点积：32.0vec3 cross = cross(a, b);    // 叉积（仅vec3）\n 五、3D图形学变换\n标准变换流程：\n#version 430 corelayout (location = 0) in vec3 aPos;uniform mat4 model;      // 模型矩阵（物体变换）uniform mat4 view;       // 视图矩阵（摄像机）uniform mat4 projection; // 投影矩阵（3D→2D）void main() &#123;    // 完整的MVP变换    gl_Position = projection * view * model * vec4(aPos, 1.0);&#125;\n各变换矩阵作用：\n· 模型矩阵：物体坐标系 → 世界坐标系\n· 平移、旋转、缩放物体\n· 视图矩阵：世界坐标系 → 摄像机坐标系\n· 摄像机位置和方向\n· 投影矩阵：3D空间 → 2D标准化设备坐标\n· 透视/正交投影\n 六、高级应用\n\n简单动画\n\nuniform float time;void main() &#123;    // 上下波动    float wave = sin(aPos.x * 5.0 + time) * 0.1;    vec3 newPos = vec3(aPos.x, aPos.y + wave, aPos.z);    gl_Position = vec4(newPos, 1.0);&#125;\n\n顶点光照计算\n\nlayout (location = 2) in vec3 aNormal;uniform vec3 lightPos;uniform vec3 lightColor;out vec3 LightingColor;void main() &#123;    // 计算光照（在顶点着色器中，性能好但质量低）    vec3 lightDir = normalize(lightPos - aPos);    float diff = max(dot(aNormal, lightDir), 0.0);    LightingColor = diff * lightColor;&#125;\n\n几何变形\n\n// 扭曲效果uniform float twistFactor;void main() &#123;    float angle = aPos.y * twistFactor;    float cosA = cos(angle);    float sinA = sin(angle);    mat2 rot = mat2(cosA, -sinA, sinA, cosA);    vec2 twisted = rot * aPos.xz;    gl_Position = vec4(twisted.x, aPos.y, twisted.y, 1.0);&#125;\n 七、与C++的数据连接\n数据流向：\nC++程序 → VAO配置 → 顶点着色器 → 片段着色器   ↓        ↓          ↓         ↓设置uniform  定义属性  接收in变量  接收插值后数据            layout   处理计算   最终颜色输出\n连接步骤：\n\n\nC++中配置VAO：\n glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, offset);\n\n\n着色器声明对应location：\n layout (location = 0) in vec3 aPos;\n\n\n传递uniform：\n // C++中GLint loc = glGetUniformLocation(program, &quot;time&quot;);glUniform1f(loc, currentTime);\n\n\n 片段着色器\n 一、基本概念\n定义\n片段着色器（Fragment Shader）是GPU渲染管线的最后一个可编程阶段，处理每个像素（片段） 的最终颜色。\n核心职责\n· 计算每个像素的最终颜色\n· 应用纹理、光照、阴影等效果\n· 决定像素是否被丢弃（透明度、深度测试等）\n执行时机\n顶点着色器 → 光栅化 → 片段着色器 → 帧缓冲区\n↓         ↓         ↓         ↓\n每个顶点    生成片段   每个像素    最终图像\n​\n· 执行次数 = 屏幕像素数（或可见片段数）\n· 通常执行次数 &gt;&gt; 顶点着色器执行次数\n二、核心代码结构\n基本模板：\n#version 430 core                // 1. 版本声明in vec3 ourColor;                // 2. 输入：从顶点着色器来（插值后）in vec2 TexCoord;                //    其他插值数据out vec4 FragColor;              // 3. 输出：最终像素颜色（必须！）uniform sampler2D ourTexture;    // 4. Uniform变量：纹理采样器void main() &#123;                    // 5. 主函数    // 简单颜色输出    FragColor = vec4(ourColor, 1.0);    // 或纹理采样    // FragColor = texture(ourTexture, TexCoord);&#125;\n 三、关键组件详解\n输入（in变量）in 类型 变量名;  // 从顶点着色器传递，经过光栅化插值​特点：· 自动插值：三角形顶点间的平滑过渡· 无location：与顶点着色器的out变量名对应· 典型输入：· 颜色：in vec3 ourColor;· 纹理坐标：in vec2 TexCoord;· 法线：in vec3 Normal;· 世界坐标：in vec3 FragPos;输出· 必需输出：至少一个out变量（通常是FragColor）out vec4 FragColor;  // RGBA颜色，A=透明度​· 多渲染目标（MRT）：layout(location = 0) out vec4 ColorBuffer;layout(location = 1) out vec4 NormalBuffer;layout(location = 2) out vec4 PositionBuffer;​Uniform变量uniform 类型 变量名;  // 从C++传入，所有片段共享​常用uniform：· 纹理采样器：sampler2D, samplerCube· 时间：float time· 光照参数：vec3 lightPos, vec3 lightColor· 材质属性：vec3 ambient, vec3 diffuse, vec3 specular· 摄像机位置：vec3 viewPos\n 四、内置变量与函数\n重要内置变量// 片段信息vec4 gl_FragCoord;      // 像素坐标(x,y,z,w)，z是深度bool gl_FrontFacing;    // 是否正面朝向vec2 gl_PointCoord;     // 点精灵的纹理坐标// 深度控制（可选）float gl_FragDepth;     // 手动设置深度值​核心内置函数// 纹理采样vec4 texture(sampler2D sampler, vec2 coord);vec4 texture(samplerCube sampler, vec3 coord);// 数学函数float length(vec2/vec3 v);    // 向量长度vec3 normalize(vec3 v);       // 单位化float dot(vec3 a, vec3 b);    // 点积vec3 cross(vec3 a, vec3 b);   // 叉积float mix(float a, float b, float t); // 线性插值// 噪声与随机float noise(vec2/vec3 p);     // 柏林噪声\n​\n 五、纹理处理\n基本纹理采样uniform sampler2D texture1;in vec2 TexCoord;void main() &#123;    // 采样纹理    vec4 texColor = texture(texture1, TexCoord);    // 混合纹理和颜色    FragColor = texColor * vec4(ourColor, 1.0);&#125;​多纹理混合uniform sampler2D texture1;uniform sampler2D texture2;uniform float mixValue;void main() &#123;    vec4 tex1 = texture(texture1, TexCoord);    vec4 tex2 = texture(texture2, TexCoord);    FragColor = mix(tex1, tex2, mixValue);&#125;​纹理过滤与包装// 纹理坐标变换（处理超出[0,1]范围）vec2 wrappedCoord = fract(TexCoord);  // 重复纹理vec2 mirroredCoord = abs(TexCoord);   // 镜像重复// 自定义采样vec4 customSample(sampler2D tex, vec2 coord) &#123;    return texture(tex, coord);&#125;\n glm数学工具库\n 📦 GLM核心概念\nGLM = OpenGL Mathematics，专为图形学设计的数学库\n#include &lt;glm/glm.hpp&gt;              // 核心库#include &lt;glm/gtc/matrix_transform.hpp&gt; // 变换函数#include &lt;glm/gtc/type_ptr.hpp&gt;     // 类型指针转换\n 🔢 基本数据类型\n向量 (Vectors)\nglm::vec2 v2(1.0f, 2.0f);          // 2D向量 (x, y)glm::vec3 v3(1.0f, 2.0f, 3.0f);    // 3D向量 (x, y, z) ← 最常用！glm::vec4 v4(1.0f, 2.0f, 3.0f, 1.0f); // 4D向量 (x, y, z, w)// 访问分量float x = v3.x;     // 直接访问float y = v3[1];    // 数组式访问float z = v3.r;     // 颜色式访问 (r,g,b,a)// 常用向量glm::vec3 zero = glm::vec3(0.0f);          // (0,0,0)glm::vec3 one = glm::vec3(1.0f);           // (1,1,1)glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); // 上方向\n矩阵 (Matrices)\nglm::mat2 m2;        // 2×2矩阵glm::mat3 m3;        // 3×3矩阵glm::mat4 m4;        // 4×4矩阵 ← 3D变换最常用！// 创建单位矩阵（什么都不做的矩阵）glm::mat4 identity = glm::mat4(1.0f);  // 对角线为1，其他为0// [1, 0, 0, 0]// [0, 1, 0, 0]// [0, 0, 1, 0]// [0, 0, 0, 1]// 访问元素float elem = m4[0][1];  // 第0行第1列\n 🚀 变换矩阵 (Transformations)\n\n平移 (Translation)\n\nglm::mat4 model = glm::mat4(1.0f);  // 单位矩阵model = glm::translate(model, glm::vec3(1.0f, 2.0f, 3.0f));// 将物体移动到(1, 2, 3)位置\n\n旋转 (Rotation)\n\n// 绕特定轴旋转（角度单位：弧度）model = glm::rotate(model, angle, glm::vec3(0.0f, 1.0f, 0.0f));// 绕Y轴旋转angle弧度// 常用：度转弧度float radians = glm::radians(45.0f);  // 45度转弧度model = glm::rotate(model, glm::radians(45.0f), glm::vec3(1.0f, 0.0f, 0.0f));// 绕多个轴旋转（注意顺序！）glm::mat4 rotation = glm::mat4(1.0f);rotation = glm::rotate(rotation, angleX, glm::vec3(1,0,0)); // X轴rotation = glm::rotate(rotation, angleY, glm::vec3(0,1,0)); // Y轴rotation = glm::rotate(rotation, angleZ, glm::vec3(0,0,1)); // Z轴\n\n缩放 (Scaling)\n\nmodel = glm::scale(model, glm::vec3(2.0f, 2.0f, 2.0f));  // 均匀放大2倍model = glm::scale(model, glm::vec3(1.0f, 2.0f, 1.0f));  // 只在Y轴拉伸2倍\n 📐 视图和投影矩阵\n视图矩阵 (View Matrix) - “相机”\n// 方法1：直接平移（相机后退）glm::mat4 view = glm::mat4(1.0f);view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));  // 相机在Z=3// 方法2：使用lookAt（更直观）glm::mat4 view = glm::lookAt(    glm::vec3(0.0f, 0.0f, 3.0f),   // 相机位置    glm::vec3(0.0f, 0.0f, 0.0f),   // 看向的目标点    glm::vec3(0.0f, 1.0f, 0.0f)    // 相机的&quot;上&quot;方向);\n投影矩阵 (Projection Matrix)\n// 透视投影 (3D效果，有近大远小)glm::mat4 projection = glm::perspective(    glm::radians(45.0f),            // 视野角度(FOV) - 常用45°    (float)width / (float)height,   // 宽高比    0.1f,                           // 近平面 - 最近能看到哪里    100.0f                          // 远平面 - 最远能看到哪里);// 正交投影 (2D/UI，无近大远小)glm::mat4 ortho = glm::ortho(    -2.0f, 2.0f,     // 左/右边界    -1.5f, 1.5f,     // 下/上边界    0.1f, 100.0f     // 近/远平面);\n 🧮 矩阵操作和组合\n矩阵乘法顺序\n// 重要：矩阵乘法顺序是从右向左！glm::mat4 mvp = projection * view * model;// 等价于：// 1. 先应用模型变换：model × vertex// 2. 再应用视图变换：view × (model × vertex)// 3. 最后投影：projection × (view × model × vertex)\n变换顺序很重要！\n// ❌ 错误顺序：先移动后旋转glm::mat4 wrong = glm::rotate(glm::mat4(1.0f), angle, axis)                * glm::translate(glm::mat4(1.0f), position);// 物体会绕世界原点旋转！// ✅ 正确顺序：先旋转后移动glm::mat4 correct = glm::translate(glm::mat4(1.0f), position)                  * glm::rotate(glm::mat4(1.0f), angle, axis);// 物体绕自身中心旋转，然后移动\n 📊 向量和矩阵运算\n向量运算\nglm::vec3 a(1.0f, 2.0f, 3.0f);glm::vec3 b(4.0f, 5.0f, 6.0f);// 基本运算glm::vec3 c = a + b;      // 加法 (5,7,9)glm::vec3 d = a - b;      // 减法 (-3,-3,-3)glm::vec3 e = a * 2.0f;   // 数乘 (2,4,6)glm::vec3 f = a / 2.0f;   // 数除 (0.5,1,1.5)// 点积（结果：标量）- 用于求角度、投影float dot = glm::dot(a, b);  // 1*4 + 2*5 + 3*6 = 32// 叉积（结果：向量）- 用于求法线、垂直向量glm::vec3 cross = glm::cross(a, b);  // 垂直于a和b的向量// 长度和归一化float length = glm::length(a);        // 向量长度glm::vec3 normalized = glm::normalize(a); // 单位向量（长度为1）// 距离float distance = glm::distance(a, b); // a和b之间的距离\n矩阵运算\nglm::mat4 A = glm::mat4(1.0f);glm::mat4 B = glm::translate(glm::mat4(1.0f), glm::vec3(1,0,0));// 矩阵乘法glm::mat4 C = A * B;  // 组合变换// 矩阵求逆glm::mat4 inverse = glm::inverse(A);  // 逆矩阵// 矩阵转置glm::mat4 transpose = glm::transpose(A);\n​\n uniform函数封装\n 📦 OpenGL Uniform原装函数库\n核心头文件\n#include &lt;glad/glad.h&gt;  // 包含所有glUniform*函数声明\n所有glUniform函数一览表\n函数 参数格式 对应GLSL类型 用途标量类glUniform1&#123;i/ui/f&#125; (loc, value) int/uint/float 单个值glUniform2&#123;i/ui/f&#125; (loc, v0, v1) ivec2/uvec2/vec2 2分量glUniform3&#123;i/ui/f&#125; (loc, v0, v1, v2) ivec3/uvec3/vec3 3分量glUniform4&#123;i/ui/f&#125; (loc, v0, v1, v2, v3) ivec4/uvec4/vec4 4分量数组类glUniform1&#123;i/ui/f&#125;v (loc, count, array) int[]/float[] 标量数组glUniform2&#123;i/ui/f&#125;v (loc, count, array) vec2[] 2D向量数组glUniform3&#123;i/ui/f&#125;v (loc, count, array) vec3[] 3D向量数组glUniform4&#123;i/ui/f&#125;v (loc, count, array) vec4[] 4D向量数组矩阵类glUniformMatrix2fv (loc, count, transpose, array) mat2 2×2矩阵glUniformMatrix3fv (loc, count, transpose, array) mat3 3×3矩阵glUniformMatrix4fv (loc, count, transpose, array) mat4 4×4矩阵glUniformMatrix2x3fv (loc, count, transpose, array) mat2x3 2×3矩阵glUniformMatrix3x2fv (loc, count, transpose, array) mat3x2 3×2矩阵\n\n 🔧 Uniform原装函数详细用法\n\n获取Uniform位置（必须第一步）\n\nGLint location = glGetUniformLocation(GLuint program, const char* name);// 返回值：-1表示没找到，≥0表示位置索引// 例如：glGetUniformLocation(shaderProgram, &quot;model&quot;);\n\n必须激活着色器程序\n\nglUseProgram(shaderProgram);  // 必须先调用！// 之后才能设置这个程序的uniform\n\n标量设置示例\n\n// 设置单个floatglUniform1f(location, 3.14f);// 设置单个intglUniform1i(location, 42);// 设置vec3 (3个float)glUniform3f(location, 1.0f, 0.0f, 0.0f);  // 红色\n\n向量数组设置\n\n// 设置vec3数组GLfloat colors[] = &#123;    1.0f, 0.0f, 0.0f,  // 红色    0.0f, 1.0f, 0.0f,  // 绿色    0.0f, 0.0f, 1.0f   // 蓝色&#125;;glUniform3fv(location, 3, colors);  // 3个vec3\n\n矩阵设置（最常用！）\n\n// 设置4×4矩阵glm::mat4 model = glm::mat4(1.0f);glUniformMatrix4fv(location,          // uniform位置                   1,                 // 矩阵数量                   GL_FALSE,          // 是否转置（GLM是列主序）                   glm::value_ptr(model)); // 数据指针\n\n完整流程示例\n\n// 原装OpenGL uniform设置流程GLuint shaderProgram = ...;  // 已链接着色器程序// 1. 激活程序glUseProgram(shaderProgram);// 2. 获取所有uniform位置GLint modelLoc = glGetUniformLocation(shaderProgram, &quot;model&quot;);GLint viewLoc = glGetUniformLocation(shaderProgram, &quot;view&quot;);GLint projLoc = glGetUniformLocation(shaderProgram, &quot;projection&quot;);GLint colorLoc = glGetUniformLocation(shaderProgram, &quot;color&quot;);// 3. 设置uniform值glm::mat4 model = glm::translate(glm::mat4(1.0f), glm::vec3(1,0,0));glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));glm::mat4 view = glm::lookAt(...);glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));glm::mat4 projection = glm::perspective(...);glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(projection));glUniform3f(colorLoc, 1.0f, 0.0f, 0.0f);  // 红色\n\n stack库\n 一、基本概念\n什么是 stack？\n#include &lt;stack&gt;// 栈（Stack）：后进先出（LIFO）的数据结构// 比喻：叠盘子 - 最后放的盘子最先拿走\n底层实现\n// std::stack 是容器适配器，默认用 deque 实现template&lt;    class T,    class Container = std::deque&lt;T&gt;  // 可以换成 vector 或 list&gt; class stack;\n\n 二、核心函数（3个基本操作）\n\npush() - 压栈/入栈\n\nstd::stack&lt;int&gt; s;s.push(10);     // 栈：[10]s.push(20);     // 栈：[10, 20]s.push(30);     // 栈：[10, 20, 30]// 时间复杂度：O(1)\n\ntop() - 查看栈顶\n\nint value = s.top();  // 返回30，但不移除// 栈仍为：[10, 20, 30]// 重要：如果栈为空，调用 top() 是未定义行为！\n\npop() - 弹栈/出栈\n\ns.pop();  // 移除30// 栈变为：[10, 20]// 注意：pop() 不返回元素！只移除！\n\n 三、辅助函数\n\nempty() - 判断栈是否为空\n\nwhile (!s.empty()) &#123;  // 栈不为空时循环    s.pop();&#125;// 安全清空栈的方法\n\nsize() - 获取栈中元素数量\n\nstd::cout &lt;&lt; &quot;栈大小: &quot; &lt;&lt; s.size() &lt;&lt; std::endl;\n\n 四、常见错误用法\n错误1：pop() 获取值\n// ❌ 错误！int x = s.pop();  // 编译错误！pop() 不返回值// ✅ 正确做法：int x = s.top();  // 先获取s.pop();          // 再移除\n错误2：空栈时调用 top()\nstd::stack&lt;int&gt; emptyStack;// ❌ 危险！int x = emptyStack.top();  // 未定义行为！// ✅ 安全做法：if (!emptyStack.empty()) &#123;    int x = emptyStack.top();&#125;\n\n 五、在图形学中的实际应用\n\n矩阵堆栈（经典应用）\n\nstd::stack&lt;glm::mat4&gt; matrixStack;// 保存当前变换状态matrixStack.push(currentMatrix);// 应用局部变换currentMatrix = glm::translate(currentMatrix, position);// 渲染物体...// 恢复之前状态currentMatrix = matrixStack.top();matrixStack.pop();\n\n太阳系层级变换示例\n\n// 模拟 OpenGL 的矩阵堆栈std::stack&lt;glm::mat4&gt; mvStack;mvStack.push(glm::mat4(1.0f));  // 单位矩阵// 太阳glm::mat4 sunModel = mvStack.top();// 行星（继承太阳的坐标系）mvStack.push(mvStack.top());  // 保存状态glm::mat4 planetModel = mvStack.top();planetModel = glm::translate(planetModel, planetPosition);// 月球（继承行星位置）mvStack.push(planetModel);  // 保存行星位置// ...月球变换...mvStack.pop();  // 回到行星位置\n\n 六、底层容器更换\n使用不同底层容器\n// 默认：deque（平衡性能）std::stack&lt;int&gt; s1;// 使用 vector（连续内存）std::stack&lt;int, std::vector&lt;int&gt;&gt; s2;// 使用 list（快速插入删除）std::stack&lt;int, std::list&lt;int&gt;&gt; s3;// 所有接口完全相同！\n性能对比\n// push()/pop() 性能：deque:  平均 O(1)，适合通用场景vector: 平均 O(1)，但扩容时 O(n)list:   总是 O(1)，但内存开销大\n\n 七、栈 vs 内存栈的区别\n重要区分\n// std::stack（数据结构）            内存栈（系统栈）// -----------------------------   --------------------// 在堆上管理数据                   存储局部变量、返回地址// 大小只受系统内存限制              固定大小（通常1-8MB）// 手动 push/pop 管理               自动分配/释放// 可以存任意对象                   只能存基本类型和指针\n验证示例\n#include &lt;stack&gt;#include &lt;iostream&gt;void test() &#123;    // std::stack 对象本身在栈内存上（很小）    std::stack&lt;int&gt; s;    // 但它的数据在堆上，可以很大    for (int i = 0; i &lt; 1000000; i++) &#123;        s.push(i);  // 100万数据，不会栈溢出！    &#125;    std::cout &lt;&lt; &quot;栈大小: &quot; &lt;&lt; s.size() &lt;&lt; std::endl;&#125;\n\n 纹理、法线、材质、光源\n 一、纹理（Texture）\n1.1 什么是纹理？\n纹理 = 贴图 = 覆盖在3D模型表面的图片\n模型是骨架，纹理是皮肤球体是地球仪，纹理是世界地图\n1.2 纹理坐标（UV）\n// 每个顶点对应图片上的一个点u = (float)j / sectorCount;  // 横向：0 → 1（左到右）v = (float)i / stackCount;   // 纵向：0 → 1（上到下）// 顶点数据布局（8个float）[xyz][nx ny nz][u v]位置   法线    纹理坐标\n1.3 纹理加载（stb_image）\n#define STB_IMAGE_IMPLEMENTATION#include &lt;stb_image.h&gt;unsigned int loadTexture(const char* path) &#123;    unsigned int textureID;    glGenTextures(1, &amp;textureID);    // 翻转Y轴（OpenGL原点在左下，图片原点在左上）    stbi_set_flip_vertically_on_load(true);    // 加载图片    unsigned char* data = stbi_load(path, &amp;width, &amp;height, &amp;nrChannels, 0);    // 设置纹理参数    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);  // U方向重复    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);  // V方向重复    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // 缩小    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);  // 放大    return textureID;&#125;\n1.4 纹理要求\n✅ 尺寸是2的幂：512、1024、2048、4096✅ RGB模式（不是CMYK）✅ 格式：JPG（无透明）、PNG（有透明）❌ 尺寸不是2的幂（如1920×1080）❌ CMYK模式的JPG\n1.5 着色器中使用\n// 顶点着色器layout (location = 2) in vec2 aTexCoord;out vec2 TexCoord;TexCoord = aTexCoord;// 片元着色器uniform sampler2D ourTexture;vec3 color = texture(ourTexture, TexCoord).rgb;\n\n 二、法线（Normal）\n2.1 什么是法线？\n法线 = 垂直于表面的方向向量 = 面朝哪边\n        ↑ 法线        │        │━━━━━━━━━━━━━━━ 表面\n2.2 球体的法线\n// 球体的法线 = 从球心指向顶点lengthInv = 1.0f / radius;nx = x * lengthInv;ny = y * lengthInv;nz = z * lengthInv;// 顶点数据：位置后面紧跟着法线[xyz][nx ny nz][u v]位置   法线    纹理\n2.3 法线的用途\n\n光照计算（核心！）\n\nvec3 norm = normalize(Normal);vec3 lightDir = normalize(lightPos - FragPos);float diff = max(dot(norm, lightDir), 0.0);  // 余弦值\n\n背面剔除\n\nglEnable(GL_CULL_FACE);glCullFace(GL_BACK);  // 不渲染球体内表面\n\n环境遮蔽、反射等高级效果\n法线变换（重要！）\n\n// 模型有旋转缩放时，法线不能直接乘model矩阵Normal = mat3(transpose(inverse(model))) * aNormal;\n\n 三、材质（Material）\n3.1 什么是材质？\n材质 = 物体表面如何与光交互的规则\n3.2 Phong光照模型的材质属性\n// 材质结构体struct Material &#123;    vec3 ambient;   // 环境光反射系数    vec3 diffuse;   // 漫反射反射系数    vec3 specular;  // 镜面反射反射系数    float shininess; // 反光度（越大高光越集中）&#125;;// 光源结构体struct Light &#123;    vec3 position;  // 光源位置    vec3 ambient;   // 环境光强度    vec3 diffuse;   // 漫反射强度    vec3 specular;  // 镜面反射强度&#125;;\n3.3 材质 = 纹理 + 光照参数\n// 纹理决定漫反射颜色vec3 diffuseColor = texture(ourTexture, TexCoord).rgb;// 材质参数控制光照响应float ambientStrength = 0.1;   // 环境光系数float specularStrength = 0.5;  // 镜面反射系数float shininess = 32.0;        // 反光度\n\n 四、光源（Light）\n4.1 三种光源类型\n// 1. 平行光（太阳）vec3 lightDir = normalize(-lightDirection);  // 方向固定// 2. 点光源（灯泡）vec3 lightDir = normalize(lightPos - FragPos);  // 有位置，向四周// 3. 聚光灯（手电筒）float theta = dot(lightDir, normalize(lightDirection));if(theta &gt; cutoffAngle) &#123; /* 照亮 */ &#125;\n4.2 Phong光照三要素\n// 1. 环境光（Ambient）// 永不黑暗，模拟全局光照反弹float ambientStrength = 0.1;vec3 ambient = ambientStrength * lightColor;// 2. 漫反射（Diffuse）// 粗糙表面，各向同性vec3 norm = normalize(Normal);vec3 lightDir = normalize(lightPos - FragPos);float diff = max(dot(norm, lightDir), 0.0);vec3 diffuse = diff * lightColor;// 3. 镜面反射（Specular）// 光滑表面，高光vec3 viewDir = normalize(viewPos - FragPos);vec3 reflectDir = reflect(-lightDir, norm);float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);vec3 specular = specularStrength * spec * lightColor;// 最终颜色vec3 result = (ambient + diffuse + specular) * objectColor;\n4.3 光源位置设置\n// 固定光源（太阳）glUniform3f(lightPosLoc, 2.0f, 2.0f, 2.0f);// 移动光源（手电筒）glUniform3f(lightPosLoc, sin(time) * 3.0f, 2.0f, cos(time) * 3.0f);// 光源跟随摄像机（头灯）glUniform3f(lightPosLoc, camX, camY, camZ);\n\n 五、完整渲染方程\n// Phong光照模型FinalColor = (    ambient +                    // 环境光（常数）    diffuse * max(0, N·L) +     // 漫反射（余弦定律）    specular * pow(max(0, R·V), shininess)  // 镜面反射（Phong）) * objectColor;// N: 法线// L: 光源方向// R: 反射方向// V: 视线方向","categories":["图形学"],"tags":["图形"]},{"title":"高等代数","url":"/2026/02/27/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/","content":" 一、多项式\n 1. 一元多项式的基本概念\n定义 1（多项式）\n设 PPP 是一个数域，xxx 是一个文字，形式表达式\nf(x)=anxn+an−1xn−1+⋯+a1x+a0f(x) = a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_1 x + a_0\nf(x)=an​xn+an−1​xn−1+⋯+a1​x+a0​\n称为数域 PPP 上的一元多项式，其中 ai∈Pa_i \\in Pai​∈P。\n定义 2（次数）\n若 an≠0a_n \\neq 0an​=0，则称 nnn 为多项式 f(x)f(x)f(x) 的次数，记作 deg⁡f(x)=n\\deg f(x) = ndegf(x)=n，ana_nan​ 称为首项系数。\n定义 3（多项式相等）\n两个多项式相等当且仅当它们的同次项系数全相等。\n 2. 多项式的运算\n性质 1\n设 f(x),g(x)∈P[x]f(x), g(x) \\in P[x]f(x),g(x)∈P[x]，则：\ndeg⁡(f(x)±g(x))≤max⁡{deg⁡f,deg⁡g}\\deg(f(x) \\pm g(x)) \\leq \\max\\{\\deg f, \\deg g\\}\ndeg(f(x)±g(x))≤max{degf,degg}\ndeg⁡(f(x)g(x))=deg⁡f+deg⁡g\\deg(f(x)g(x)) = \\deg f + \\deg g\ndeg(f(x)g(x))=degf+degg\n 3. 带余除法\n定理 1（带余除法）\n对于 f(x),g(x)∈P[x]f(x), g(x) \\in P[x]f(x),g(x)∈P[x]，g(x)≠0g(x) \\neq 0g(x)=0，存在唯一的 q(x),r(x)∈P[x]q(x), r(x) \\in P[x]q(x),r(x)∈P[x]，使得\nf(x)=q(x)g(x)+r(x)f(x) = q(x)g(x) + r(x)\nf(x)=q(x)g(x)+r(x)\n其中 deg⁡r(x)&lt;deg⁡g(x)\\deg r(x) &lt; \\deg g(x)degr(x)&lt;degg(x) 或 r(x)=0r(x) = 0r(x)=0。\n 4. 最大公因式\n定义 4（最大公因式）\n设 f(x),g(x)∈P[x]f(x), g(x) \\in P[x]f(x),g(x)∈P[x]，d(x)d(x)d(x) 称为 f(x)f(x)f(x) 与 g(x)g(x)g(x) 的最大公因式，若：\n\nd(x)∣f(x)d(x) \\mid f(x)d(x)∣f(x) 且 d(x)∣g(x)d(x) \\mid g(x)d(x)∣g(x)\n若 h(x)∣f(x)h(x) \\mid f(x)h(x)∣f(x) 且 h(x)∣g(x)h(x) \\mid g(x)h(x)∣g(x)，则 h(x)∣d(x)h(x) \\mid d(x)h(x)∣d(x)\n\n定理 2\nf(x)f(x)f(x) 与 g(x)g(x)g(x) 的最大公因式存在，且存在 u(x),v(x)∈P[x]u(x), v(x) \\in P[x]u(x),v(x)∈P[x] 使得\nd(x)=u(x)f(x)+v(x)g(x)d(x) = u(x)f(x) + v(x)g(x)\nd(x)=u(x)f(x)+v(x)g(x)\n 5. 因式分解定理\n定义 5（不可约多项式）\n次数 ≥1\\geq 1≥1 的多项式 p(x)p(x)p(x) 称为不可约的，若它不能表示为两个次数比它低的多项式的乘积。\n定理 3（唯一因式分解定理）\n数域 PPP 上任意次数 ≥1\\geq 1≥1 的多项式均可唯一分解为不可约多项式的乘积：\nf(x)=ap1r1(x)p2r2(x)⋯psrs(x)f(x) = a p_1^{r_1}(x) p_2^{r_2}(x) \\cdots p_s^{r_s}(x)\nf(x)=ap1r1​​(x)p2r2​​(x)⋯psrs​​(x)\n 6. 重因式\n定义 6（重因式）\n若不可约多项式 p(x)p(x)p(x) 满足 pk(x)∣f(x)p^k(x) \\mid f(x)pk(x)∣f(x) 但 pk+1(x)∤f(x)p^{k+1}(x) \\nmid f(x)pk+1(x)∤f(x)，则称 p(x)p(x)p(x) 为 f(x)f(x)f(x) 的 kkk 重因式。\n定理 4\n若 p(x)p(x)p(x) 是 f(x)f(x)f(x) 的 kkk 重因式，则 p(x)p(x)p(x) 是 f′(x)f&#x27;(x)f′(x) 的 k−1k-1k−1 重因式。\n 7. 复数域、实数域上的多项式\n定理 5（代数基本定理）\n每个次数 ≥1\\geq 1≥1 的复系数多项式在复数域中至少有一个根。\n定理 6\n复数域上的不可约多项式只有一次多项式。\n定理 7\n实数域上的不可约多项式只有一次多项式和判别式小于零的二次多项式。\n\n 二、行列式\n 1. 排列与逆序\n定义 7（排列）\n由 1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 组成的一个有序数组称为一个 nnn 级排列。\n定义 8（逆序数）\n排列中逆序的总数称为该排列的逆序数，记作 τ(i1i2⋯in)\\tau(i_1 i_2 \\cdots i_n)τ(i1​i2​⋯in​)。\n定义 9（奇偶排列）\n逆序数为奇数的排列称为奇排列，为偶数的称为偶排列。\n 2. nnn 阶行列式的定义\n定义 10\nnnn 阶行列式\ndet⁡A=∣a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮an1an2⋯ann∣=∑j1j2⋯jn(−1)τ(j1j2⋯jn)a1j1a2j2⋯anjn\\det A = \\begin{vmatrix}\na_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\na_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\na_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\n\\end{vmatrix} = \\sum_{j_1 j_2 \\cdots j_n} (-1)^{\\tau(j_1 j_2 \\cdots j_n)} a_{1j_1} a_{2j_2} \\cdots a_{nj_n}\ndetA=∣∣∣∣∣∣∣∣∣∣​a11​a21​⋮an1​​a12​a22​⋮an2​​⋯⋯⋱⋯​a1n​a2n​⋮ann​​∣∣∣∣∣∣∣∣∣∣​=j1​j2​⋯jn​∑​(−1)τ(j1​j2​⋯jn​)a1j1​​a2j2​​⋯anjn​​\n 3. 行列式的性质\n性质 2\n行列互换，行列式的值不变，即 det⁡A=det⁡AT\\det A = \\det A^TdetA=detAT。\n性质 3\n互换行列式的两行（列），行列式变号。\n性质 4\n行列式的某一行（列）有公因子 kkk，则可提到行列式外面。\n性质 5\n若行列式有两行（列）完全相同，则行列式为零。\n性质 6\n若行列式有两行（列）成比例，则行列式为零。\n性质 7\n将行列式的某一行（列）的 kkk 倍加到另一行（列）上，行列式的值不变。\n 4. 行列式按一行（列）展开\n定义 11（余子式）\n在 nnn 阶行列式中，划去 aija_{ij}aij​ 所在的行和列，剩下的元素按原次序组成的 n−1n-1n−1 阶行列式称为 aija_{ij}aij​ 的余子式，记作 MijM_{ij}Mij​。\n定义 12（代数余子式）\nAij=(−1)i+jMijA_{ij} = (-1)^{i+j} M_{ij}Aij​=(−1)i+jMij​ 称为 aija_{ij}aij​ 的代数余子式。\n定理 8（展开定理）\ndet⁡A=∑j=1naijAij(按第 i 行展开)\\det A = \\sum_{j=1}^n a_{ij} A_{ij} \\quad (\\text{按第 } i \\text{ 行展开})\ndetA=j=1∑n​aij​Aij​(按第 i 行展开)\ndet⁡A=∑i=1naijAij(按第 j 列展开)\\det A = \\sum_{i=1}^n a_{ij} A_{ij} \\quad (\\text{按第 } j \\text{ 列展开})\ndetA=i=1∑n​aij​Aij​(按第 j 列展开)\n 5. 克拉默法则\n定理 9（克拉默法则）\n若线性方程组\n{a11x1+a12x2+⋯+a1nxn=b1a21x1+a22x2+⋯+a2nxn=b2⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯an1x1+an2x2+⋯+annxn=bn\\begin{cases}\na_{11}x_1 + a_{12}x_2 + \\cdots + a_{1n}x_n = b_1 \\\\\na_{21}x_1 + a_{22}x_2 + \\cdots + a_{2n}x_n = b_2 \\\\\n\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots \\\\\na_{n1}x_1 + a_{n2}x_2 + \\cdots + a_{nn}x_n = b_n\n\\end{cases}\n⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​a11​x1​+a12​x2​+⋯+a1n​xn​=b1​a21​x1​+a22​x2​+⋯+a2n​xn​=b2​⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯an1​x1​+an2​x2​+⋯+ann​xn​=bn​​\n的系数行列式 D≠0D \\neq 0D=0，则方程组有唯一解：\nxj=DjD,j=1,2,⋯ ,nx_j = \\frac{D_j}{D},\\quad j = 1,2,\\cdots,n\nxj​=DDj​​,j=1,2,⋯,n\n其中 DjD_jDj​ 是将 DDD 的第 jjj 列换成常数项得到的行列式。\n\n 三、线性方程组\n 1. 消元法\n定义 13（矩阵）\n由 m×nm \\times nm×n 个数排成的 mmm 行 nnn 列的数表称为 m×nm \\times nm×n 矩阵。\n定义 14（阶梯形矩阵）\n满足以下条件的矩阵称为行阶梯形矩阵：\n\n零行在矩阵的最下方\n非零行的第一个非零元（称为主元）的列指标随行指标的增加而严格增加\n\n 2. 矩阵的秩\n定义 15（kkk 阶子式）\n在 m×nm \\times nm×n 矩阵 AAA 中，任取 kkk 行 kkk 列，位于这些行和列交叉处的元素按原次序组成的 kkk 阶行列式称为 AAA 的一个 kkk 阶子式。\n定义 16（秩）\n矩阵 AAA 的非零子式的最高阶数称为 AAA 的秩，记作 r(A)r(A)r(A)。\n 3. 线性方程组解的存在性\n定理 10（线性方程组有解判别定理）\n线性方程组 AX=BAX = BAX=B 有解的充要条件是系数矩阵的秩等于增广矩阵的秩：\nr(A)=r(Aˉ)r(A) = r(\\bar{A})\nr(A)=r(Aˉ)\n定理 11\n设 r(A)=r(Aˉ)=rr(A) = r(\\bar{A}) = rr(A)=r(Aˉ)=r，则：\n\n当 r=nr = nr=n 时，方程组有唯一解\n当 r&lt;nr &lt; nr&lt;n 时，方程组有无穷多解，自由未知量的个数为 n−rn - rn−r\n\n 4. 齐次线性方程组\n定理 12\nnnn 元齐次线性方程组 AX=0AX = 0AX=0 有非零解的充要条件是 r(A)&lt;nr(A) &lt; nr(A)&lt;n。\n定理 13\n当 m&lt;nm &lt; nm&lt;n 时，mmm 个方程 nnn 个未知数的齐次线性方程组必有非零解。\n\n 四、矩阵\n 1. 矩阵的运算\n定义 17（矩阵加法）\n设 A=(aij)m×nA = (a_{ij})_{m \\times n}A=(aij​)m×n​，B=(bij)m×nB = (b_{ij})_{m \\times n}B=(bij​)m×n​，则\nA+B=(aij+bij)m×nA + B = (a_{ij} + b_{ij})_{m \\times n}\nA+B=(aij​+bij​)m×n​\n定义 18（数乘矩阵）\nkA=(kaij)m×nkA = (k a_{ij})_{m \\times n}\nkA=(kaij​)m×n​\n定义 19（矩阵乘法）\n设 A=(aij)m×sA = (a_{ij})_{m \\times s}A=(aij​)m×s​，B=(bij)s×nB = (b_{ij})_{s \\times n}B=(bij​)s×n​，则 C=ABC = ABC=AB 是 m×nm \\times nm×n 矩阵，其中\ncij=∑k=1saikbkjc_{ij} = \\sum_{k=1}^s a_{ik} b_{kj}\ncij​=k=1∑s​aik​bkj​\n性质 8\n矩阵乘法满足结合律，不满足交换律。\n 2. 矩阵的转置\n定义 20（转置矩阵）\n将 A=(aij)m×nA = (a_{ij})_{m \\times n}A=(aij​)m×n​ 的行列互换得到的 n×mn \\times mn×m 矩阵称为 AAA 的转置，记作 ATA^TAT。\n性质 9\n(AT)T=A(A^T)^T = A(AT)T=A，(A+B)T=AT+BT(A + B)^T = A^T + B^T(A+B)T=AT+BT，(kA)T=kAT(kA)^T = kA^T(kA)T=kAT，(AB)T=BTAT(AB)^T = B^T A^T(AB)T=BTAT。\n 3. 逆矩阵\n定义 21（逆矩阵）\n对于 nnn 阶方阵 AAA，若存在 nnn 阶方阵 BBB 使得 AB=BA=InAB = BA = I_nAB=BA=In​，则称 AAA 可逆，BBB 称为 AAA 的逆矩阵，记作 A−1A^{-1}A−1。\n定理 14\nAAA 可逆 ⇔\\Leftrightarrow⇔ det⁡A≠0\\det A \\neq 0detA=0。\n定理 15\n若 AAA 可逆，则\nA−1=1det⁡AA∗A^{-1} = \\frac{1}{\\det A} A^*\nA−1=detA1​A∗\n其中 A∗A^*A∗ 是 AAA 的伴随矩阵。\n 4. 初等变换与初等矩阵\n定义 22（初等变换）\n三种行（列）变换：\n\n交换两行\n用非零常数乘某一行\n将一行的 kkk 倍加到另一行\n\n定义 23（初等矩阵）\n由单位矩阵经过一次初等变换得到的矩阵称为初等矩阵。\n定理 16\n对矩阵 AAA 施行初等行变换相当于左乘相应的初等矩阵；施行初等列变换相当于右乘相应的初等矩阵。\n 5. 矩阵的秩的性质\n性质 10\nr(A)=r(AT)r(A) = r(A^T)r(A)=r(AT)\n性质 11\nr(AB)≤min⁡{r(A),r(B)}r(AB) \\leq \\min\\{r(A), r(B)\\}r(AB)≤min{r(A),r(B)}\n性质 12\nr(A+B)≤r(A)+r(B)r(A + B) \\leq r(A) + r(B)r(A+B)≤r(A)+r(B)\n\n 五、二次型\n 1. 二次型的概念\n定义 24（二次型）\n含有 nnn 个变量 x1,x2,⋯ ,xnx_1, x_2, \\cdots, x_nx1​,x2​,⋯,xn​ 的二次齐次函数\nf(x1,x2,⋯ ,xn)=∑i=1n∑j=1naijxixjf(x_1, x_2, \\cdots, x_n) = \\sum_{i=1}^n \\sum_{j=1}^n a_{ij} x_i x_j\nf(x1​,x2​,⋯,xn​)=i=1∑n​j=1∑n​aij​xi​xj​\n称为二次型，其中 aij∈Pa_{ij} \\in Paij​∈P。\n定义 25（矩阵表示）\n二次型可表示为 f=XTAXf = X^T A Xf=XTAX，其中 AAA 为对称矩阵，称为二次型的矩阵。\n 2. 合同变换\n定义 26（合同）\n设 A,BA, BA,B 为 nnn 阶方阵，若存在可逆矩阵 CCC 使得 B=CTACB = C^T A CB=CTAC，则称 AAA 与 BBB 合同。\n性质 13\n合同关系是等价关系，且合同矩阵的秩相等。\n 3. 化二次型为标准形\n定理 17（配方法）\n任意二次型可通过非退化线性替换化为标准形：\nf=d1y12+d2y22+⋯+dnyn2f = d_1 y_1^2 + d_2 y_2^2 + \\cdots + d_n y_n^2\nf=d1​y12​+d2​y22​+⋯+dn​yn2​\n定理 18（正交变换法）\n对于实二次型，存在正交变换 X=QYX = QYX=QY 使其化为标准形：\nf=λ1y12+λ2y22+⋯+λnyn2f = \\lambda_1 y_1^2 + \\lambda_2 y_2^2 + \\cdots + \\lambda_n y_n^2\nf=λ1​y12​+λ2​y22​+⋯+λn​yn2​\n其中 λi\\lambda_iλi​ 是 AAA 的特征值。\n 4. 惯性定理\n定理 19（惯性定理）\n实二次型的标准形中，正平方项的个数 ppp 和负平方项的个数 qqq 是由二次型唯一确定的，与所做的非退化线性替换无关。(p,q)(p, q)(p,q) 称为惯性指数，p−qp - qp−q 称为符号差。\n 5. 正定二次型\n定义 27（正定二次型）\n实二次型 f=XTAXf = X^T A Xf=XTAX 称为正定的，若对任意非零向量 XXX，都有 f(X)&gt;0f(X) &gt; 0f(X)&gt;0。\n定理 20\n实二次型正定的充要条件是：\n\n它的标准形的所有系数都大于 0\n它的矩阵的所有顺序主子式都大于 0\n\n","categories":["-高等代数"],"tags":["-数学"]},{"title":"网络通信","url":"/2026/02/18/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/","content":" 应用层\n 一、应用层是干什么的？\n核心职责：让计算机理解人类意图\n应用层 = 网络应用的&quot;大脑&quot;你的需求：看网页、发邮件、传文件↓应用层翻译成：HTTP请求、SMTP命令、FTP操作↓网络传输\n 二、应用层协议家族\n2.1 Web通信：HTTP/HTTPS\n# HTTP就像&quot;明信片&quot; - 所有人都能看到内容GET /index.html HTTP/1.1      ← 你要什么Host: www.example.com          ← 找谁要User-Agent: Chrome             ← 谁在要Accept: text/html              ← 要什么格式# HTTPS = HTTP + 加密信封# 把明信片装进加密信封再寄# 关键特点：1. 无状态：服务器不记得你2. 请求-响应：一问一答3. 可扩展：各种Header自定义\n2.2 电子邮件：SMTP/POP3/IMAP\n# SMTP发送邮件（像邮局寄信）HELO client.example.com        ← 打招呼MAIL FROM:&lt;alice@example.com&gt;  ← 谁寄的RCPT TO:&lt;bob@example.org&gt;      ← 寄给谁DATA                           ← 开始写信From: Alice &lt;alice@example.com&gt;To: Bob &lt;bob@example.org&gt;Subject: Hello!This is the email body..                              ← 结束（一个点）QUIT                           ← 再见# POP3收邮件（像从邮箱取信）# IMAP更高级（像在邮局看信，信还在服务器）\n2.3 文件传输：FTP/SFTP\n# FTP命令（像远程文件管理器）$ ftp example.comConnected to example.com.Name: alicePassword: *****ftp&gt; ls                         # 列出文件ftp&gt; get file.txt              # 下载文件ftp&gt; put newfile.txt           # 上传文件ftp&gt; quit# SFTP = FTP + SSH加密# 更安全，但用法类似\n2.4 域名解析：DNS\n# DNS查询（像电话簿查询）你：www.google.com的IP是多少？↓DNS客户端：查询本地缓存 → 没有↓DNS递归解析器：问根服务器 → &quot;.com&quot;服务器在哪？↓根服务器：.com服务器是这些IP↓递归解析器：问.com服务器 → google.com服务器在哪？↓.com服务器：在这里↓递归解析器：问google.com服务器 → www的IP？↓google.com服务器：是 142.250.190.78↓你：知道了！连接142.250.190.78# 实际上用dig命令：$ dig www.google.com; ANSWER SECTION:www.google.com.    300    IN    A    142.250.190.78\n2.5 远程登录：SSH\n# SSH（像带加密的远程控制）$ ssh user@server.example.comPassword: *****# 连接后：1. 客户端和服务器协商加密算法2. 验证服务器身份（防止中间人攻击）3. 用户认证（密码或密钥）4. 建立加密通道# 你可以：$ ls                          # 执行命令$ vim file.txt                # 编辑文件$ scp local.txt user@server:~/  # 安全复制文件\n 三、现代应用层：不仅仅是协议\n3.1 RESTful API（现在最流行）\n# REST把网络资源当成&quot;物体&quot;来操作# 统一接口：HTTP方法对应CRUD操作GET    /api/users           # 获取用户列表GET    /api/users/123       # 获取用户123POST   /api/users           # 创建新用户PUT    /api/users/123       # 更新用户123DELETE /api/users/123       # 删除用户123# 请求示例：POST /api/users HTTP/1.1Content-Type: application/json&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;&#125;# 响应示例：HTTP/1.1 201 CreatedContent-Type: application/jsonLocation: /api/users/456&#123;&quot;id&quot;: 456, &quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;&#125;\n3.2 WebSocket（双向实时通信）\n// 传统HTTP：客户端问，服务器答（像对讲机）// WebSocket：双向随时通信（像电话）// 客户端JavaScriptconst socket = new WebSocket(&#x27;ws://example.com/chat&#x27;);socket.onopen = function() &#123;    // 连接建立，可以随时发消息    socket.send(&#x27;Hello Server!&#x27;);&#125;;socket.onmessage = function(event) &#123;    // 随时接收服务器消息    console.log(&#x27;Received:&#x27;, event.data);&#125;;// 服务器可以主动推消息，不用等客户端请求\n3.3 GraphQL（灵活的数据查询）\n# 传统REST：多个端点，固定返回格式# GraphQL：一个端点，客户端指定要什么# 客户端查询（只要id和name）query &#123;  user(id: &quot;123&quot;) &#123;    id    name  &#125;&#125;# 响应（只返回请求的字段）&#123;  &quot;data&quot;: &#123;    &quot;user&quot;: &#123;      &quot;id&quot;: &quot;123&quot;,      &quot;name&quot;: &quot;Alice&quot;    &#125;  &#125;&#125;# 可以复杂查询：query &#123;  user(id: &quot;123&quot;) &#123;    name    posts &#123;      title      comments &#123;        text        author &#123;          name        &#125;      &#125;    &#125;  &#125;&#125;\n 四、应用层的安全考虑\n4.1 HTTPS：HTTP的加密版本\n# HTTPS = HTTP + TLS加密# 建立连接过程：# 1. 客户端打招呼ClientHello  - 支持的TLS版本  - 支持的加密算法  - 客户端随机数# 2. 服务器回应ServerHello  - 选择的TLS版本和算法  - 服务器随机数  - 服务器证书（证明身份）# 3. 密钥交换客户端验证证书，生成预主密钥用服务器公钥加密发送# 4. 生成会话密钥双方用随机数+预主密钥计算相同密钥# 5. 加密通信开始之后所有HTTP数据用会话密钥加密\n4.2 OAuth 2.0（授权框架）\n# 你不用把密码给第三方应用，而是授权它访问# 流程：1. 用户点击&quot;用Google登录&quot;2. 跳转到Google授权页面3. 用户登录Google并同意授权4. Google返回授权码给应用5. 应用用授权码换访问令牌6. 应用用令牌访问用户数据# 请求示例：GET /oauth/authorize?  response_type=code&amp;  client_id=CLIENT_ID&amp;  redirect_uri=REDIRECT_URI&amp;  scope=email\n 传输层\n 一、传输层是干什么的？\n1.1 核心职责：进程到进程的通信\n应用层：浏览器 ↔ 网站传输层：Chrome进程(端口443) ↔ Nginx进程(端口443)关键概念：端口号（Port）- IP地址：找到哪台计算机- 端口号：找到哪个程序- 范围：0-65535  - 0-1023：知名端口（HTTP:80, HTTPS:443, SSH:22）  - 1024-49151：注册端口  - 49152-65535：动态/私有端口\n1.2 传输层的两大选择\nTCP（传输控制协议）：可靠的&quot;快递员&quot;  - 保证送达，保证顺序  - 速度较慢，开销较大  - 用于：网页、邮件、文件传输UDP（用户数据报协议）：快速的&quot;邮筒&quot;  - 不保证送达，不保证顺序  - 速度极快，开销极小  - 用于：视频流、游戏、DNS查询\n 二、TCP深度解析：可靠的连接\n2.1 TCP三次握手（建立连接）\n// 想象打电话的过程：// 客户端：喂，能听到吗？ (SYN)// 服务器：能听到，你能听到我吗？ (SYN+ACK)// 客户端：能听到，开始说吧！ (ACK)// 实际TCP数据包：// 包1：SYN, seq=1000// 包2：SYN, seq=2000, ACK=1001// 包3：ACK, seq=1001, ACK=2001// 为什么三次？不是两次或四次？// 两次：无法确认客户端收到服务器的SYN+ACK// 四次：冗余，第三次ACK已经足够\n2.2 TCP数据传输机制\n// TCP把数据分成&quot;段&quot;（segment）发送// 每个段有序列号，接收方按序重组// 发送方视角：1. 应用数据：&quot;Hello World&quot; (11字节)2. TCP分成：seq=1000, data=&quot;Hello &quot;           seq=1006, data=&quot;World&quot;3. 等待ACK：收到ACK=1011表示对方收到了// 接收方视角：收到seq=1000, data=&quot;Hello &quot; → 缓存收到seq=1006, data=&quot;World&quot;  → 拼成&quot;Hello World&quot;发送ACK=1011 (&quot;我收到了0-1010字节&quot;)// 如果乱序到达：收到seq=1006先到 → 等待seq=1000收到seq=1000后 → 一起交给应用层\n2.3 TCP可靠性保证的四大机制\n// 1. 确认应答（ACK）// 每收到数据，必须回复ACKstruct tcp_ack &#123;    uint32_t ack_number;  // &quot;我期望收到的下一个字节号&quot;    // 可以累积确认：ACK=5000 表示收到了0-4999&#125;;// 2. 超时重传// 发送数据后启动定时器（RTO - 重传超时）// 如果超时未收到ACK，重发数据// RTO动态调整：基于RTT（往返时间）// 3. 流量控制（滑动窗口）// 接收方：&quot;我缓冲区只剩1460字节了&quot;// 发送方：&quot;那我先发1460字节，等你腾出空间&quot;uint16_t window_size;  // 窗口大小字段，告诉对方能收多少// 4. 拥塞控制（保护网络）// 四个阶段：// - 慢启动：指数增长，试探网络容量// - 拥塞避免：线性增长，接近阈值// - 快速重传：收到3个重复ACK立即重传// - 快速恢复：拥塞后不回到慢启动\n2.4 TCP四次挥手（断开连接）\n// 想象挂电话：// 客户端：我说完了 (FIN)// 服务器：好的，我也说完了 (ACK + FIN)// 客户端：收到，再见 (ACK)// 实际过程：// 客户端 → FIN → 服务器 (我要关闭了)// 服务器 → ACK → 客户端 (知道了)// (这里可能有数据传输延迟)// 服务器 → FIN → 客户端 (我也要关了)// 客户端 → ACK → 服务器 (好的，再见)// 为什么需要TIME_WAIT状态？// 客户端发送最后一个ACK后等待2MSL（最大段生存期）// 原因：// 1. 确保对方收到ACK（如果没收到会重传FIN）// 2. 让旧连接的数据包在网络中消失，避免混淆新连接\n 三、UDP深度解析：简单的数据报\n3.1 UDP协议特点\n// UDP头只有8字节（TCP至少20字节）struct udphdr &#123;    uint16_t source_port;    // 源端口    uint16_t dest_port;      // 目标端口    uint16_t length;         // UDP头+数据总长度    uint16_t checksum;       // 校验和（可选）&#125;;// UDP的特点：// 1. 无连接：直接发送，不需要握手// 2. 不可靠：不保证到达，不保证顺序// 3. 无状态：不维护连接状态// 4. 无流量控制：能发多快发多快// 5. 无拥塞控制：可能淹没网络// 但正是这种&quot;简单&quot;在某些场景是优势\n3.2 UDP使用场景\n// 场景1：DNS查询// 请求：&quot;www.google.com的IP？&quot;// 响应：&quot;142.250.190.78&quot;// 特点：小数据包，快速响应，一次查询一次响应// 场景2：音视频流// 视频帧1 → 视频帧2 → 视频帧3// 丢了一帧？继续播下一帧！// 重传旧帧反而会导致卡顿// 场景3：在线游戏// 玩家位置更新：新位置比旧位置更重要// 如果位置包延迟，直接发最新位置// 场景4：DHCP（动态主机配置）// 广播请求IP配置，快速获取网络参数\n3.3 UDP的可靠性实现（可选）\n// 应用层可以在UDP基础上实现可靠性// 比如QUIC协议（HTTP/3的基础）// 简单可靠UDP实现思路：struct reliable_udp_header &#123;    uint32_t sequence;       // 序列号（应用层实现）    uint32_t ack;            // 确认号（应用层实现）    uint16_t flags;          // 标志位    uint8_t data[];          // 数据&#125;;// 应用层实现：// - 序列号保证顺序// - 确认和重传保证可靠// - 但比TCP更灵活：可以自定义重传策略\n 网络层\n 一、网络层是干什么的？\n1.1 核心职责：跨网络的数据包路由\n传输层：从进程到进程（港口到港口）网络层：从主机到主机（城市到城市）你的电脑（北京） → 路由器1 → 路由器2 → ... → 目标服务器（上海）网络层解决两个问题：1. 寻址：每台设备有唯一IP地址2. 路由：找到最佳路径送到目的地\n1.2 关键概念：IP地址\n// IPv4地址：32位，点分十进制表示192.168.1.100 = 11000000.10101000.00000001.01100100// 网络部分 + 主机部分192.168.1.0/24  // 前24位是网络，后8位是主机                // 这个网络可以有254台主机（1-254）// IPv6地址：128位，冒号分隔十六进制2001:0db8:85a3:0000:0000:8a2e:0370:7334// 简写：2001:db8:85a3::8a2e:370:7334// 特殊地址：127.0.0.1     本地环回（自己）192.168.x.x   私有地址（内网用）10.x.x.x      私有地址（大型内网）172.16.x.x    私有地址\n 二、IP协议详解\n2.1 IP包头结构\n// IPv4包头（20-60字节）struct iphdr &#123;#if defined(__LITTLE_ENDIAN_BITFIELD)    __u8    ihl:4,      // 头部长度（以4字节为单位，最小5）            version:4;  // 版本（4=IPv4）#elif defined(__BIG_ENDIAN_BITFIELD)    __u8    version:4,            ihl:4;#endif    __u8    tos;        // 服务类型（优先级、延迟、吞吐量要求）    __be16  tot_len;    // 总长度（头+数据，最大65535）    __be16  id;         // 标识（用于分片重组）    __be16  frag_off;   // 分片偏移和标志    __u8    ttl;        // 生存时间（每过一跳减1，到0丢弃）    __u8    protocol;   // 上层协议（6=TCP, 17=UDP, 1=ICMP）    __sum16 check;      // 头部校验和    __be32  saddr;      // 源IP地址    __be32  daddr;      // 目标IP地址    // 可选项（如果有）&#125;;// 关键字段解释：// TTL：防止数据包永远循环//   你 traceroute 时看到的就是TTL递减过程// Protocol：告诉接收方&quot;这是TCP包，交给TCP处理&quot;\n2.2 IP分片与重组\n// 问题：网络链路有MTU（最大传输单元）// 以太网MTU=1500字节，IP头20字节，所以数据最多1480字节// 如果数据更大怎么办？分片！// 分片过程：原始IP包：总长度3000字节↓ 分成3片：片1：偏移0，长度1500，更多分片标志=1片2：偏移1480，长度1500，更多分片标志=1片3：偏移2960，长度40，更多分片标志=0// 接收方重组：收到片2 → 等片1和片3收到片1 → 等片3收到片3 → 重组完成，交给上层// 现代网络避免分片：TCP有MSS（最大段大小）// TCP握手时协商MSS，保证数据小于MTU\n2.3 IP地址分类和子网划分\n# IP地址分类（传统）A类：0.0.0.0 - 127.255.255.255    # 前8位网络，后24位主机B类：128.0.0.0 - 191.255.255.255  # 前16位网络，后16位主机C类：192.0.0.0 - 223.255.255.255  # 前24位网络，后8位主机# CIDR（无类别域间路由）现代方法192.168.1.0/24      # 前24位是网络，后8位是主机10.0.0.0/8          # 前8位是网络，后24位是主机172.16.0.0/12       # 前12位是网络，后20位是主机# 子网划分：把一个大网络分成小网络192.168.1.0/24 分成4个子网：192.168.1.0/26   # 主机范围：1-62192.168.1.64/26  # 主机范围：65-126192.168.1.128/26 # 主机范围：129-190192.168.1.192/26 # 主机范围：193-254\n 三、路由：互联网的导航系统\n3.1 路由表：网络的&quot;地图&quot;\n# 查看Linux路由表$ ip route showdefault via 192.168.1.1 dev eth0      # 默认路由：不知道去哪的都发给网关192.168.1.0/24 dev eth0 proto kernel  # 本地网络：直接发送10.0.0.0/8 via 192.168.1.2 dev eth0   # 特定网络：通过特定网关# 路由表结构：# 目标网络 → 下一跳地址 → 出口网卡# 路由查找过程（最长前缀匹配）：目标IP：192.168.1.100匹配项：1. 192.168.1.0/24 dev eth0        ✓ 匹配24位，直接发送2. 192.168.0.0/16 via 10.0.0.1    ✗ 只匹配16位，不是最具体目标IP：8.8.8.8匹配项：1. 192.168.1.0/24 dev eth0        ✗ 不匹配2. default via 192.168.1.1 dev eth0 ✓ 默认路由匹配\n3.2 路由协议：路由器之间的&quot;语言&quot;\n// 路由器如何知道网络拓扑？// 通过路由协议交换信息// 1. RIP（路由信息协议） - 距离向量//    告诉邻居：&quot;我到网络A的距离是3跳&quot;//    问题：收敛慢，最大15跳// 2. OSPF（开放最短路径优先） - 链路状态//    每个路由器知道整个网络拓扑//    自己计算最短路径（Dijkstra算法）// 3. BGP（边界网关协议） - 路径向量//    互联网骨干路由器使用//    &quot;AS100：我能到网络A，路径是AS200→AS300&quot;//    AS：自治系统（一个运营商或大公司）\n3.3 路由过程详解\n// 数据包在路由器中的旅程// 路由器收到数据包：1. 检查目标IP地址2. 查找路由表3. 确定下一跳和出口接口4. 减少TTL（如果为0则丢弃）5. 重新计算校验和6. 转发到出口接口// 实际路由表示例（简化）：struct fib_table &#123;    struct trie *trie;  // 路由表用trie树组织    // ...&#125;;// 路由查找函数：struct fib_result fib_lookup(struct net *net, struct flowi *flp) &#123;    // 根据目标IP查找路由    // 返回下一跳地址、出口设备等&#125;\n 四、相关协议\n4.1 ARP：地址解析协议\n// 问题：网络层用IP地址，但链路层用MAC地址// ARP解决：&quot;这个IP地址对应的MAC地址是什么？&quot;// ARP请求（广播）：发送者：&quot;谁的IP是192.168.1.1？请告诉192.168.1.100&quot;以太网目标MAC：FF:FF:FF:FF:FF:FF（广播）// ARP响应（单播）：192.168.1.1：&quot;我是192.168.1.1，我的MAC是00:11:22:33:44:55&quot;// Linux ARP缓存：$ arp -a? (192.168.1.1) at 00:11:22:33:44:55 [ether] on eth0? (192.168.1.100) at aa:bb:cc:dd:ee:ff [ether] on eth0\n4.2 ICMP：互联网控制消息协议\n// IP协议的&quot;辅助协议&quot;，用于错误报告和诊断// ICMP类型：// 0: Echo Reply (ping响应)// 3: Destination Unreachable (目标不可达)// 5: Redirect (重定向)// 8: Echo Request (ping请求)// 11: Time Exceeded (超时，traceroute用)// 常见用途：// 1. ping：发送ICMP Echo Request，等待Reply// 2. traceroute：发送TTL=1的包，收到Time Exceeded，知道第一跳// 3. 网络错误：收到Destination Unreachable// ICMP头：struct icmphdr &#123;    __u8    type;       // 类型    __u8    code;       // 代码（更具体信息）    __sum16 checksum;   // 校验和    // 其他字段根据类型不同&#125;;\n4.3 NAT：网络地址转换\n// 问题：IPv4地址不够用// 解决方案：多个设备共享一个公网IP// NAT工作原理：内网设备：192.168.1.100:54321 → NAT路由器NAT路由器：转换源地址为 203.0.113.1:12345 → 互联网互联网响应：203.0.113.1:12345 → NAT路由器NAT路由器：转换目标地址为 192.168.1.100:54321 → 内网// NAT表记录：// 内网IP:端口 ↔ 公网IP:端口 映射关系// 类型：// 1. 静态NAT：固定映射（服务器用）// 2. 动态NAT：临时映射（普通用户用）// 3. PAT（端口地址转换）：多个内网IP用一个公网IP，不同端口区分\n 五、IPv6：下一代IP协议\n5.1 IPv6的优势\n// IPv6包头（固定40字节）struct ipv6hdr &#123;#if defined(__LITTLE_ENDIAN_BITFIELD)    __u8    priority:4,    // 流量类别            version:4;     // 版本（6）#elif defined(__BIG_ENDIAN_BITFIELD)    __u8    version:4,            priority:4;#endif    __u8    flow_lbl[3];   // 流标签    __be16  payload_len;   // 负载长度    __u8    nexthdr;       // 下一个头（类似IPv4的protocol）    __u8    hop_limit;     // 跳数限制（类似TTL）    struct in6_addr saddr; // 源地址（128位）    struct in6_addr daddr; // 目标地址（128位）&#125;;// IPv6改进：// 1. 地址空间巨大：2^128个地址（地球每平方米10^23个地址）// 2. 简化头部：固定40字节，无分片（路径MTU发现）// 3. 更好的安全性：IPsec内置// 4. 无NAT：每个设备都有公网地址// 5. 更好的QoS支持：流标签\n5.2 IPv6地址类型\n# IPv6地址表示2001:0db8:85a3:0000:0000:8a2e:0370:7334# 简写：2001:db8:85a3::8a2e:370:7334# 特殊地址：::1                          # 环回地址（类似127.0.0.1）fe80::/10                    # 链路本地地址（类似169.254.x.x）2000::/3                     # 全球单播地址（公网地址）ff00::/8                     # 多播地址# IPv4映射的IPv6地址：::ffff:192.0.2.1             # 表示IPv4地址192.0.2.1\n 链路层\n 一、链路层是干什么的？\n1.1 核心职责：同一网络内设备间的直接通信\n网络层：北京 → 上海（跨城市）链路层：你家 → 邻居家（同一条街）链路层只关心：1. 这个数据包在本地网络发给谁？2. 用什么样的&quot;信封&quot;（帧格式）包装？3. 如何避免邻居同时说话（冲突避免）？\n1.2 工作范围：一跳之内\n你的电脑 → 交换机/路由器 → 下一跳设备      ↑ 这一跳由链路层负责链路层不关心：- 数据包最终要去哪（那是网络层的事）- 数据内容是什么（那是上层的事）- 如何跨多个网络（那是路由的事）\n 二、以太网：最主流的链路层协议\n2.1 以太网帧结构\n// 以太网帧（最小64字节，最大1518字节）struct ethhdr &#123;    unsigned char h_dest[ETH_ALEN];   // 目标MAC地址 (6字节)    unsigned char h_source[ETH_ALEN]; // 源MAC地址 (6字节)    __be16 h_proto;                   // 上层协议类型 (2字节)    // 后面是数据（46-1500字节）    // 最后是CRC校验（4字节）&#125; __attribute__((packed));// 关键字段解释：// MAC地址：00:11:22:33:44:55//   - 前3字节：厂商标识（OUI）//   - 后3字节：设备序列号//   - 全球唯一（理论上）// 协议类型：// 0x0800: IPv4// 0x0806: ARP// 0x86DD: IPv6// 0x8100: VLAN标签\n2.2 MAC地址详解\n# 查看本机MAC地址$ ip link show eth02: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000    link/ether 00:11:22:33:44:55 brd ff:ff:ff:ff:ff:ff# MAC地址类型：00:11:22:33:44:55    # 单播地址（发给特定设备）ff:ff:ff:ff:ff:ff    # 广播地址（发给所有设备）01:00:5e:xx:xx:xx    # 多播地址（发给一组设备）# MAC地址由IEEE分配：00:11:22              # 可能是Intel网卡00:50:56              # VMware虚拟网卡08:00:27              # VirtualBox虚拟网卡\n 三、交换机：链路层的智能中枢\n3.1 交换机如何工作\n// 交换机维护一个MAC地址表// 记录：哪个MAC地址在哪个端口struct mac_table_entry &#123;    unsigned char mac[ETH_ALEN];  // MAC地址    int port;                     // 端口号    time_t timestamp;             // 上次看到的时间&#125;;// 交换机工作流程：1. 学习：收到帧时，记录源MAC和入口端口2. 转发：查看目标MAC，查表决定出口端口3. 广播：如果MAC不在表中，向所有端口转发（除入口）// 示例：端口1收到：源MAC=AA:BB:CC:DD:EE:FF，目标MAC=00:11:22:33:44:551. 学习：AA:BB:CC:DD:EE:FF在端口12. 查表：00:11:22:33:44:55在端口33. 转发：只从端口3转发出去// 如果目标MAC是广播地址ff:ff:ff:ff:ff:ff// 则向所有端口转发（泛洪）\n3.2 交换机的三种转发方式\n1. 存储转发（最常用）   - 接收完整帧   - 检查CRC错误   - 查表转发   - 延迟较大，但可靠2. 直通交换   - 收到目标MAC就开始转发   - 延迟小，但可能转发错误帧3. 无碎片交换   - 收到前64字节（避免冲突碎片）后转发   - 平衡了延迟和可靠性\n 四、无线网络（Wi-Fi）的链路层\n4.1 802.11帧结构\n// 无线帧比以太网帧复杂很多struct ieee80211_hdr &#123;    __le16 frame_control;     // 帧控制字段    __le16 duration_id;       // 持续时间/ID    u8 addr1[6];             // 接收方地址    u8 addr2[6];             // 发送方地址    u8 addr3[6];             // 过滤地址（通常BSSID）    __le16 seq_ctrl;          // 序列控制    // 可选：地址4、QoS控制等    // 然后是帧主体&#125;;// 无线网络的特殊问题：// 1. 共享介质：大家用同一频率，会冲突// 2. 隐藏节点：A和C都能和B通信，但彼此听不到// 3. 信号衰减：距离远了信号弱\n4.2 CSMA/CA：避免冲突的机制\n// 有线以太网用CSMA/CD：冲突检测// 无线用CSMA/CA：冲突避免（因为难以检测冲突）// CSMA/CA流程：1. 监听信道：如果忙，等待随机时间再试2. 发送RTS：请求发送（可选）3. 等待CTS：清除发送（可选）4. 发送数据5. 等待ACK：接收方确认收到// RTS/CTS解决隐藏节点问题：// A想发给B，但C在附近也在发// A发RTS，B回CTS，C听到CTS就知道信道被占用了\n 五、ARP协议再深入\n5.1 ARP完整流程\n// 情景：你的电脑(192.168.1.100)想访问路由器(192.168.1.1)// 步骤1：查ARP缓存$ arp -a? (192.168.1.1) at 00:11:22:33:44:55 [ether] on eth0// 如果有，直接使用MAC地址// 步骤2：如果没有，发送ARP请求// 以太网帧：目标MAC: ff:ff:ff:ff:ff:ff (广播)源MAC: aa:bb:cc:dd:ee:ff协议类型: 0x0806 (ARP)数据: &quot;谁的IP是192.168.1.1？告诉192.168.1.100&quot;// 步骤3：路由器回复目标MAC: aa:bb:cc:dd:ee:ff (你的电脑)源MAC: 00:11:22:33:44:55 (路由器)数据: &quot;我是192.168.1.1，MAC是00:11:22:33:44:55&quot;// 步骤4：更新ARP缓存// 现在知道192.168.1.1的MAC了\n5.2 ARP攻击与防御\n// ARP欺骗（中间人攻击）：// 攻击者发送虚假ARP响应：// &quot;我是192.168.1.1，MAC是攻击者的MAC&quot;// 结果：你的流量都经过攻击者// 防御：// 1. 静态ARP条目（手动绑定）$ arp -s 192.168.1.1 00:11:22:33:44:55// 2. ARP监控软件// 检测异常的ARP活动// 3. 交换机安全特性// 端口安全：每个端口只允许特定MAC// DHCP监听：防止虚假DHCP服务器\n 六、VLAN：虚拟局域网\n6.1 VLAN的作用\n问题：大型公司有多个部门，都在一个物理网络      - 财务部数据能被工程部看到      - 广播风暴影响所有部门解决方案：VLAN物理上一个交换机，逻辑上分成多个虚拟交换机\n6.2 VLAN帧格式\n// 带VLAN标签的以太网帧struct vlan_ethhdr &#123;    unsigned char h_dest[ETH_ALEN];    unsigned char h_source[ETH_ALEN];    __be16 h_vlan_proto;      // 固定0x8100    __be16 h_vlan_TCI;        // VLAN标签信息    __be16 h_vlan_encapsulated_proto;  // 上层协议    // 数据...&#125;;// VLAN TCI字段：// - PCP (3位): 优先级// - DEI (1位): 丢弃资格指示// - VID (12位): VLAN ID (1-4094)// 示例：VLAN 10：财务部 (192.168.10.0/24)VLAN 20：工程部 (192.168.20.0/24)VLAN 30：访客网络 (192.168.30.0/24)// 即使物理连接同一交换机，不同VLAN不能直接通信// 需要路由器（或三层交换机）在VLAN间转发\n 物理层\n 一、物理层是干什么的？\n1.1 核心职责：把0和1变成物理信号\n上层看到的是：0 1 0 1 0 1物理层看到的是：- 网线：高电压(1) 低电压(0) 高电压(1)- 光纤：亮(1) 灭(0) 亮(1)- 无线电：特定频率(1) 另一频率(0)物理层不关心：- 数据是什么意思- 数据要发给谁- 数据是否正确它只关心：怎么可靠地传输比特\n1.2 物理层的两大任务\n1. 编码：把比特变成信号   计算机：0101   物理层：高高低高高高低高（电压变化）2. 传输：把信号送到对面   通过：铜线、光纤、空气（无线）\n 二、有线传输：看得见的物理层\n2.1 以太网电缆（双绞线）\n// 常见的网线：Cat5e、Cat6、Cat7// 8根线分成4对，每对双绞（减少干扰）// 引脚定义（T568B标准）：引脚  颜色      用途1    白橙       TX+ (发送正)2    橙         TX- (发送负)3    白绿       RX+ (接收正)6    绿         RX- (接收负)4    蓝         (有时用于电话)5    白蓝7    白棕8    棕// 为什么双绞？// 每对线互相缠绕，外部干扰会同时影响两根线// 接收方比较两根线的差值，抵消干扰// 水晶头（RJ45）连接：1. 剥开外皮，理直8根线2. 按顺序排好：白橙、橙、白绿、蓝、白蓝、绿、白棕、棕3. 剪齐，插入水晶头4. 用压线钳压紧\n2.2 编码技术：如何表示0和1\n// 曼彻斯特编码（旧以太网用）// 每个比特中间都有跳变// 0：高→低跳变// 1：低→高跳变// 示例：数据： 0   1   0   1   0信号：高→低 低→高 高→低 低→高 高→低      |___| |___| |___| |___| |___|// 优点：自带时钟，接收方容易同步// 缺点：效率只有50%（每个比特都有跳变）// 4B/5B编码（更快以太网用）// 每4个数据比特映射为5个传输比特// 保证至少有2次跳变，保持同步// 效率：80%// 8B/10B编码（千兆以太网）// 每8比特映射为10比特// 平衡0和1的数量（直流平衡）\n2.3 物理层设备：中继器和集线器\n// 中继器（Repeater）：// 功能：放大信号，延长传输距离// 问题：也放大噪声// 现代基本不用，被交换机取代// 集线器（Hub）：// 多端口中继器// 收到信号 → 放大 → 转发给所有其他端口// 工作在物理层，没有智能// 集线器的问题：// 1. 所有设备共享带宽（10Mbps集线器，4个设备，每个最多2.5Mbps）// 2. 冲突域大：一个设备发数据，其他都要等// 3. 不安全：所有设备看到所有数据\n 三、无线传输：看不见的物理层\n3.1 Wi-Fi无线电基础\n// 无线网络在特定频率工作// 2.4GHz频段：// 信道1：2.412 GHz// 信道6：2.437 GHz// 信道11：2.462 GHz// （中国有13个信道，美国11个）// 5GHz频段：// 更多信道，更少干扰，但穿透力差// 调制技术：把数据加载到无线电波上// 1. BPSK：1比特/符号（最慢，最可靠）// 2. QPSK：2比特/符号// 3. 16-QAM：4比特/符号// 4. 64-QAM：6比特/符号（最快，需要好信号）// 5. 256-QAM：8比特/符号（Wi-Fi 6）// MIMO（多输入多输出）：// 多个天线同时收发，提高速度和可靠性\n3.2 无线信号特性\n# 无线信号随距离衰减（自由空间路径损耗）def path_loss(distance, frequency):    &quot;&quot;&quot;    distance: 距离（米）    frequency: 频率（Hz）    返回：路径损耗（dB）    &quot;&quot;&quot;    # 公式：PL = 20*log10(d) + 20*log10(f) + 20*log10(4π/c) - Gt - Gr    # 简化：每倍距离增加6dB损耗    return 20 * math.log10(distance) + 20 * math.log10(frequency) + 147.55# 示例：2.4GHz Wi-Fi，10米距离loss = path_loss(10, 2.4e9)  # 约60dB损耗# 障碍物影响：# 墙壁：3-10dB损耗# 地板：10-20dB损耗# 金属：完全阻挡\n 四、光纤传输：光速的物理层\n4.1 光纤原理\n// 光纤结构：// 核心：高折射率玻璃（直径9-62.5微米）// 包层：低折射率玻璃// 涂覆层：保护层// 工作原理：全内反射// 光在核心内反射前进，不会漏出// 两种类型：// 1. 多模光纤（MMF）：//    - 核心较粗（50或62.5微米）//    - 光有多种路径（模式）//    - 距离短（500米以内）//    - 便宜，用于局域网// 2. 单模光纤（SMF）：//    - 核心很细（9微米）//    - 光只有一种路径//    - 距离长（数十公里）//    - 贵，用于长途通信\n4.2 光传输系统\n// 光通信组件：// 1. 光源：激光二极管或LED//    - 激光：相干光，适合单模长距离//    - LED：非相干光，适合多模短距离// 2. 调制：直接调制或外调制//    - 直接：改变驱动电流改变光强//    - 外调制：恒定光源+外部调制器（更高速）// 3. 光纤：传输介质// 4. 探测器：光电二极管//    - PIN光电二极管：普通速度//    - 雪崩光电二极管（APD）：高灵敏度// 波分复用（WDM）：// 一根光纤传输多个波长（颜色）的光// 提高容量：160个波长 × 100Gbps = 16Tbps\n 五、物理层标准与速率\n5.1 以太网物理层标准\n# 常见以太网标准：10BASE-T:   10 Mbps, 双绞线, 100米100BASE-TX: 100 Mbps, Cat5双绞线, 100米   # 快速以太网1000BASE-T: 1 Gbps, Cat5e双绞线, 100米    # 千兆以太网10GBASE-T:  10 Gbps, Cat6a双绞线, 100米   # 万兆以太网# 光纤标准：1000BASE-SX: 1 Gbps, 多模光纤, 550米（850nm波长）1000BASE-LX: 1 Gbps, 单模光纤, 5公里（1310nm波长）10GBASE-SR:  10 Gbps, 多模光纤, 300米10GBASE-LR:  10 Gbps, 单模光纤, 10公里100GBASE-SR4: 100 Gbps, 多模光纤, 100米（并行4光纤）# 命名规则：- 10/100/1000：速率 Mbps- BASE：基带传输（数字信号）- T：双绞线，S：短波，L：长波，X：特殊编码\n5.2 Wi-Fi物理层标准\n# IEEE 802.11系列：802.11b: 2.4GHz, 最大11 Mbps (1999)802.11a: 5GHz, 最大54 Mbps (1999)802.11g: 2.4GHz, 最大54 Mbps (2003)802.11n: 2.4/5GHz, 最大600 Mbps (2009)  # Wi-Fi 4802.11ac: 5GHz, 最大6.9 Gbps (2014)      # Wi-Fi 5802.11ax: 2.4/5/6GHz, 最大9.6 Gbps (2019) # Wi-Fi 6802.11be: 即将发布，Wi-Fi 7，最大30 Gbps# 实际速度：标称速度 ≠ 实际速度- 802.11ac 1300Mbps → 实际约500-800Mbps- 802.11ax 2400Mbps → 实际约800-1200Mbps# 原因：协议开销、信号干扰、共享介质\n 六、物理层的关键问题与解决方案\n6.1 信号衰减与失真\n// 问题1：信号随距离衰减// 解决方案：中继器/放大器// 问题2：码间干扰（ISI）// 一个信号位影响下一个位// 原因：带宽有限，信号展宽// 解决方案：// 1. 均衡器：补偿频率响应// 2. 更好的编码：减少高频分量// 问题3：时钟同步// 发送方和接收方时钟有微小差异// 解决方案：// 1. 曼彻斯特编码：自带时钟// 2. 锁相环（PLL）：从数据流提取时钟// 3. 弹性缓冲区：容忍微小差异\n6.2 错误检测与纠正\n// 物理层不纠正错误（那是上层的事）// 但可以检测错误并标记// 常见技术：// 1. 奇偶校验：1位错误检测，不能纠正//    偶校验：数据中1的个数为偶数，校验位=0//    奇校验：数据中1的个数为奇数，校验位=1// 2. CRC（循环冗余校验）：以太网用//    发送方：数据 ÷ 生成多项式 = 余数，附加余数//    接收方：（数据+余数）÷ 生成多项式，应该余0//    能检测多位错误// 物理层发现错误 → 丢弃帧 → 上层重传\n","categories":["-网络通信"]}]